/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package FrameCreate;

import DataBaseTools.DataBase;
import Tools.StrTools;
import XMLTools.XMLSAX;
import globalData.globVar;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;

/**
 *
 * @author nazarov
 */
// --- Анализ удаленных таблиц ---
public class InspectionTablesFrame extends javax.swing.JFrame {

    public ArrayList<String> listObjLeft = new ArrayList<>(); // Объекты левой колонки
    public ArrayList<String> listObjRight = new ArrayList<>(); // Объекты правой колонки
    DefaultListModel<String> listModel = new DefaultListModel<String>(); // модель первого списка
    DefaultListModel<String> listModelTwo = new DefaultListModel<String>(); // модель второго списка
    HashMap<String, ArrayList<String>> mapData = new HashMap<>(); // тут хранятся сформированные данные для отображения
    String[] checkFieldTable = null; // хранятся выделлые группой элементы списков справа
    ArrayList<String> listT = null; // Лист Таблиц из базы
    String lastItemJlist = null; // меню которое было нажато последний раз

    /**
     * Creates new form InspectionTables
     */
    public InspectionTablesFrame() {
        this.setTitle("восстановление или полное удаление таблиц (помеченное как удаленные)."); // Установить заголовок
        initComponents();
        setDataToFrame();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        delete = new javax.swing.JMenuItem();
        recovery = new javax.swing.JMenuItem();
        jPanel1 = new javax.swing.JPanel();
        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList2 = new javax.swing.JList();

        delete.setText("удалить таблицу");
        delete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteActionPerformed(evt);
            }
        });
        jPopupMenu1.add(delete);

        recovery.setText("восстановить");
        recovery.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                recoveryActionPerformed(evt);
            }
        });
        jPopupMenu1.add(recovery);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jList1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jList1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jList1MousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(jList1);

        jSplitPane1.setLeftComponent(jScrollPane1);

        jList2.setComponentPopupMenu(jPopupMenu1);
        jList2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jList2MousePressed(evt);
            }
        });
        jScrollPane2.setViewportView(jList2);

        jSplitPane1.setRightComponent(jScrollPane2);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 568, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 480, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    

    // нажатие на список слева
    private void jList1MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList1MousePressed
        checkFieldTable = new String[jList1.getSelectedIndices().length]; // так вабираем выделенное
        if (checkFieldTable.length <= 1) { // обрабатываем только 1 элемент
            int index = jList1.locationToIndex(evt.getPoint());
            String nameMap = (String) jList1.getSelectedValue();
            updatejList(nameMap);
            lastItemJlist = nameMap;
        }
    }//GEN-LAST:event_jList1MousePressed

    // выделение и нажатие на списке справа
    private void jList2MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList2MousePressed

        if (evt.isPopupTrigger()) { //if the event shows the menu
            jList2.setSelectedIndex(jList2.locationToIndex(evt.getPoint())); //select the item
            jPopupMenu1.show(jList2, evt.getX(), evt.getY()); //and show the menu
        } else {
            checkFieldTable = new String[jList2.getSelectedIndices().length]; // вабираем выделенное
            // так заносим в список
            for (int i = 0; i < jList2.getSelectedIndices().length; ++i) {// Массив индексов
                String datainList = (String) jList2.getModel().getElementAt(jList2.getSelectedIndices()[i]);
                System.out.println(datainList);
                checkFieldTable[i] = datainList;
            }
        }
    }//GEN-LAST:event_jList2MousePressed

    // поп меню пункт удалить
    private void deleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteActionPerformed
        if (checkFieldTable.length > 0) { // если выделили не 1
            String delT = "Таблицы : ";
            for (String s : checkFieldTable) {
                //System.out.println("Delet t : " + s);
                globVar.DB.dropTable(s); // удаляем  безвозвратно
                delT += s + "\n ";
            }
            delT += "\n\n Удалены!";
            JOptionPane.showMessageDialog(null, delT); //сообщение
        }
        updatejList(lastItemJlist); // обновить правый лист
    }//GEN-LAST:event_deleteActionPerformed


    // поп меню пункт восстановить
    private void recoveryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_recoveryActionPerformed

        if (checkFieldTable.length > 1) { // если выделили не 1
            JOptionPane.showMessageDialog(null, "Восстановить можно только 1 таблицу \n"); //сообщение
        } else {
            for (String s : checkFieldTable) {
                globVar.DB.dropTableWithBackUp(lastItemJlist); // удаляем оригинал
                globVar.DB.renameTable(s, lastItemJlist); // восстанавливаем из Del
                JOptionPane.showMessageDialog(null, "Таблица" + s + " восстановлена \n"); //сообщение
            }
        }
        updatejList(lastItemJlist); // обновить правый лист

    }//GEN-LAST:event_recoveryActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
       
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new InspectionTablesFrame().setVisible(true);
            }
        });
    }

    // занести данные в формы
    public void setDataToFrame() {
        listModelTwo.clear(); // Очищаем модели
        listModel.clear();

//        XMLSAX.getConnectBaseConfig("Config.xml");
//        DataBase db = new DataBase();
//        globVar.DB = db;
        ArrayList<String> listT = globVar.DB.getListTable(); // формируем Лист

        // Сортируем имена таблиц
        Collections.sort(listT, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });

        // -- оставить только Del таблицы --
        for (int i = 0; i < listT.size(); ++i) {
            String s1 = listT.get(i);
            if (!s1.matches("^Del.*")) {// Если начинается не с Del автоматом пропускаем 
                listT.remove(i);
                --i;
            }
        }
        // формируем данные
        for (int i = 0; i < listT.size(); ++i) {
            ArrayList commonTables = new ArrayList<>();
            String commonName = null;
            String s1 = listT.get(i);

            // применем паттерн
            Pattern pattern0 = Pattern.compile("^Del((_[0-9]{2}){1,100}_)(.+)$");
            Matcher matcher0 = pattern0.matcher(s1);
            if (matcher0.matches()) {
                commonName = matcher0.group(3);
                System.out.println(commonName);

                if (commonName.equals("GPA_AO")) {
                    System.out.println("find");
                }
                // и еще раз удаленные таблицы тоже были удалены
                matcher0 = pattern0.matcher(commonName);
                if (matcher0.matches()) {
                    commonName = matcher0.group(3);
                    System.out.println(commonName);
                }
//                    for(int m =0; m <= matcher0.groupCount(); m++){
//                        System.out.println(matcher0.group(m));
//                    }
            }

            boolean firstEnter = true;
            for (int j = i + 1; j <= listT.size(); ++j) {
                if (j >= listT.size()) { // выход на последнем элементе
                    break;
                }
                String s2 = listT.get(j);
                // тут сравниваем строки своим методом(а вот и не используем находит подстроки мелкие =( ) 
                //commonName = StrTools.getCommonMaxStr(s1, s2);

                if (s2.matches(".*" + commonName + ".*")) { // если есть вхождение подстроки имени таблицы
                    // и первую и вторую таблицу заносим
                    if (firstEnter) {
                        commonTables.add(s1);
                        listT.remove(i);
                        firstEnter = false;
                        --i;
                        --j; // и j тоже сместится 
                        commonTables.add(s2);
                        listT.remove(j);
                        --j;
                    } else {
                        commonTables.add(s2);
                        listT.remove(j);
                        --j;
                    }
                }
            }
            // если не было повторения заносим единственное вхождение
            if (firstEnter) {
                commonTables.add(s1);
                listT.remove(i);
                --i;
            }
            // заносим в мэп если что то нашли
            if (commonName != null) {
                mapData.put(commonName, commonTables);
            }
        }

        // заносим данные в лист
        ArrayList<String> leftColumn = new ArrayList<>();
        for (Map.Entry<String, ArrayList<String>> item : mapData.entrySet()) {
            leftColumn.add(item.getKey());
        }
        // Сортируем левую колонку
        Collections.sort(leftColumn, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });
        // и данные в модель листа
        for(String s: leftColumn){
            listModel.addElement(s);
        }
        jList1.setModel(listModel);

//        // посчитать сколько данных по итогу
//        int iV =0;
//        for(Map.Entry<String, ArrayList<String>> entry : mapData.entrySet()) { // еще раз прогнать получить имена
//            String key = entry.getKey();
//            ArrayList<String> value = entry.getValue();
//            for(String s: value){
//                ++iV;
//            }
//         }
//        iV=0;
    }

    // Фукция обновления правого столбца
    public void updatejList(String nameMap) {
        setDataToFrame(); // перед этим дергаем базу нужно ли? 
        // обновляем данные в колонку 2
        listModelTwo.clear();
        for (String s : mapData.get(nameMap)) {
            listModelTwo.addElement(s);
        }
        jList2.setModel(listModelTwo);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem delete;
    private javax.swing.JList jList1;
    private javax.swing.JList jList2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPopupMenu jPopupMenu1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JMenuItem recovery;
    // End of variables declaration//GEN-END:variables
}
