/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package FrameCreate;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import DataBaseConnect.*;
import XMLTools.XMLSAX;
import globalData.globVar;
import org.w3c.dom.Node;

/**
 *
 * @author nazarov
 */
public class ExecutiveMechanism extends javax.swing.JFrame {

    //HashMap< String, Integer> addElementTable0 = new HashMap<>(); // элементы для отображения в левом полях
    //HashMap< String, Integer> addElementTable1 = new HashMap<>(); // элементы для отображения в правом поле
    ArrayList<String> addElementTable0 = new ArrayList<>(); // элементы для отображения в левом полях
    ArrayList<String> addElementTable1 = new ArrayList<>(); // элементы для отображения в правом поле
    private HashMap< String, Integer> listNamedGraphMap = new HashMap<>();
    DefaultListModel listModel = new DefaultListModel(); // модель для динамического добавления данных
    private DefaultListModel<String> listModel_two = new DefaultListModel<String>();
    String[] checkFieldTable = null; // массив выделенных в таблицах
    DataBase workbase; // подключаемся к базе и берем список
    ArrayList<ArrayList> listDataToTable; // ПРи старте сразу формируем данные
    String nameTable; // название таблицы и заголовка
    String[] columns; // названия колонок для таблицы в формате масива
    ArrayList<String> columnT; // названия колонок для таблицы
    /**
     * Creates new form ExecutiveMechanism
     */
    public ExecutiveMechanism(DataBase workbase) { // С передачей базы
        this.workbase = workbase;
        listDataToTable = readConfigExeMech();
        initComponents();
    }

    public ExecutiveMechanism() {
        this.workbase = DataBase.getInstance();
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel2 = new javax.swing.JPanel();
        jButton2 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new TableNzVer3(nameTable, columns, listDataToTable).getJTable();     // Новая таблица(а есть еще более новей);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton2.setText("добавить в базу");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jScrollPane1.setViewportView(jTable1);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 537, Short.MAX_VALUE)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 157, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jButton2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 415, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    // --- Кнопка добавления данных в базу ---
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        workbase.createTable(nameTable, columnT);
        for(ArrayList<String> array: listDataToTable){
            workbase.insertRows(nameTable, array.toArray(new String[array.size()]), columnT); // опять значения на оборот
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    // --- тестовый ---
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ExecutiveMechanism().setVisible(true);
            }
        });
    }

    // --- Фукция сортировки из HAsgMap
    List sortMap(HashMap< String, Integer> map) {
        List list = new ArrayList(map.entrySet()); // Новый отсортированный массив
        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {
            @Override
            public int compare(Map.Entry<Integer, Integer> a, Map.Entry<Integer, Integer> b) {
                return a.getValue() - b.getValue();
            }
        });
        return list;
    }

    // --- регулярка для сравнения столбцов  --
    String compareData(List<String> columnsB, String str2) {
        String findDat = null;
        String hmiIns = "_plc";
        boolean find = false;
        boolean patt0 = false;
        boolean patt1 = false;
        boolean pattHMI = false;
        Pattern pattern0 = Pattern.compile("^(" + str2 + "|" + str2.toUpperCase() + ")$"); // точное соответствие но с игнорированем CAPS
        //Pattern patternHMI = Pattern.compile("^.*(" + str2 + ".*" + hmiIns + "|" + str2.toUpperCase() + ".*" + hmiIns.toUpperCase() + ").*$"); // если в имени есть HMI
        Pattern patternHMI = Pattern.compile("^.*(" + str2 + ".*" + hmiIns + ")|(" + str2.toUpperCase() + ".*" + hmiIns.toUpperCase() + ").*"); // если в имени есть HMI
        Pattern pattern1 = Pattern.compile("^.*(" + str2 + "|" + str2.toUpperCase() + ").*$"); // Любая строка в верхнем и нижнем регистре
        Matcher matcher0;
        int equalI;
        for (int i = 0; i < columnsB.size(); ++i) { // Пробежим для анализа по ним
            String s = columnsB.get(i);
            matcher0 = pattern0.matcher(s); // Применяем строку к патерну точного совпадения
            if (matcher0.matches()) {
                findDat = s;
                patt0 = true;
                find = true;
                equalI = i;
                //break;
            }
            if (!patt0) { // сюда заходим если никогда не нашли что в списке
                matcher0 = patternHMI.matcher(s); // Применяем строку к патерну все внутри + строка hmiIns после 
                if (matcher0.matches()) {
                    findDat = s;
                    pattHMI = true;
                    find = true;
                    equalI = i;
                    //break;
                }
                if (!pattHMI) {
                    matcher0 = pattern1.matcher(s); // Применяем строку к патерну все внутри
                    if (matcher0.matches()) {
                        findDat = s;
                        patt1 = true;
                        find = true;
                        equalI = i;
                        // break;
                    }
                }
            }
        }
        return findDat;
    }

    // сопоставление имен сигналов, и списком возможных вариантов
    String comparSignals(String str1, String str2, String[] massEnd) {
        String finderS = null;
        String cutString = null;
        for (int i = 0; i < massEnd.length; ++i) { // пробегаем по списку окончаний отрезая окончания
            cutString = "^(.*)" + massEnd[i] + "$";
            Pattern pattern0 = Pattern.compile(cutString);
            Matcher matcher0 = pattern0.matcher(str1);  // впихиваем в сравнение 1 строку из входа
            if (matcher0.matches()) { // попали под патерн 
                //System.out.println(matcher0.group(0)); // Системный вывод
                str1 = matcher0.group(1);
                break; // до первого найденного
            }
        }

        for (int i = 0; i < massEnd.length; ++i) { // пробегаем по списку окончаний
            String patternS = "^(" + str1 + ").*" + massEnd[i] + "$"; // прикручиваем окончание и сравниваем
            Pattern pattern0 = Pattern.compile(patternS);
            Matcher matcher0 = pattern0.matcher(str2);  // впихиваем в сравнение 1 строку из входа
            if (matcher0.matches()) { // попали под патерн 
                finderS = str2;
                break; // до первого найденного
            }
        }
        return finderS;
    }

    // проверка имени сигнала, есть ли совпадения с списком c начала Строки
    boolean checkSignal(String str, String[] massName) {
        boolean enterSig = false;
        String cutString;
        for (int i = 0; i < massName.length; ++i) { // пробегаем по списку окончаний отрезая окончания
            cutString = "^(" + massName[i] + ".*)" + "|" + "^(" + massName[i].toUpperCase() + ".*)" + "$";
            //s= s.substring(0,1).toUpperCase() + s.substring(1); // может пригодится первый символ из строки в верхнем регистре
            //s = Character.toUpperCase(s.charAt(0)) + s.substring(1); // может пригодится первый символ из строки в верхнем регистре
            Pattern pattern0 = Pattern.compile(cutString);
            Matcher matcher0 = pattern0.matcher(str);  // впихиваем в сравнение строку из входа
            if (matcher0.matches()) { // попали под патерн 
                System.out.println("Findind unnecessary sig --> " + matcher0.group(0)); // Системный вывод
                enterSig = true;
                break; // до первого найденного
            }
        }
        return enterSig;
    }

    // --- чтение xml и формирование  из него каких таблиц читаем и что сапоставлять ---
    public ArrayList<ArrayList> readConfigExeMech() {
        ArrayList<ArrayList> findingTagname = new ArrayList();//листы для хранения найденного Что передаем
        nameTable = globVar.abonent + "_AM";    //  название таблицы строится
        this.setTitle(nameTable); // Установить заголовок
        columnT = new ArrayList<>(); // заготовка названия колонок
        String[] nameColumnList = new String[]{"TAG_NAME_PLC", "Наименование сигнала", "Наименование"}; // наименование колонок для выборки из базы
        ArrayList<String> listColumnSelect = new ArrayList(); // листы с колонками для запроса к базе
        ArrayList<ArrayList> listTagName = new ArrayList(); // 
        boolean firstStep = true; // Переменная первого прохода формирования списка
        int sumArraySize = 0; // Переменная для определения длинны формирования массива (не верно)
        int biforeSumArraySize = 0;
        
        XMLSAX readXML = new XMLSAX();
        Node rootN = readXML.readDocument(globVar.сonfigAMs); // Читаем конфигурационный файл
        ArrayList<Node> listNodeRootN = readXML.getHeirNode(rootN); // ноды рута AM_Classica, AM_NKU и тд
        for (Node n : listNodeRootN) {
            String nameN = n.getNodeName(); // имена первых нод названия иструментов
            ArrayList<Node> listNodeMethodExe = readXML.getHeirNode(n);
            
            for (Node nodeConEnd : listNodeMethodExe) { // пробегаем по commands endSensors
                HashMap<String, String> dataN = readXML.getDataNode(nodeConEnd); // только одно пока данное
                String nameCaseTable = dataN.get("tableName"); // берем названия из таблицы будет выборка данных
                // пробегаем по on off
                ArrayList<String> listOnOff = new ArrayList<>();
                ArrayList<String> listNameOnOff = new ArrayList<>();
                for (Node nodeOnOff : readXML.getHeirNode(nodeConEnd)) {
                    listNameOnOff.add(nameCaseTable + "_" +nodeOnOff.getNodeName()); // имена первых нод названия иструментов(уникальность названия стобцов для базы)
                    HashMap<String, String> dataOnOff = readXML.getDataNode(nodeOnOff); // только одно пока данное
                    String strEnd = dataOnOff.get("end"); // забираем окончания
                    listOnOff.add(strEnd);
                }

                listColumnSelect.clear(); // так как при следующих прогонах оно добавляет данные
                String nameTreq = globVar.abonent + "_" + nameCaseTable;
                List<String> columnsB = workbase.selectColumns(nameTreq); // возмем Названия колонок из таблицы
                
                for (String s : nameColumnList) { // Формируем список столбцов запросы к базе
                    String nameAlgColumn = compareData(columnsB, s); // передаем лист и строку на анализ соответствия(есть ли подобные столбцы). первый попавшийся возвращаем.
                    if (nameAlgColumn != null) {
                        listColumnSelect.add(nameAlgColumn); // Добавляем колонки для передачи в базу для запроса SELECT 
                        columnT.add(nameTreq +"_"+nameAlgColumn);
                    }
                }
                
                if (listColumnSelect.size() > 0) { //если есть что то для запроса к базе по столбцам
                    ArrayList<String[]> dataFromBase = workbase.getData(nameTreq, listColumnSelect); // получили массивы листов из базы 
                    listTagName.add(dataFromBase); // Кладем структуру в Лист
                    columnT.addAll(listNameOnOff); // Сращиваем с значениями нод
                } else {
                    JOptionPane.showMessageDialog(null, "Не найдены идентификаторы столбцов " + nameTreq); // Это сообщение
                }

                if (listTagName != null && listTagName.size() > 1) {
                    int elMass = 0; // первый элемент Листа
                    int numElTagName = 0;// номер элемента с tag_name массива для сравнения (надо определять автоматом)
                    int numElRusName = 1;//   
                    for (ArrayList<String[]> listDODI : listTagName) {
                        //columnT.add(nameCaseTable); 
                        for (int i = 0; i < listDODI.size(); ++i) {  // пробегаем по листу
                            String[] mass = listDODI.get(i);
                            ArrayList<String> findTmp = new ArrayList(); // Временный как часть строки
                            findTmp.add(mass[numElTagName]); // добавляем тэгнэм
                            findTmp.add(mass[numElRusName]); // Добавляем русское название
                            for (String ending : listOnOff) { // пробегаем по листу окончаний
                                String endingStr = "^(.*)" + "(" + ending + ")" + "$";
                                Pattern pattern0 = Pattern.compile(endingStr);
                                Matcher matcher0 = pattern0.matcher(mass[numElTagName]);  // tag_name в сравнение регуляркой
                                if (matcher0.matches()) { // попали под патерн 
                                    //System.out.println(matcher0.group(0)); // Системный вывод
                                    findTmp.add(matcher0.group(2));
                                } else {
                                    findTmp.add(""); // Пустую строку для матрицы
                                }
                            }
                            // Формирование матрицы данных
                            if (findingTagname.size() <= i) { // Проверка добавления строки или контекация Листов
                                if (firstStep) { // если первый проход только формируется лист
                                    findingTagname.add(findTmp);
                                    sumArraySize = findTmp.size();
                                } else{
                                    ArrayList<String> tmpMatrix = new ArrayList();
                                    for(int j=0; j<sumArraySize; ++j){
                                        tmpMatrix.add("");
                                    }
                                    tmpMatrix.addAll(findTmp); // сращиваем с пустым
                                    findingTagname.add(tmpMatrix); // и сформированный добавляем
                                }
                            } else {
                                findingTagname.get(i).addAll(findTmp); // контекация к строки колекции  
                            }
                        }
                        // сброс для следующих данных
                        firstStep = false;
                        //sumArraySize=0;
                    }
                    listTagName.clear();
                }
            }

        }
        columns = columnT.toArray(new String[columnT.size()]); // преобразовываем в массив
        return findingTagname;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton2;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables
}
