<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE Program >
<Program UUID="FI5DB4PAVCKUBGJGNZHXCJLJYU" Name="UVI_Algorithm" Period="250" PutDataAtEndOfCycle="true">
    <Variables>
        <Variable UUID="Y4JE23YFJNGEHOO5BNXEG3LKWQ" Name="Pulse" Type="FB_Pulse" TypeUUID="LCERBCVHMURELEDEHKKNKLUZNQ" Usage="internal" />
        <Variable UUID="HWRHWE3R2ZZUPNT24H6IKWBBGM" Name="Logic" Type="FB_Logic" TypeUUID="UB363VV3BHWEPNZS3N22GQE2PI" Usage="internal" />
        <Variable UUID="KXTWO5SLBVKE5ISBOZ3E73VYSA" Name="Imit" Type="FB_Imit" TypeUUID="6FYJFI56GMYUTBC5ILWW7D63N4" Usage="internal" />
        <Variable UUID="IIJHVTZLTMCUTFFK2IIUYSTNCA" Name="tmpBTN_ArchUser" Type="BOOL" Usage="internal" />
        <Variable UUID="N3G665G6UVUEXERBRUYBVSZQP4" Name="IM_Call" Type="FB_IM_Call" TypeUUID="XICUTQAGUXZEZLSIPSBXR2UEV4" Usage="internal" />
        <Variable UUID="K2M7Y667A33UDJ65LRXQ6ZMJ2A" Name="proc_UVI_UVI_mb_AI_CallAll_FB" Type="UVI_UVI_mb_AI_CallAll_FB" TypeUUID="Y4UUEO6BMA4EJAB2WLGFMUSQEY" Usage="internal" />
        <Variable UUID="HBGNSTUZNVZEPJFIOSDIWAIOZA" Name="proc_mb_UVI_DI" Type="mb_UVI_DI" TypeUUID="BIVT7BBFRN3E7IHJW2F3YOM43Q" Usage="internal" />
        <Variable UUID="4Z7TQMNKUWGE3BIHPNSPLBNILE" Name="mb_IM_UVI" Type="FB_mb_IM_UVI" TypeUUID="ARCJAQXZ64FELEYDH7EUWUXRJI" Usage="internal" />
    </Variables>
    <ST><![CDATA[//Определение длительности цикла
//cycle_time:
tim.tmpREALtime := CLOCK();
tim.cycle := LREAL_TO_REAL(tim.tmpREALtime - tim.tmpREALtime_prev);
tim.tmpREALtime_prev := tim.tmpREALtime;
//================================== Имитаторы ===================================
if ImitOn then Imit(); end_if;
//================================== ввод ==================================
//Обработка
UVI_AI_CallAll();
ANB_CallAll();
UVI_DI_CallAll();
//=== Драйверы смежных подсистем ===
//= УВИ - установка ввода ингибитора
proc_UVI_UVI_mb_AI_CallAll_FB();
UVI_UVI_mb_DI_CallAll();
proc_mb_UVI_DI();
//================================== АПС ==================================
APS_Init();
APS_CallAll(UVI_BTN.Deblock);
//================================== Регуляторы ==================================
//Инициализация
//Обработка
//================================== Логика =====================================
Logic();
//================================== ППУ ==================================
//Инициализация
//Обработка
//================================== Граф режимов ==================================
Mode_CallAll();
//================================== Барабаны ==================================
//DRM_CallAll();
//================================== Алгоритм ==================================
Alg_UVI();
//================================== ИМ ==================================
//Резервированные
//Обычные
IM_Call();
//= по модбасу
mb_IM_UVI();
//================================== Тренды ==================================
Trends(); // передача данных в тренды
//= запись архивов
UVI_SS.ArchStop := UVI_Mode.AOUVI;//= Архив останова
//= включение/выключение Пользовательского архива
tmpBTN_ArchUser := UVI_BTN.ArchUser;
UVI_BTN.ArchUser := FALSE;
if tmpBTN_ArchUser then
  if UVI_SS.ArchUser Then
    UVI_SS.ArchUser := FALSE;
  else
    UVI_SS.ArchUser := TRUE;
  end_if;
end_if;
//================================== Обмен по интерфейсам ==================================
//================================== вывод ==================================
UVI_DO_CallAll();
//=== Драйверы смежных подсистем ===
//= УВИ - установка ввода ингибитора
UVI_UVI_mb_DO_CallAll();
//==========================================================================================
//меандр
Pulse(true, T#1s, UVI_SS.CPU_HeartBit);
init:=true ;//=]]></ST>
    <DataTypes>
        <Struct UUID="VZ3H6GEVT3CUTI65HAA5AALRAY" Name="T_AI_FromHMI" Comment="команды из ЧМИ">
            <Field UUID="SCKERE4PHRDEBGWST4LC2RTTSE" Name="manualTarget" Comment="Задание из ЧМИ" Type="REAL" />
            <Field UUID="P47TXVXBU2GUBJ5JZEXSX4KSJ4" Name="BTNmanualOn" Comment="Кнопка вкл. задания значения из ЧМИ" Type="BOOL" />
            <Field UUID="GZSU6SS7CYNUPOLP767OZHJUK4" Name="BTNrepairOn" Comment="Кнопка вкл. ремонта" Type="BOOL" />
            <Field UUID="DI7XBJR5XPIE7L7MXPXMVNN3JI" Name="BTNworkOn" Comment="Кнопка перекл. в работу" Type="BOOL" />
            <Field UUID="R7L6QVFARZUU3FCBO456DXWXDQ" Name="BTNrepairProlong" Comment="Кнопка продления ремонта" Type="BOOL" />
        </Struct>
        <Struct UUID="GZ6UU5D6R5EXXPFY4TZ3EOTECU" Name="T_AI_Internal" Comment="Настройки канала">
            <Field UUID="URGJ7HGIJFACLBUMROBSRYNGTY" Name="qCycleROC" Comment="Количество циклов для контроля РОК" Type="INT" />
            <Field UUID="Z7HE4D7FEJA6XEO3ZT5EA5LEYI" Name="summCycleROC" Comment="сумма значений для РОК" Type="REAL" />
            <Field UUID="RW4U6LB23JHNFML2N4BQA7MLUE" Name="prevMeasure" Comment="Значение на предыдущем цикле" Type="REAL" />
            <Field UUID="QZTLVLZCD5A2FNOJWEQSSKV6WQ" Name="validMeasure" Comment="Последнее валидное измерение" Type="REAL" />
            <Field UUID="OTAS6CSOKJEYPNL7XMDFHUW3H4" Name="prevFault" Comment="наличие неисправности на предыдущем цикле " Type="BOOL" />
            <Field UUID="XWXRWWREWFAVBI2RI4EGZVP3HQ" Name="timerRecover" Comment="Таймер восстановления канала в работу после неисправности" Type="REAL" />
            <Field UUID="KKF6R5ONEBFP3DN2NJV3RM2STQ" Name="timerRepair" Comment="Таймер ремонта реальный" Type="REAL" />
        </Struct>
        <Struct UUID="XHUY6ZRHGRQEVOF35XEJI5L2SE" Name="T_AI_Settings" Comment="Настройки канала">
            <Field UUID="3KRWP62AKYDUFINJHEYQWHS2UU" Name="min" Comment="минимум шкалы канала, ед.изм. Не может быть &gt;= max" Type="REAL" />
            <Field UUID="RHO37XVNDVTUPEFTMJHSLHKUNY" Name="max" Comment="максимум шкалы канала, ед.изм. Не может быть &lt;= min" Type="REAL" />
            <Field UUID="RT6HE3WIDNSU7NDWHC2ZBOTRCI" Name="hiLim" Comment="уровень зашкала вверх, ед.изм. Не может быть &lt;= loLim и &gt; max" Type="REAL" />
            <Field UUID="NONAD4XZLCAUFCYSSF3ZG5Y2RM" Name="loLim" Comment="уровень зашкала вниз, ед.изм. Не может быть &gt;= hiLim и &lt; min" Type="REAL" />
            <Field UUID="IUL5HZOYX5CRDAD2EFAJYKUZ5Y" Name="hiBrk" Comment="уровень обрыва вверх, ед.изм. Не может быть &lt;= hiLim" Type="REAL" />
            <Field UUID="MYIPHEQSBJAADA2AH7XXTJLX64" Name="loBrk" Comment="уровень зашкала вниз, ед.изм. Не может быть &gt;= loLim" Type="REAL" />
            <Field UUID="35MUITRQHY5EPKM27DJOZ4D6SQ" Name="minADC" Comment="значение АЦП, соответствующее минимуму шкалы канала, б.р." Type="REAL" />
            <Field UUID="DW4YTEEV6RPEFHVBRONZ7WJRDI" Name="maxADC" Comment="значение АЦП, соотв. макс. шкалы, б.р. Не может быть равно minADC" Type="REAL" />
            <Field UUID="WIQAREZUYVCIVMICFARE4YILCI" Name="corrADC" Comment="корректировка минимуму АЦП" Type="REAL" />
            <Field UUID="YT5OLJPK5IAU7MM5REJ76FO7HM" Name="maxROC" Comment="макс. допустимая скорость роста, ед.изм./сек. Если «0» - скорость роста не анализируется" Type="REAL" />
            <Field UUID="Y52LQTQH7KVEPHEO2JGKSNLEYQ" Name="recoveryTime" Comment="время восстановления после неисправности, сек. Не может быть меньше &quot;0&quot;" Type="REAL" />
            <Field UUID="MX7EBZEDTNJUXGLTSFW2KWSO7U" Name="repairTime" Comment="максимальное время в ремонте, сек. Не может быть меньше или равно «0»" Type="INT" />
            <Field UUID="65QNI3SAURVUXMDDIVWNLWTPRA" Name="tau" Comment="тау фильтра, сек. Если «0» - фильтрация отсутствует" Type="REAL" />
            <Field UUID="CZKTSP7UMKMUHNAN43U4PZ3TDA" Name="id" Comment="номер по порядку" Type="INT" />
        </Struct>
        <Struct UUID="J74RQIZG5I6EZDCM32A6SZRKIM" Name="T_AI_ToHMI" Comment="устанавливаются программой обработки канала">
            <Field UUID="QJ6PEGLAUPLUFEIFAGBJIT6PW4" Name="PV" Comment="значение для САУ. Рассчитывается из  measure, Manual_Target с учётом неисправностей и фильтрации" Type="REAL" />
            <Field UUID="WBZOXI5CNLLEXLWHLINZ2KMYF4" Name="measure" Comment="Пересчёт кода АЦП в инженерные единицы" Type="REAL" />
            <Field UUID="6ZWUCOB6MR2ENPVJU6GJK7ZWXI" Name="CurrentTimeOfRepair" Comment="оставшееся время ремонта" Type="INT" />
            <Field UUID="GJY3VEM5KRNE5LIEPIA5A6MP5I" Name="fault_common" Comment="обобщённая неисправность. Образуется по «ИЛИ» от break,up_scale,down_scale,ROC,settingErr" Type="BOOL" />
            <Field UUID="3BIE4PEO6GDEZOARVMTGWNRJF4" Name="break" Comment="обрыв канала" Type="BOOL" />
            <Field UUID="JCRW2DPM2TFEDNS2CN4EMDRYHU" Name="up_scale" Comment="выход за верхний зашкал" Type="BOOL" />
            <Field UUID="4KBYMW34KEZE5ECIADCEQTZ6OA" Name="down_scale" Comment="выход за нижний зашкал" Type="BOOL" />
            <Field UUID="CKL3UGPLCBNUJBWI6XLA2VGNRQ" Name="ROC" Comment="превышение скорости изменения вверх или вниз" Type="BOOL" />
            <Field UUID="267MAGDT2FWEXMF4G7MQVHR24E" Name="settingErr" Comment="ошибка задания настроек – несоответствие допустимым значениям" Type="BOOL" />
            <Field UUID="S2TVATEJGHLUFBOP4OOPDLYPRA" Name="manual" Comment="канал в дист.упр." Type="BOOL" />
            <Field UUID="RBLIJTEXCENEXF4ULLUV3Q7PRU" Name="repair" Comment="канал в ремонте" Type="BOOL" />
            <Field UUID="TG5OXUO2FTCU5GZL2PWACX4G7E" Name="repair_time_less_10_percent" Comment="до конца ремонта осталось меньше 10% от заданного времени" Type="BOOL" />
            <Field UUID="YSARYMFTNDSE5LGQ3JNIXZZXTA" Name="as" Comment="отображать красным. Выставляется при выходе канала за аварийную уставку." Type="BOOL" />
            <Field UUID="UMPPDYIYCIUUFF73JAE2OWAUZM" Name="os" Comment="отображать фиолетовым. Выставляется при выходе канала за ограничительную уставку." Type="BOOL" />
            <Field UUID="I74VSDZAHPDUBF3C5UMMHZZF7M" Name="ps" Comment="отображать жёлтым. Выставляется при выходе канала за предупредительную уставку." Type="BOOL" />
            <Field UUID="RFUGWRJCW2IETLDPVQDEZRSKSE" Name="criticalFault" Comment="Критическая ошибка обработки" Type="BOOL" />
            <Field UUID="NAC3XDBC7TKE5COYOS7EGC37CY" Name="hint" Type="STRING" />
        </Struct>
        <Struct UUID="ANRR6BLMKETURJI5AWVQRMBAWA" Name="T_AM_Type" Comment="Типы ИМ">
            <Field UUID="R5GH244D3G6E5DEQ2KVL3QUOPI" Name="am1x0" Comment="1 команда, 0 конечников" Type="INT" />
            <Field UUID="EJFBQPJBB3XULMGIE7YE5QDS5Y" Name="am2x2fh" Comment="2 команды, 2 конечника (открытие, удержание)" Type="INT" />
            <Field UUID="PEAWQ344DBNUBPNVEK6VIDXUMQ" Name="am1x1" Comment="1 команда, 1 конечник" Type="INT" />
            <Field UUID="YXE6GIVXD3UUNKU3HRZPTTZBOE" Name="am1x2" Comment="1 команда, 2 конечника" Type="INT" />
            <Field UUID="MFOXKBTRKOKU3IUXG27BRR6PJU" Name="am2x1" Comment="2 команды, 1 конечник" Type="INT" />
            <Field UUID="CDSXEEZ5QJVETJCNSILRMROO5Q" Name="am2x2" Comment="2 команды, 2 конечника" Type="INT" />
            <Field UUID="XF7TYKMMVOAEXDRIKZ7ZD4YPTI" Name="am1ofx1of" Comment="1 команда OF, 1 конечник OF" Type="INT" />
            <Field UUID="QCC7QFFLWAIUFCBCEJXJDPMERY" Name="am1ofx2" Comment="1 команда OF, 2 конечника" Type="INT" />
            <Field UUID="4UM4UUEK6RMUPM6VL5ID7Q7ROY" Name="am1x1of" Comment="1 команда , 1 конечник OF" Type="INT" />
            <Field UUID="Y4PYZ4D5FQJUJN7SZNZX54JCW4" Name="amPos" Comment="Прочие с положением (АПК, ТРК...)" Type="INT" />
            <Field UUID="KBA3PS23ZYPEHHLFPRWZ6K2HSU" Name="am3x2" Comment="3 команды (on, off, stop), 2 конечника" Type="INT" />
            <Field UUID="ZMCVOELEKJSEHDWZMR7RVCXAQQ" Name="am2x2x3ware" Comment="2 команды, 2 конечника, трёхпроводная схема" Type="INT" />
            <Field UUID="5XGMK4PV7ZFK5OVFGH6GCCODQU" Name="am1x4nku" Comment="1 команда, 4 сигнала от НКУ" Type="INT" />
            <Field UUID="3ETYUGWR4FDSTEGO7ONOD7ACZA" Name="am2x7upp" Comment="2 команды (БП и УПП) и 7 сигналов от НКУ" Type="INT" />
            <Field UUID="ROV7ATBVJFGPPIFIL3A5A73ZOQ" Name="am2x8nku" Comment="2 команды и 8 сигналов от НКУ" Type="INT" />
        </Struct>
        <Struct UUID="I7SVZ4ZR3CPE7BHJZXJTI4JZXI" Name="T_ANB_Settings" Comment="Настройки уставки">
            <Field UUID="UXSEBOXIDKYENBCFLBBAZN2RZA" Name="setForFault" Comment="значение, записываемое в ANB при неисправности канала: 0 - FALSE, 1 - TRUE, 2 - оставить то что было" Type="INT" />
            <Field UUID="IPWZCJVRWK6U7JLH7P5RM5FSCQ" Name="isUp" Comment="направление срабатывания верхнее (FALSE - нижнее)" Type="BOOL" />
            <Field UUID="GDXKQ5WSUIYE5GF3QWM5WECPLM" Name="delay" Comment="задержка на срабатывание" Type="REAL" />
        </Struct>
        <Struct UUID="7GRLWKHH6VJU5KGLKDIOI5QPQI" Name="T_AO_FromHMI">
            <Field UUID="YQBDUQ2SLVH4VLPEMFQCTQ7MSA" Name="manualTarget" Comment="Задание из ЧМИ" Type="REAL" />
            <Field UUID="5X47MBB46NFXXFQYHPGECOG46U" Name="BTNforceOn" Comment="кнопка включения режима форсировки" Type="BOOL" />
            <Field UUID="2LUBNMQXIBEO7NYA7FMHMSQMQA" Name="BTNworkOn" Comment="Кнопка перекл. в работу" Type="BOOL" />
        </Struct>
        <Struct UUID="KOTCLUQLO7JERF5MDM2GMF62MI" Name="T_AO_ToHMI">
            <Field UUID="37PITYONYNCEPAA4FZ7CYI4ZZU" Name="forsPermit" Comment="Форсировка разрешена" Type="BOOL" />
            <Field UUID="EW23HL5DEBFQJMV2GMGKR3LXTE" Name="forsEnable" Comment="Форсировка включена" Type="BOOL" />
            <Field UUID="DXLEHCRAXMWERIXDDJCFFR6DXU" Name="hint" Type="STRING" />
        </Struct>
        <Struct UUID="Y2SUFYR34WCUVAETREJRLVIA74" Name="T_APS_Internal">
            <Field UUID="SW4246EO2NWU5CQN5ODA6OPOUI" Name="tmr" Comment="Счетчик времени задержки" Type="REAL" />
            <Field UUID="V6KC3PUL2GGUXCYZ4IXVPRX4NI" Name="pr_value" Comment="пред. значение" Type="BOOL" />
            <Field UUID="IYUBAOIBGQXEFF5UWNT4SITBCQ" Name="target" Comment="Реакция 1 пожар, 2 АОС, 3 АОБ, 4 АС, 5 ПС" Type="INT" />
        </Struct>
        <Struct UUID="3LFH3SQ4BNEUBDNWSPIFNTUGVM" Name="T_Alarm">
            <Field UUID="TP6VLFNYNVEF7BIWDTBZDPRT3Y" Name="PV" Comment="выход сигнализации" Type="BOOL" />
            <Field UUID="JMKHYKFLKRGTZFLJ5TNHWAUBSA" Name="in" Comment="входной сигнал" Type="BOOL" />
            <Field UUID="WAKIF66KNRGTPLOADFU6DYKTKA" Name="reset" Comment="сброс триггера сигнализации" Type="BOOL" />
            <Field UUID="EASYBTH2TJCUTOXQR33HQF3RHQ" Name="message" Comment="Сообщение в окне сигнализации и журнале событий" Type="STRING" />
            <Field UUID="4ORPFEZSGJEZPMMKOGHZYD3NNU" Name="category" Comment="Категория сигнала" Type="DINT" />
            <Field UUID="GGENP5F4QZBWRB5HSA4NRTUMT4" Name="tag" Comment="допинфо для служебных целей" Type="STRING" />
            <Field UUID="3FT5IZPWNVDLLKHR3CY5JIYW4A" Name="source" Comment="Источник сигнала" Type="STRING" />
            <Field UUID="O5BP7PZQHW2UTHK6E7UGS7KUJ4" Name="delay" Comment="Задержка аварии" Type="REAL" />
            <Field UUID="H5L4U32UMVFI7AQNSK2CE57B2M" Name="target" Comment="Режим, инициируемый сигналом" Type="INT" />
        </Struct>
        <Struct UUID="CB63GVNINFXE5NDGOS62CUMGSY" Name="T_DI_FromHMI" Comment="команды из ЧМИ">
            <Field UUID="ALOR7DBMYYIEBCY2WB7KWCUIGU" Name="manualTarget" Comment="Задание из ЧМИ" Type="BOOL" />
            <Field UUID="B22NFHW4UO5ETI7GYQLXF3XAJM" Name="BTNmanualOn" Comment="Кнопка вкл. задания значения из ЧМИ" Type="BOOL" />
            <Field UUID="S7MY7EBTY62UHGFUKNDBNJEETM" Name="BTNrepairOn" Comment="Кнопка вкл. ремонта" Type="BOOL" />
            <Field UUID="JJ6OIYCGVKUURBCSRNZ6KZLHKE" Name="BTNworkOn" Comment="Кнопка перекл. в работу" Type="BOOL" />
            <Field UUID="6QZL235TTWWEFK6PJPHINDPP5Y" Name="BTNrepairProlong" Comment="Кнопка продления ремонта" Type="BOOL" />
        </Struct>
        <Struct UUID="AZLZGZOBJZBF3NOVFVJWX37NVA" Name="T_DI_Internal">
            <Field UUID="YN54AUR7NFHDJHYR7DISKVNB5Y" Name="timerRepair" Comment="таймер ремонта" Type="REAL" />
            <Field UUID="4I4YCSS2CFBTJMCGATBEXGG5SE" Name="timerAntiTremor" Comment="таймер антидребезга" Type="REAL" />
        </Struct>
        <Struct UUID="YYQ4LFBFOMREFPHHDI3SPZLDYM" Name="T_DI_Settings" Comment="настройки дискретного канала">
            <Field UUID="7BUOL5BGDSCU7DUITC6LJYC3EE" Name="del" Comment="задержка для устранения дребезга, сек." Type="REAL" />
            <Field UUID="65RJRGUGBJYUTJEW5S27QVKBII" Name="repairTime" Comment="максимальное время в ремонте, сек. Не может быть «0»" Type="INT" />
            <Field UUID="E6BN5T6PFMLUNLPCUXHL4REAAE" Name="inv" Comment="необходимость инвертирования измеренного значения" Type="BOOL" />
            <Field UUID="L2JGFBG6KZFEFAFNVUGMAVU6YE" Name="id" Comment="номер по порядку" Type="INT" />
        </Struct>
        <Struct UUID="GHOQ5H5MCDOEHDF2HTYC2D4HJI" Name="T_DI_ToHMI" Comment="устанавливаются программой обработки канала">
            <Field UUID="TNUWHHXWAKSE7ARXDZINL2OUL4" Name="CurrentTimeOfRepair" Comment="оставшееся время ремонта" Type="INT" />
            <Field UUID="Q5OI5ENSF7VEHIS4O4MQ3YADRU" Name="settingErr" Comment="ошибка задания настроек – несоответствие допустимым значениям" Type="BOOL" />
            <Field UUID="4EHQPHFYYZ5EDCSGTFQTH6IA2I" Name="manual" Comment="канал в дист.упр." Type="BOOL" />
            <Field UUID="26KRQPMZSAFUHEQWAFEZYCEXNA" Name="repair" Comment="канал в ремонте" Type="BOOL" />
            <Field UUID="2FXLROIDYK2UXEJA6MWOZVCPEQ" Name="repair_time_less_10_percent" Comment="до конца ремонта осталось меньше 10% от заданного времени" Type="BOOL" />
            <Field UUID="RHBQXEPMIJENTNXBIRDAZVI6ZM" Name="fault_common" Comment="обобщённая неисправность. Образуется по «ИЛИ» от settingErr и неисправности цепи датчика" Type="BOOL" />
            <Field UUID="6W6OANKZ3VDE7IFEAF7IFND5TY" Name="hint" Type="STRING" />
        </Struct>
        <Struct UUID="ICYCYA5WR5FTZMTITNXXGA6V4U" Name="T_DO_FromHMI">
            <Field UUID="YQBDUQ2SLVH4VLPEMFQCTQ7MSA" Name="manualTarget" Comment="Задание из ЧМИ" Type="BOOL" />
            <Field UUID="5X47MBB46NFXXFQYHPGECOG46U" Name="BTNforceOn" Comment="кнопка включения режима форсировки" Type="BOOL" />
            <Field UUID="2LUBNMQXIBEO7NYA7FMHMSQMQA" Name="BTNworkOn" Comment="Кнопка перекл. в работу" Type="BOOL" />
        </Struct>
        <Struct UUID="JPIXI5FFWBGSRAAFIJ2MBV77UE" Name="T_DO_ToHMI">
            <Field UUID="37PITYONYNCEPAA4FZ7CYI4ZZU" Name="forsPermit" Comment="Форсировка разрешена" Type="BOOL" />
            <Field UUID="EW23HL5DEBFQJMV2GMGKR3LXTE" Name="forsEnable" Comment="Форсировка включена" Type="BOOL" />
            <Field UUID="WP3KGWM747AURJEIHTUIQJLS5M" Name="hint" Type="STRING" />
        </Struct>
        <Struct UUID="KHQWP3RHOTWEFJWBPCB6JIVNWI" Name="T_Graph">
            <Field UUID="57SADCQ574VUDHSCYRYH5NMZQU" Name="cond" Comment="Условия перехода" Type="DWORD" Size="32" Array="TRUE" />
            <Field UUID="VJA4I3MIFT3U3DQCKXBULCRNXU" Name="state" Comment="Номер режима" Type="INT" />
        </Struct>
        <Struct UUID="ESHVMMDQRNWUVGD5OOWOXN2N44" Name="T_mb_AI_Settings" Comment="Настройки канала">
            <Field UUID="3KRWP62AKYDUFINJHEYQWHS2UU" Name="min" Comment="минимум шкалы канала, ед.изм. Не может быть &gt;= max" Type="REAL" />
            <Field UUID="RHO37XVNDVTUPEFTMJHSLHKUNY" Name="max" Comment="максимум шкалы канала, ед.изм. Не может быть &lt;= min" Type="REAL" />
            <Field UUID="RT6HE3WIDNSU7NDWHC2ZBOTRCI" Name="hiLim" Comment="уровень зашкала вверх, ед.изм. Не может быть &lt;= loLim и &gt; max" Type="REAL" />
            <Field UUID="NONAD4XZLCAUFCYSSF3ZG5Y2RM" Name="loLim" Comment="уровень зашкала вниз, ед.изм. Не может быть &gt;= hiLim и &lt; min" Type="REAL" />
            <Field UUID="IUL5HZOYX5CRDAD2EFAJYKUZ5Y" Name="hiBrk" Comment="уровень обрыва вверх, ед.изм. Не может быть &lt;= hiLim" Type="REAL" />
            <Field UUID="MYIPHEQSBJAADA2AH7XXTJLX64" Name="loBrk" Comment="уровень зашкала вниз, ед.изм. Не может быть &gt;= loLim" Type="REAL" />
            <Field UUID="6EEWY5YRIALELEVHNEOYVOVOKI" Name="format" Comment="Формат данных" Type="INT" />
            <Field UUID="UN2HNI376ZEU7EIB4YK7GZB34Y" Name="set1" Comment="Настройка 1" Type="REAL" />
            <Field UUID="OC357N75CFDUJLIQMDTSPYRANE" Name="set2" Comment="Настройка 2" Type="REAL" />
            <Field UUID="65QNI3SAURVUXMDDIVWNLWTPRA" Name="tau" Comment="тау фильтра, сек. Если «0» - фильтрация отсутствует" Type="REAL" />
            <Field UUID="CZKTSP7UMKMUHNAN43U4PZ3TDA" Name="id" Comment="номер по порядку" Type="INT" />
        </Struct>
        <Struct UUID="7ICVQVNQUR4UDG5AFGOT7BUCRA" Name="T_mb_AO_Settings">
            <Field UUID="PFXFJNM5WZBD7OHBISHXLQZ7LI" Name="min" Comment="Нижний порог ан.выхода в физ.единицах" Type="REAL" />
            <Field UUID="XFVOQ6QGIJAYHPPXMK6QYRI72A" Name="max" Comment="Верхний порог ан.выхода в физ.единицах" Type="REAL" />
            <Field UUID="U6PH5R5T7W7URHY7YARC4WTDC4" Name="format" Type="INT" />
            <Field UUID="A4U4GLRHWKSUNEDN2B433ZBATQ" Name="set1" Type="REAL" />
            <Field UUID="CTPDFG3CV5EEJLI5W2OAFCVLLU" Name="set2" Type="REAL" />
            <Field UUID="OK4EUCFXPNFV7EZMRH56FV3Y4M" Name="id" Type="INT" />
        </Struct>
        <Struct UUID="EKXWTT2XQFVEBA2O4SGLDA6X4E" Name="T_tuneAM">
            <Field UUID="O6YCSYX2QRLUTFJS52ZQUGTAWU" Name="delayChangeOvertimeAlert" Comment="Время перестановки, при превышении которого выдается предупреждение" Type="REAL" />
            <Field UUID="JGXKJLANO2SELHO62MUIPISOLM" Name="delayQTimeout" Comment="Время перестановки, при превышении которого снимается выходная команда" Type="REAL" />
            <Field UUID="WCIMRV5J5ANE7HJUA6CNAGFFG4" Name="delayExtraOn" Comment="Время дожима на открытие" Type="REAL" />
            <Field UUID="TI3CBQNB5L5UXB5JAB22HNT2WE" Name="delayExtraOff" Comment="Время дожима на закрытие" Type="REAL" />
            <Field UUID="F5QLAOOZQ23E5PP4LDMIH4DAZU" Name="delayNotMoveAlert" Comment="Задержка формирования нестрагивания" Type="REAL" />
            <Field UUID="TYZJFVKVMAREDE55SVBM4IKIQQ" Name="delayCircBrkAlert" Comment="Задержка формирования обрыва контроля цепи" Type="REAL" />
        </Struct>
        <Struct UUID="JOKANQL3O4QURP2EITPYYDMUV4" Name="support_AM" Comment="v1.0 от 20170724">
            <Field UUID="AJPZSGTBOZSURAEDGCYX3WHU3E" Name="iOn" Comment="Вход - &quot;включен&quot; (открыт)" Type="BOOL" />
            <Field UUID="6OD2DJH7NPKELOTUDZ75Y2AKVQ" Name="iOff" Comment="Вход - &quot;отключен&quot; (закрыт)" Type="BOOL" />
            <Field UUID="TB67SA6DTYPEDKISO6NAMC5SWQ" Name="iCon" Comment="Вход - контроль цепи включения (открытия)" Type="BOOL" />
            <Field UUID="EIFZU5L22RQUXBFPPCCT236FCQ" Name="iCoff" Comment="Вход - контроль цепи отключения (закрытия)" Type="BOOL" />
            <Field UUID="GIVBYIHUOBNU5DS3D7NB6IIQEA" Name="qOn" Comment="Выход - &quot;включить&quot; (открыть, форсировка)" Type="BOOL" />
            <Field UUID="B3U4CEPC5FQEXKDEAGWOPCDWZU" Name="qOff" Comment="Выход - &quot;отключить&quot; (закрыть)" Type="BOOL" />
            <Field UUID="5OXOOXY3F2CEHER2BZBJPT3FSA" Name="qHoldOn" Comment="Выход - &quot;удержание&quot; (трехходовой клапан)" Type="BOOL" />
            <Field UUID="W6BNQGNNUFSUXGQ3RZQ4V2XMD4" Name="algOn" Comment="Команда включения из алгоритма" Type="BOOL" />
            <Field UUID="Z3KAE3E5VX5UDAOPXTO4SUHYEY" Name="algOff" Comment="Команда отключения из алгоритма" Type="BOOL" />
            <Field UUID="U3KPWCQJYP4E7O6Z6S6U43Q2V4" Name="modeManual" Comment="Режим ручного управления" Type="BOOL" />
            <Field UUID="VSW5JXZJSMLUZFMXRYKWIBFB2I" Name="disableManual" Comment="Блокировка ручного управления" Type="BOOL" />
            <Field UUID="JO4FIXI66MRULCSWOZ7JRQSOBA" Name="disableCon" Comment="Не учитывать контроль цепи управления команды &apos;открыть&apos;" Type="BOOL" />
            <Field UUID="UZCWPJ5FO2OETORGJUJ77MHWEQ" Name="disableCoff" Comment="Не учитывать контроль цепи управления команды &apos;закрыть&apos;" Type="BOOL" />
            <Field UUID="XB6FRKLPQHBU3KBCQJ2O4LMWOI" Name="btnMode" Comment="Кнопка переключения режима Ручной/Авто (СКАДА)" Type="BOOL" />
            <Field UUID="HQXXP3VK6B7UFEZCLYPOAIJCVE" Name="btnOn" Comment="Кнопка &quot;включить&quot; (СКАДА)" Type="BOOL" />
            <Field UUID="EUREFPVUSAJU5MPE72IMKULFAQ" Name="btnOff" Comment="Кнопка &quot;отключить&quot; (СКАДА)" Type="BOOL" />
            <Field UUID="AILDXTDC3NIELCLUI3YK5YT24Q" Name="prmBtnOn" Comment="Разрешение ручного включения в авто-режиме (для повтора команды)" Type="BOOL" />
            <Field UUID="N3ML4S2CGYTUNLC75YT4BMSOZE" Name="prmBtnOff" Comment="Разрешение ручного отключения в авто-режиме (для повтора команды)" Type="BOOL" />
            <Field UUID="T6O6PYG5FOHE5M2XV53ZQ6EC4Q" Name="fNotOn" Comment="Не включен" Type="BOOL" />
            <Field UUID="FGO5HC5NS2AENDSJ7FTV6YTIKM" Name="fNotOff" Comment="Не отключен" Type="BOOL" />
            <Field UUID="SUNJAVMMKXFUTFOAEJWMDGD4B4" Name="fNotStart" Comment="Не стронулся" Type="BOOL" />
            <Field UUID="UOQBPEA7JBMU7KFLOB4CAR2Q5A" Name="fSelfOn" Comment="Самопроизвольное включение" Type="BOOL" />
            <Field UUID="DJLHHLRC674EHNL2W5UHHLPB4Y" Name="fSelfOff" Comment="Самопроизвольное отключение" Type="BOOL" />
            <Field UUID="URJGYYBT4DXU5N4YI3XNJOKP5M" Name="fFB" Comment="Двойное положение" Type="BOOL" />
            <Field UUID="WPU7QKFWK6TU5DDMTVHYF5AIOY" Name="fCon" Comment="Нет контроля цепи включения" Type="BOOL" />
            <Field UUID="WJBPVHFY5IPEZOLM74FY44PYMY" Name="fCoff" Comment="Нет контроля цепи отключения" Type="BOOL" />
            <Field UUID="3QBLSEMS7OCERKXNV3GPVS7PNM" Name="fCommon" Comment="Обобщенная неисправность" Type="BOOL" />
        </Struct>
    </DataTypes>
    <FBLibrary>
        <Folder Name="IM" Comment="" Data="" UUID="3P5RSX363WPURKC57HXHKHJFIY">
            <FunctionBlock UUID="JIOIQ3APYP4UTCXLJQK7Q6LHCA" Name="FB_IM" Comment="FB Исполнительных механизмов">
                <Variables>
                    <Variable UUID="5XYFD3YZLLBUNB42KO2XYNFDCU" Name="AMtype" Comment="тип ИМ" Type="INT" Usage="input" />
                    <Variable UUID="PETOOKKOZ5ZUHGDFGUI235UOWE" Name="AM" Comment="структура ИМ" Type="support_AM" TypeUUID="JOKANQL3O4QURP2EITPYYDMUV4" Usage="inout" />
                    <Variable UUID="FECD53T2D3CUTMVI42ECGHMCLY" Name="tuns" Comment="Настройки ИМ" Type="T_tuneAM" TypeUUID="EKXWTT2XQFVEBA2O4SGLDA6X4E" Usage="input" />
                    <Variable UUID="EDVZIRQWLT3UDFKHACOVGWPYM4" Name="cycle" Comment="цикл вызова (с)" Type="REAL" Usage="input" />
                    <Variable UUID="MC7WZK735E7EDGYPA7FMYZ6ZYY" Name="onImit" Comment="включить режим имитации" Type="BOOL" Usage="input" />
                    <Variable UUID="KNJWSZAW7KLUHKINAJIYOXQUFU" Name="imtChangeTime" Comment="время переключения состояния для имитатора" Type="REAL" InitialValue="4" Usage="input" />
                    <Variable UUID="YJALDEKXZIAEBF7TAWFK34VG7A" Name="I_ON" Type="BOOL" Usage="input" />
                    <Variable UUID="JACB2RJGQM3EJFEEH5UBKF5TIM" Name="I_OFF" Type="BOOL" Usage="input" />
                    <Variable UUID="ICKZ3QWAXBMUTKG6JQNPTEC2QM" Name="I_Con" Type="BOOL" Usage="input" />
                    <Variable UUID="EMWHYR3US7OUVAQURMVK5WK2VU" Name="I_Coff" Type="BOOL" Usage="input" />
                    <Variable UUID="7M6X7SOAZ6CE3C3LKAET4H3KUA" Name="unlock" Type="BOOL" Usage="input" />
                    <Variable UUID="PDPZIK7RNIGEZALSPLREI2IPK4" Name="Q_ON" Type="BOOL" Usage="output" />
                    <Variable UUID="V6MUNN55PDPUTAJTEWOJUXQR6U" Name="Q_OFF" Type="BOOL" Usage="output" />
                    <Variable UUID="RKQGJ6QQUGQUXAIFQADPHSMOUM" Name="Q_HoldOn" Type="BOOL" Usage="output" />
                    <Variable UUID="BTZJYNYJ2UUURFURQFWR6S5O3Y" Name="ps" Comment="Сигналка предупреждения" Type="BOOL" Usage="output" />
                    <Variable UUID="HO5QMS37KGRUFNJ4JJRITZIMP4" Name="algOn" Comment="команда открытия от алгоритма" Type="BOOL" Usage="internal" />
                    <Variable UUID="CMXCEEFW6Z6ENAFCXGRHJOGI6M" Name="algOff" Comment="команда закрытия от алгоритма" Type="BOOL" Usage="internal" />
                    <Variable UUID="IZJKEDDZ47GUFO7BOZC7YKLQZE" Name="iOn" Comment="сигнал (конечник) открытия" Type="BOOL" Usage="internal" />
                    <Variable UUID="IT7YET3ZRL2EDH6OY4RZ7F5AKI" Name="iOff" Comment="сигнал (конечник) закрытия" Type="BOOL" Usage="internal" />
                    <Variable UUID="JZG6WQHPJMMUZBZE7X2FA4VPKM" Name="qOn" Comment="выход на открытие" Type="BOOL" Usage="internal" />
                    <Variable UUID="ZPLMRSLMHTCUHIP6TYW4CL2N5I" Name="qOff" Comment="выход на закрытие" Type="BOOL" Usage="internal" />
                    <Variable UUID="VUPVKP7RMWTERJ7AZBTZVEYPCY" Name="btnOn" Comment="кнопка открытия (включения)" Type="BOOL" Usage="internal" />
                    <Variable UUID="KGF35AM36CXUJJFX4C37TTI4EU" Name="btnOff" Comment="кнопка закрытия (отключения)" Type="BOOL" Usage="internal" />
                    <Variable UUID="6WBGZYIOBLMETEEEQZ6B5ASQII" Name="modeManual" Comment="ручное управление" Type="BOOL" Usage="internal" />
                    <Variable UUID="TNVNQT5NADZUHEA5XCOVODKHHM" Name="notOn" Comment="не открыт (не включен)" Type="BOOL" Usage="internal" />
                    <Variable UUID="RQOS2DNCVDXUXMEHU43U66PC2M" Name="notOff" Comment="не закрыт (не выключен)" Type="BOOL" Usage="internal" />
                    <Variable UUID="XWDUTHDWEMTEXF363ZDXUPB2FI" Name="setOn" Comment="обобщенная команда на открытие" Type="BOOL" Usage="internal" />
                    <Variable UUID="S7TDCYI34UAURMWX7LNZ7Q3DVQ" Name="setOff" Comment="обобщенная команда на закрытие" Type="BOOL" Usage="internal" />
                    <Variable UUID="2YFKES4RS6TEZIQK64GSW2VMLI" Name="int_iOn" Type="BOOL" Usage="internal" />
                    <Variable UUID="GZBUQS2K6R2EDONSFQIJ3B2AVM" Name="int_iOff" Type="BOOL" Usage="internal" />
                    <Variable UUID="JJPQIEFP32SUXG4U4O4MLUTJPI" Name="qOnPrev" Type="BOOL" Usage="internal" />
                    <Variable UUID="MZRVQ5DAR6FELAA4OJQ4ZJF47U" Name="qOffPrev" Type="BOOL" Usage="internal" />
                    <Variable UUID="VGZDX656BHWUHMVRFQ5T7UFPGA" Name="timeQOn" Comment="текущее время подачи команды открытия" Type="REAL" Usage="internal" />
                    <Variable UUID="BJ7NG6XPBDVEVD7WNGL2ATIDGE" Name="timeQOff" Comment="текущее время подачи команды закрытия" Type="REAL" Usage="internal" />
                    <Variable UUID="R4AU66NU2YVEHBFVJROOTEM2TM" Name="timeExtraOn" Comment="текущее время дожима открытия" Type="REAL" Usage="internal" />
                    <Variable UUID="GNURLIKPQ7HE5GHCKFJEQAONAI" Name="timeExtraOff" Comment="текущее время дожима закрытия" Type="REAL" Usage="internal" />
                    <Variable UUID="PDM4LADFVAUEFE5HUDLZHS7SEM" Name="timeCircBrkOn" Comment="текущее время КЦУ On" Type="REAL" Usage="internal" />
                    <Variable UUID="MGYODHIFDPRUBN4T56OY56ICHU" Name="timeCircBrkOff" Comment="текущее время КЦУ Off" Type="REAL" Usage="internal" />
                    <Variable UUID="AJO5AFGGN7BUDDZ7BWYSA5RPEQ" Name="changeCounter" Comment="количество попыток перевода в текущее положение" Type="INT" Usage="internal" />
                    <Variable UUID="ICO74YEEKVHELOXAIVEXGPQADQ" Name="FRONT_BTN" Comment="передний фронт кнопки РУ" Type="R_TRIG" TypeUUID="S45Q5WLSRRGU3MJDOGDVF24XVA" Usage="internal" />
                    <Variable UUID="R6PIXZGPSYXURC2XIL6YCBZWIY" Name="frBTN" Comment="передний фронт кнопки РУ" Type="BOOL" Usage="internal" />
                    <Variable UUID="IM6CQF6KSQCUVA7X4SECMK6LCM" Name="wasOn" Type="BOOL" Usage="internal" />
                    <Variable UUID="2S6R7J3WHQLULLRVMT2EJOD6YI" Name="wasOff" Type="BOOL" Usage="internal" />
                    <Variable UUID="CMAZOKJUL7ZETKJDW5UR5D743Q" Name="selfOn" Comment="самопроизвольное открытие (включение)" Type="BOOL" Usage="internal" />
                    <Variable UUID="6MJNYD4M6ALEZGQ5FROHQR5MCI" Name="selfOff" Comment="самопроизвольное закрытие (отключение)" Type="BOOL" Usage="internal" />
                    <Variable UUID="UJ646BIRCAFEJPINNWJFYZK27U" Name="imtState" Comment="текущее состояние" Type="REAL" Usage="internal" />
                    <Variable UUID="BT2WTUA36XFUHK5JVE57VGP7MU" Name="imt_qOn" Comment="внутренний сигнал ON (для унификации разнотипных ИМ)" Type="BOOL" Usage="internal" />
                    <Variable UUID="R6A5AI6O7K6ETL3VWIGD5RNVDU" Name="imt_qOff" Comment="внутренний сигнал OFF (для унификации разнотипных ИМ)" Type="BOOL" Usage="internal" />
                    <Variable UUID="SCKVA6FKP3UUJNHQUPGI2FXD7I" Name="iCon" Comment="контроль цепи" Type="BOOL" Usage="internal" />
                    <Variable UUID="FJBNTNBQHFREZNBP6FFGAKB64Y" Name="iCoff" Comment="контроль цепи" Type="BOOL" Usage="internal" />
                    <Variable UUID="NQH4CDIJEABERJZC2LFG46JX7E" Name="frontImitOn" Type="R_TRIG" TypeUUID="S45Q5WLSRRGU3MJDOGDVF24XVA" Usage="internal" />
                    <Variable UUID="P3NHLORDEEAEVENDKAOMT666JU" Name="frImitOn" Type="BOOL" Usage="internal" />
                    <Variable UUID="HF7YYOEZACGEXH23CYTA2BQ23Y" Name="disableManual" Comment="запрет ручного режима (внутренний сигнал)" Type="BOOL" Usage="internal" />
                    <Variable UUID="IB3U55AUN5UU7NW5VSDNGRDCKU" Name="fNotOn_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="ECXVHPRFC5XUXDL4FXXVLJU4PM" Name="fNotOff_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="RCCP626CVVQEDM5UZRBEWQAQAI" Name="fNotStart_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="J244K4GAFILUNINAFURJQGVEEY" Name="fSelfOn_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="MJPL45THOCLUTNSKBQLD3H6PGE" Name="fSelfOff_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="NJWXABGIHTKEBN4UVYBRAHZTLQ" Name="fFB_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="BMFNBKYDUCDUTGTY4MWQUMM3LY" Name="fCon_prv" Type="BOOL" Usage="internal" />
                    <Variable UUID="GMQ6D2T5AQAUPBWTXOAHL2QD2E" Name="fCoff_prv" Type="BOOL" Usage="internal" />
                </Variables>
                <ST><![CDATA[// ==================== Макрос для исполнительных механизмов =====================================

// константы AMtype
// 2-ИМ 1Q 0FB 1 команда 0 конечников (1x0)
// 3-ИМ 2Q(Fors+Hold) 2FB 2 команды 0 конечников (2x0)
// 4-ИМ 1Q 1FB 1 команда 1 конечник (1x1)
// 5-ИМ 1Q 2FB 1 команда 2 конечника (1x2)
// 6-ИМ 2Q 1FB 2 команды 1 конечник (2x1)
// 7-ИМ 2Q 2FB 2 команды 2 конечника (2x2)
// 8-ИМ 1Q 1FB с командой/конечником OFF
// 9-ИМ 1Q 2FB с командой OFF и двумя конечниками
// 10-ИМ 1Q 1FB с командой ON/ конечником OF 
// 11-ИМ ТРК, АПК и прочие с положением

  AM.iOn   := I_ON;
  AM.iOff  := I_OFF;
  AM.iCon  := I_Con;
  AM.iCoff := I_Coff;

// привязка к входам структуры AM
  btnOn  := AM.btnOn;
  btnOff := AM.btnOff;
  algOn  := AM.algOn;
  algOff := AM.algOff;
  modeManual := AM.modeManual;
 //запись типа ИМ в структуру  
//  AM.AMtype := AMtype; 

// инициализация задержек (если в структуре задержка не инициализирована - используем значение по-умолчанию)
//время перестановки, при превышении которого выдается предупреждение
IF tuns.delayChangeOvertimeAlert = 0.0 THEN tuns.delayChangeOvertimeAlert := 45.0; END_IF; 
//		delayChangeOvertimeAlert := 45.0; 
//	ELSE delayChangeOvertimeAlert := tuns.delayChangeOvertimeAlert; 
//END_IF; 

//время перестановки, при превышении которого снимается выходная команда
IF tuns.delayQTimeout = 0.0 THEN tuns.delayQTimeout := 90.0; END_IF; 
//	ELSE delayQTimeout := AM.delayQTimeout; 
//END_IF; 

//delayExtraOn := AM.delayExtraOn; //время дожима на открытие
//delayExtraOff := AM.delayExtraOff; //время дожима на закрытие
//задержка формирования нестрагивания
IF tuns.delayNotMoveAlert = 0.0 THEN tuns.delayNotMoveAlert := 4.0; END_IF; 
//ELSE delayNotMoveAlert := AM.delayNotMoveAlert; 
//END_IF; 
//задержка формирования обрыва контроля цепи
IF tuns.delayCircBrkAlert = 0.0 THEN tuns.delayCircBrkAlert := 1.0; END_IF; 
//	ELSE delayCircBrkAlert := AM.delayCircBrkAlert; 
//END_IF; 
// обобщенная неисправность
AM.fCommon := AM.fNotOn OR AM.fNotOff OR AM.fNotStart OR AM.fSelfOn OR AM.fSelfOff OR AM.fFB OR AM.fCon OR AM.fCoff;
// запрет ручного режима (внутренний сигнал)
disableManual := AM.disableManual AND NOT (AM.fNotOn OR AM.fNotOff); 

//** Переключатель РУЧНОГО РЕЖИМА (переключение по одному сигналу)
FRONT_BTN(AM.btnMode, frBTN); //передний фронт кнопки сохраняем в темп (frBTN)
IF frBTN AND AM.modeManual OR disableManual THEN //если есть фронт кнопки, и включен ручной режим - сброс ручного режима так же, ручной режим сбрасывается, когда он не разрешен!
	AM.modeManual := FALSE; //сброс ручного режима
	frBTN := FALSE; //сброс фронта
	AM.btnMode := FALSE; //сброс кнопки
END_IF;
//если есть фронт кнопки, ручной режим не включен, и нет запрета ручного режима
IF frBTN AND NOT AM.modeManual AND NOT disableManual THEN 
	AM.modeManual := TRUE; //включение ручного режима
	frBTN := FALSE; //сброс фронта
	AM.btnMode := FALSE; //сброс кнопки
END_IF;

//=========================================================================================================
CASE AMtype OF

2: // AM_1Q0FB *************************** ИМ 1Q 0FB ******************************************************

qOn := NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn) OR  modeManual AND (btnOn OR qOn) AND NOT btnOff;
       
// сигналы положения (конечники)
AM.iOn := AM.qOn;
AM.iOff := NOT AM.iOn;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// обрыв КЦУ
IF iCon or qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
//обрыв КЦУ команды "открыть (включить)"
AM.fCon := NOT AM.disableCon AND timeCircBrkOn > tuns.delayCircBrkAlert;      

3: // AM_2Q_FH *************************** ИМ 2Q(Fors+Hold) 2FB *******************************************

// сигналы положения (конечники)
iOn  := AM.iOn;
iOff := AM.iOff;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// формирование внутренних сигналов для реализации дожима
IF iOff OR NOT iOn THEN timeExtraOn  := 0.0; 
	ELSIF timeExtraOn  < 10000000.0 THEN timeExtraOn  := timeExtraOn  + cycle; 
END_IF;
int_iOn := timeExtraOn > tuns.delayExtraOn; // на время дожима - задерживаем сигналы открытия...

IF iOn OR NOT iOff THEN timeExtraOff  := 0.0; 
	ELSIF timeExtraOff  < 10000000.0 THEN timeExtraOff  := timeExtraOff  + cycle; 
END_IF;
int_iOff := timeExtraOff > tuns.delayExtraOff; // ...и закрытия.

// обобщенные команды от алгоритма и от кнопок РУ
AM.qHoldOn := int_iOn AND NOT setOff; //команда "удержание"
// обобщенная команда: открыть
setOn  := (modeManual AND  btnOn OR NOT modeManual AND algOn  OR setOn ) 
          AND NOT (modeManual  AND btnOff  OR NOT modeManual AND algOff); 
// обобщенная команда: закрыть
setOff := (modeManual AND btnOff OR NOT modeManual AND algOff OR setOff) 
          AND NOT (modeManual  AND  btnOn  OR NOT modeManual AND algOn ); 
 // выход на ИМ: открыть
qOn  := setOn  AND NOT int_iOn  AND timeQOn < tuns.delayQTimeout AND (changeCounter < 2  OR qOn );  

// подсчет попыток перестановки - только для ИМ (2х )
IF changeCounter > 0 AND (qOff OR btnOn) OR changeCounter < 0 AND (qOn OR btnOff) (*OR reset*) THEN changeCounter := 0;
	ELSIF NOT qOnPrev  AND qOn  THEN changeCounter := changeCounter + 1;
	ELSIF NOT qOffPrev AND qOff THEN changeCounter := changeCounter - 1;
END_IF;
qOnPrev := qOn;
qOffPrev := qOff;

// накапливаем время подачи команды открытия (включения)
IF NOT setOn  OR btnOn  THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;
IF NOT setOff OR btnOff THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// нестрагивание (только для ИМ с двумя конечниками)
//на закрытие
AM.fNotStart := (timeQOn > tuns.delayNotMoveAlert AND qOn AND iOff)    //на открытие
             OR (timeQOff > tuns.delayNotMoveAlert AND NOT qOn AND NOT AM.qHoldOn AND iOn); 

// не включен (не открыт) / не выключен (не закрыт)
notOn  := (timeQOn  > tuns.delayChangeOvertimeAlert AND qOn  OR notOn)  AND NOT int_iOn;     // не открыт
notOff := (timeQOff > tuns.delayChangeOvertimeAlert AND qOff OR notOff) AND NOT int_iOff;    // не закрыт

// неисправность концевых выключателей
AM.fFB:= iOff AND iOn; //двойное положение

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT iOn;
wasOn  := iOn AND (qOn OR AM.qHoldOn);
wasOff := (iOff OR wasOff) AND NOT (qOn OR AM.qHoldOn);

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

4: // AM_1Q1FB *************************** ИМ 1Q 1FB ******************************************************
// сигналы положения (конечники)
iOn  := AM.iOn;
iOff := NOT iOn;
AM.iOff := NOT iOn;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// обобщенные команды от алгоритма и от кнопок РУ
qOn := NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn)
       OR  modeManual AND (btnOn OR qOn) AND NOT btnOff;

// накапливаем время подачи команды открытия (включения)
IF NOT qOn THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;

IF qOn THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// не включен (не открыт) / не выключен (не закрыт)
notOn  := timeQOn  > tuns.delayChangeOvertimeAlert AND NOT iOn;      // не включен
notOff := timeQOff > tuns.delayChangeOvertimeAlert AND NOT iOff;     // не выключен

// обрыв КЦУ
IF iCon or qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
//обрыв КЦУ команды "открыть (включить)"
AM.fCon := NOT AM.disableCon AND timeCircBrkOn > tuns.delayCircBrkAlert;      


// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT iOn;
wasOn  := iOn AND qOn;
wasOff := (iOff OR wasOff) AND NOT qOn;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

5: // AM_1Q2FB *************************** ИМ 1Q 2FB ******************************************************
// сигналы положения (конечники)
iOn  := AM.iOn;
iOff := AM.iOff;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

//  обобщенные команды от алгоритма и от кнопок РУ
qOn := NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn)
       OR  modeManual AND (btnOn OR qOn) AND NOT btnOff;

// накапливаем время подачи команды открытия (включения)
IF NOT qOn THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;

IF qOn THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// нестрагивание (только для ИМ с двумя конечниками)
 //на закрытие
AM.fNotStart := (timeQOn > tuns.delayNotMoveAlert AND qOn AND iOff)    //на открытие
             OR (timeQOff > tuns.delayNotMoveAlert AND NOT qOn AND NOT AM.qHoldOn AND iOn);

// не включен (не открыт) / не выключен (не закрыт)
notOn  := timeQOn  > tuns.delayChangeOvertimeAlert AND NOT iOn;      // не включен
notOff := timeQOff > tuns.delayChangeOvertimeAlert AND NOT iOff;     // не выключен

// обрыв КЦУ
IF iCon or qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
AM.fCon := NOT AM.disableCon AND timeCircBrkOn > tuns.delayCircBrkAlert;      //обрыв КЦУ команды "открыть (включить)"

// неисправность концевых выключателей
AM.fFB:= iOff AND iOn; //двойное положение

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT iOn;
wasOn  := iOn AND qOn;
wasOff := (iOff OR wasOff) AND NOT qOn;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

6: // AM_2Q1FB *************************** ИМ 2Q 1FB ******************************************************   // 
// сигналы положения (конечники)
iOn  := AM.iOn;
iOff := NOT iOn;
AM.iOff := NOT iOn;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// формирование внутренних сигналов для реализации дожима
IF iOff OR NOT iOn THEN timeExtraOn  := 0.0; 
	ELSIF timeExtraOn  < 10000000.0 THEN timeExtraOn  := timeExtraOn  + cycle; 
END_IF;
int_iOn := timeExtraOn > tuns.delayExtraOn; // на время дожима - задерживаем сигналы открытия...

IF iOn OR NOT iOff THEN timeExtraOff  := 0.0; 
	ELSIF timeExtraOff  < 10000000.0 THEN timeExtraOff  := timeExtraOff  + cycle; 
END_IF;
int_iOff := timeExtraOff > tuns.delayExtraOff; // ...и закрытия.

//  обобщенные команды от алгоритма и от кнопок РУ
// обобщенная команда: открыть  
  setOn  := (modeManual AND btnOn OR NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn) OR setOn)  
					AND NOT (modeManual  AND btnOff  OR NOT modeManual AND algOff); 
 
 setOff := (modeManual AND btnOff OR NOT modeManual AND (algOff OR btnOff AND AM.prmBtnOff) OR setOff) 
						AND NOT (modeManual  AND  btnOn  OR NOT modeManual AND algOn); // обобщенная команда: закрыть
 
 qOn  := setOn  AND NOT int_iOn  AND timeQOn < tuns.delayQTimeout AND (changeCounter < 2  OR qOn);   // выход на ИМ: открыть 
 qOff := setOff AND NOT int_iOff AND timeQOff< tuns.delayQTimeout AND (changeCounter > -2 OR qOff);   // выход на ИМ: закрыть

// подсчет попыток перестановки - только для ИМ (2х )
IF changeCounter > 0 AND (qOff OR btnOn) OR changeCounter < 0 AND (qOn OR btnOff) (*OR reset*) THEN changeCounter := 0;
	ELSIF NOT qOnPrev  AND qOn  THEN changeCounter := changeCounter + 1;
	ELSIF NOT qOffPrev AND qOff THEN changeCounter := changeCounter - 1;
END_IF;
qOnPrev := qOn;
qOffPrev := qOff;

// накапливаем время подачи команды открытия (включения)
IF NOT setOn  OR btnOn  THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;

IF NOT setOff OR btnOff THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// не включен (не открыт) / не выключен (не закрыт)
notOn  := (timeQOn  > tuns.delayChangeOvertimeAlert AND qOn  OR notOn)  AND NOT int_iOn;     // не открыт
notOff := (timeQOff > tuns.delayChangeOvertimeAlert AND qOff OR notOff) AND NOT int_iOff;    // не закрыт

// обрыв КЦУ
IF NOT qOn AND iCon OR qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
AM.fCon := NOT AM.disableCon AND (timeCircBrkOn > tuns.delayCircBrkAlert OR AM.fCon) AND NOT iCon;      //обрыв КЦУ команды "открыть (включить)"

IF NOT qOff AND iCoff OR qOff THEN timeCircBrkOff := 0.0;
	ELSIF timeCircBrkOff < tuns.delayCircBrkAlert THEN timeCircBrkOff := timeCircBrkOff + cycle; 
END_IF;
AM.fCoff := NOT AM.disableCoff AND (timeCircBrkOff > tuns.delayCircBrkAlert OR AM.fCoff) AND NOT iCoff; //обрыв КЦУ команды "закрыть (отключить)"

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
  selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
  selfOff := (wasOn AND NOT iOn OR selfOff) AND NOT (iOn OR qOff); //
  wasOn  := (iOn OR wasOn) AND NOT qOff;
  wasOff := (iOff OR wasOff) AND NOT qOn;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

7: // AM_2Q2FB *************************** ИМ 2Q 2FB ******************************************************
// сигналы положения (конечники)
iOn  := AM.iOn;
iOff := AM.iOff;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// формирование внутренних сигналов для реализации дожима
IF iOff OR NOT iOn THEN timeExtraOn  := 0.0; 
	ELSIF timeExtraOn  < 10000000.0 THEN timeExtraOn  := timeExtraOn  + cycle; 
END_IF;
int_iOn := timeExtraOn > tuns.delayExtraOn; // на время дожима - задерживаем сигналы открытия...

IF iOn OR NOT iOff THEN timeExtraOff  := 0.0; 
	ELSIF timeExtraOff  < 10000000.0 THEN timeExtraOff  := timeExtraOff  + cycle; 
END_IF;
int_iOff := timeExtraOff > tuns.delayExtraOff; // ...и закрытия.

//  обобщенные команды от алгоритма и от кнопок РУ
setOn  := (modeManual AND  btnOn OR NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn)  OR setOn)
          AND NOT (modeManual  AND btnOff  OR NOT modeManual AND algOff); // обобщенная команда: открыть
setOff := (modeManual AND btnOff OR NOT modeManual AND (algOff OR btnOff AND AM.prmBtnOff) OR setOff)           
          AND NOT (modeManual  AND  btnOn  OR NOT modeManual AND algOn); // обобщенная команда: закрыть

qOn  := setOn  AND NOT int_iOn  AND timeQOn < tuns.delayQTimeout AND (changeCounter < 2  OR qOn );   // выход на ИМ: открыть 
qOff := setOff AND NOT int_iOff AND timeQOff< tuns.delayQTimeout AND (changeCounter > -2 OR qOff);   // выход на ИМ: закрыть

// подсчет попыток перестановки - только для ИМ (2х )
IF changeCounter > 0 AND (qOff OR btnOn) OR changeCounter < 0 AND (qOn OR btnOff) (*OR reset*) THEN changeCounter := 0;
	ELSIF NOT qOnPrev  AND qOn  THEN changeCounter := changeCounter + 1;
	ELSIF NOT qOffPrev AND qOff THEN changeCounter := changeCounter - 1;
END_IF;
qOnPrev := qOn;
qOffPrev := qOff;

// накапливаем время подачи команды открытия (включения)
IF NOT setOn  OR btnOn  THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;

IF NOT setOff OR btnOff THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// нестрагивание (только для ИМ с двумя конечниками)
AM.fNotStart := (timeQOn > tuns.delayNotMoveAlert AND qOn AND iOff)    //на открытие
             OR (timeQOff > tuns.delayNotMoveAlert AND qOff AND iOn);   //на закрытие

// не включен (не открыт) / не выключен (не закрыт)
notOn  := (timeQOn  > tuns.delayChangeOvertimeAlert AND qOn  OR notOn)  AND NOT int_iOn;     // не открыт
notOff := (timeQOff > tuns.delayChangeOvertimeAlert AND qOff OR notOff) AND NOT int_iOff;    // не закрыт

// обрыв КЦУ
IF iCon or qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
AM.fCon := NOT AM.disableCon AND timeCircBrkOn > tuns.delayCircBrkAlert;      //обрыв КЦУ команды "открыть (включить)"

IF iCoff or qOff THEN timeCircBrkOff := 0.0;
	ELSIF timeCircBrkOff < tuns.delayCircBrkAlert THEN timeCircBrkOff := timeCircBrkOff + cycle; 
END_IF;
AM.fCoff := NOT AM.disableCoff AND timeCircBrkOff > tuns.delayCircBrkAlert; //обрыв КЦУ команды "закрыть (отключить)"

// неисправность концевых выключателей
AM.fFB:= iOff AND iOn; //двойное положение

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn AND NOT iOn OR selfOff) AND NOT (iOn OR qOff); 
wasOn  := (iOn OR wasOn) AND NOT qOff;
wasOff := (iOff OR wasOff) AND NOT qOn;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

8: // AM_inv1Q1FB ************************ ИМ 1Q 1FB с командой/конечником OFF ****************************
// сигналы положения (конечники)
iOff := AM.iOff;
iOn  := NOT iOff;
AM.iOn := NOT iOff; 

// сигналы контроля цепи
iCoff := AM.iCoff;

//  обобщенные команды от алгоритма и от кнопок РУ
qOff := NOT modeManual AND (algOff OR btnOff AND AM.prmBtnOff) OR modeManual AND (btnOff OR qOff) AND NOT btnOn;
       
// накапливаем время подачи команды открытия (включения)
IF NOT qOff THEN timeQOff  := 0.0; 
	ELSIF timeQOff  < 10000000.0 THEN timeQOff  := timeQOff  + cycle; 
END_IF;

// не включен (не открыт) / не выключен (не закрыт)
notOn  := (timeQOn  > tuns.delayChangeOvertimeAlert AND qOn  OR notOn)  AND NOT iOn;     // не открыт
notOff := (timeQOff > tuns.delayChangeOvertimeAlert AND qOff OR notOff) AND NOT iOff;    // не закрыт

// обрыв КЦУ
IF NOT qOff AND iCoff OR qOff THEN timeCircBrkOff := 0.0;
	ELSIF timeCircBrkOff < tuns.delayCircBrkAlert THEN timeCircBrkOff := timeCircBrkOff + cycle; 
END_IF;
AM.fCoff := NOT AM.disableCoff AND (timeCircBrkOff > tuns.delayCircBrkAlert OR AM.fCoff) AND NOT iCoff; //обрыв КЦУ команды "закрыть (отключить)"

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT iOn;
wasOff  := iOff AND qOff;
wasOn := (iOn OR wasOn) AND NOT qOff;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

9: // AM_inv1Q2FB ************************ ИМ 1Q 2FB с командой OFF/ и двумя конечниками ******************
// сигналы положения (конечники)
iOff := AM.iOff;
iOn  := AM.iOn;

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

//  обобщенные команды от алгоритма и от кнопок РУ
qOff := NOT modeManual AND (algOff OR btnOff AND AM.prmBtnOff) OR  modeManual AND (btnOff OR qOff) AND NOT btnOn;
       

// накапливаем время подачи команды открытия (включения)
IF NOT qOff THEN timeQOff  := 0.0; 
	ELSIF timeQOff  < 10000000.0 THEN timeQOff  := timeQOff  + cycle; 
END_IF;

// не включен (не открыт) / не выключен (не закрыт)
notOn  := (timeQOn  > tuns.delayChangeOvertimeAlert AND qOn  OR notOn)  AND NOT iOn;     // не открыт
notOff := (timeQOff > tuns.delayChangeOvertimeAlert AND qOff OR notOff) AND NOT iOff;    // не закрыт

// обрыв КЦУ
IF NOT qOff AND iCoff OR qOff THEN timeCircBrkOff := 0.0;
	ELSIF timeCircBrkOff < tuns.delayCircBrkAlert THEN timeCircBrkOff := timeCircBrkOff + cycle; 
END_IF;
AM.fCoff := NOT AM.disableCoff AND (timeCircBrkOff > tuns.delayCircBrkAlert OR AM.fCoff) AND NOT iCoff; //обрыв КЦУ команды "закрыть (отключить)"

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT iOn;
wasOff  := iOff AND qOff;
wasOn := (iOn OR wasOn) AND NOT qOff;

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

10: // AM_1Q1CFB *************************** ИМ 1Q 1FB ******************************************************

// сигналы положения (конечники)
iOff := AM.iOff;
iOn  := NOT iOff;
AM.iOn := NOT iOff; 

// сигналы контроля цепи
iCon  := AM.iCon;
iCoff := AM.iCoff;

// обобщенные команды от алгоритма и от кнопок РУ
qOn := NOT modeManual AND (algOn OR btnOn AND AM.prmBtnOn) OR  modeManual AND (btnOn OR qOn) AND NOT btnOff;
      
// накапливаем время подачи команды открытия (включения)
IF NOT qOn or unlock THEN timeQOn  := 0.0; 
	ELSIF timeQOn  < 10000000.0 THEN timeQOn  := timeQOn  + cycle; 
END_IF;

IF qOn or unlock THEN timeQOff := 0.0; 
	ELSIF timeQOff < 10000000.0 THEN timeQOff := timeQOff + cycle; 
END_IF;

// не включен (не открыт) / не выключен (не закрыт)
notOn  := timeQOn  > tuns.delayChangeOvertimeAlert AND NOT iOn;      // не включен
notOff := timeQOff > tuns.delayChangeOvertimeAlert AND NOT iOff;     // не выключен

// обрыв КЦУ
IF NOT qOn AND iCon OR qOn THEN timeCircBrkOn := 0.0;
	ELSIF timeCircBrkOn < tuns.delayCircBrkAlert THEN timeCircBrkOn := timeCircBrkOn + cycle; 
END_IF;
AM.fCon := NOT AM.disableCon AND (timeCircBrkOn > tuns.delayCircBrkAlert OR AM.fCon) AND NOT iCon;      //обрыв КЦУ команды "открыть (включить)"

// самопроизвольное открытие/закрытие
// сигнал сбрасывается при наличии нужного положения ИМ или при подаче противоположной команды
selfOn  := (wasOff AND NOT iOff OR selfOn) AND NOT (iOff OR qOn or unlock);
selfOff := (wasOn  AND NOT iOn OR selfOff) AND NOT (iOn or unlock);
wasOn  := iOn AND qOn;
wasOff := (iOff OR wasOff) AND NOT (qOn or unlock);

// разрешение для кнопок, когда ИМ не_открылся/не_закрылся
AM.prmBtnOn := notOn  AND algOn  AND NOT qOn;
AM.prmBtnOff := notOff AND algOff AND NOT qOff;

END_CASE;

//------------------------------------ Имитатор ИМ ---------------------------------------------------------

frontImitOn(onImit, frImitOn); //передний фронт onImit

IF onImit THEN //Начало имитации

	IF frImitOn THEN // по переднему фронту onImit инициализация положение ИМ
	  IF iOn AND NOT iOff THEN imtState := imtChangeTime; // открыт
		ELSIF iOff AND NOT iOn THEN imtState := 0.0; //закрыт
		ELSE imtState := imtChangeTime / 2.0; // ставим в середину
	  END_IF;
	END_IF;

	// формирование внутренних команд в соответствии с типом ИМ
	IF AMtype = 1 OR AMtype = 6 OR AMtype = 7 THEN // ИМ с двумя командами
	  imt_qOn  := qOn;
	  imt_qOff := qOff;
	ELSIF AMtype = 3 THEN // ИМ с форсировкой-удержанием
	  imt_qOn  := qOn OR AM.qHoldOn;
	  imt_qOff := NOT imt_qOn;
	ELSIF AMtype = 8 OR AMtype = 9 THEN // для ИМ (1x1) (с командой/конечником OFF)
	  imt_qOff  := qOff;
	  imt_qOn := NOT qOff;
	ELSE // ИМ с одной командой
	  imt_qOn  := qOn;
	  imt_qOff := NOT qOn;
	END_IF;    

	IF imt_qOn  THEN imtState := imtState + cycle; END_IF; // перемещение -> ON
	IF imt_qOff THEN imtState := imtState - cycle; END_IF; // перемещение -> OFF

	IF imtState > imtChangeTime THEN imtState := imtChangeTime; END_IF; // ограничение
	IF imtState < 0.0 THEN imtState := 0.0; END_IF;

	//концевики
	IF AMtype = 4 OR AMtype = 6 THEN
	  AM.iOn  := imtState/imtChangeTime > 0.9; // формируем выход при 90% перемещения 
	  AM.iOff := NOT iOn; // для ИМ 2х1
	ELSIF AMtype = 8 THEN // для ИМ (1x1) (с командой/конечником OFF)
	  AM.iOff  := imtState/imtChangeTime < 0.1; 
	  AM.iOn := NOT iOff; // для ИМ 2х1
	ELSIF AMtype = 11 THEN // для ИМ ТРК, АПК и прочих 
	  AM.iOff  := I_OFF; 
	  AM.iOn :=  I_ON; 
	ELSIF AMtype <> 2 THEN
	  AM.iOn  := imtState/imtChangeTime > 0.9; // формируем выход при 90% перемещения
	  AM.iOff := imtState/imtChangeTime < 0.1; // формируем выход при 10% перемещения
	END_IF;

	//КЦУ (формируется, когда не подается команда управления)
	AM.iCon  := NOT imt_qOn;
	AM.iCoff := NOT imt_qOff;

END_IF; //Конец имитации

//---------------------------------------------------------------------
IF unlock THEN 
	notOn   := FALSE;
	notOff  := FALSE;
	selfOn  := FALSE;
	selfOff := FALSE;
	wasOn:= FALSE; //Добавлено
	wasOff:= FALSE; //Добавлено
	changeCounter := 0; //Добавлено
END_IF;

// привязка к выходам структуры AM
AM.fNotOn  := notOn;	//не включен (не открыт)
AM.fNotOff := notOff;	//не выключен (не закрыт)
AM.fSelfOn  := selfOn;	//самопроизвольное открытие
AM.fSelfOff := selfOff;	//самопроизвольное закрытие
AM.qOn  := qOn;
AM.qOff := qOff;
// передача выходных сигналов
Q_ON     := AM.qOn;
Q_OFF    := AM.qOff;
Q_HoldOn := AM.qHoldOn;
// сброс кнопок РУ (откр/закр)
AM.btnOn  := FALSE;
AM.btnOff := FALSE;

//ПС по ИМ для сирены. Снимать там же где и остальные ПС
ps := AM.fNotOn and not fNotOn_prv
	  or AM.fNotOff and not fNotOff_prv
	  or AM.fNotStart and not fNotStart_prv
	  or AM.fSelfOn and not fSelfOn_prv
	  or AM.fSelfOff and not fSelfOff_prv
	  or AM.fFB and not fFB_prv
	  or AM.fCon and not fCon_prv
	  or AM.fCoff and not fCoff_prv;

fNotOn_prv		:= AM.fNotOn;
fNotOff_prv		:= AM.fNotOff;
fNotStart_prv	:= AM.fNotStart;
fSelfOn_prv		:=	AM.fSelfOn;
fSelfOff_prv	:=	AM.fSelfOff;
fFB_prv			:=	AM.fFB;
fCon_prv		:=	AM.fCon;
fCoff_prv		:=	AM.fCoff;

]]></ST>
            </FunctionBlock>
            <FunctionBlock UUID="XICUTQAGUXZEZLSIPSBXR2UEV4" Name="FB_IM_Call">
                <Variables>
                    <Variable UUID="H5PBCAC4VRDULBAEGWVD6PFO3U" Name="IM_type" Type="T_AM_Type" TypeUUID="ANRR6BLMKETURJI5AWVQRMBAWA" Usage="internal" />
                    <Variable UUID="TSD445UDCETEFHCQM2CAJQ4KWY" Name="Proc_Vn_V1" Type="FB_IM" TypeUUID="JIOIQ3APYP4UTCXLJQK7Q6LHCA" Usage="internal" />
                </Variables>
                <ST><![CDATA[//Константы ИМ

//= if not init.AM then
if not init then 
	IM_type.am1x0	   	:= 2; //ИМ 1 команда, 0 конечников
	IM_type.am2x2fh	   	:= 3; //ИМ 2 команды, 2 конечника (открытие, удержание)
	IM_type.am1x1	   	:= 4; //ИМ 1 команда, 1 конечник
	IM_type.am1x2	   	:= 5; //ИМ 1 команда, 2 конечника
	IM_type.am2x1	   	:= 6; //ИМ 2 команды, 1 конечник
	IM_type.am2x2	   	:= 7; //ИМ 2 команды, 2 конечника
	IM_type.am1ofx1of  	:= 8; //ИМ 1 команда OF, 1 конечник OF
	IM_type.am1ofx2	   	:= 9; //ИМ 1 команда OF, 2 конечника
	IM_type.am1x1of		:= 10; //ИМ 1 команда, 1 конечник OF
	IM_type.amPos		:= 11; //ИМ прочие с положением (АПК, ТРК...)
	IM_type.am3x2		:= 12; //ИМ 3 команды (on, off, stop), 2 конечника
	IM_type.am2x2x3ware	:= 13; //ИМ 2 команды, 2 конечника, трёхпроводная схема
	IM_type.am1x4nku	:= 14; //ИМ 1 команда, 4 сигнала от НКУ
	IM_type.am2x7upp	:= 15; //ИМ 2 команды (БП и УПП) и 7 сигналов от НКУ
	IM_type.am2x8nku	:= 16; //ИМ 2 команды и 8 сигналов от НКУ
	IM_Init(); 
//=	init.APS := true; 
end_if;

ps_im := false; //звуковое предупреждение по ИМ

//Вентсистема В1
//2x1
UVI_AM.Vn_V1.disableManual := not UVI_TS.DU_IM;  //Запрет РУ
//= UVI_AM.Vn_V1.algOff	:=	FALSE;  //Логическая команда на закр.(выкл.) - формируется в алгоритме //=
//= UVI_AM.Vn_V1.algOn	:=	FALSE;  //Логическая команда на откр.(вкл.)  - формируется в алгоритме //=

Proc_Vn_V1( AMtype := IM_type.am2x1, AM := UVI_AM.Vn_V1, onImit := ImitOn,   cycle := tim.cycle, unlock := UVI_BTN.Deblock
EN := NOT (UVI_DO_ToHMI.Vn_V1_ON.forsEnable OR UVI_DO_ToHMI.Vn_V1_OF.forsEnable),
tuns := TuneAM.Vn_V1,
I_ON       := UVI_DI.Vn_V1_ON
//= I_OFF      := UVI_DI.Vn_V1_OF 	нет концевика закрытия (выкл.) 
I_Con      := TRUE
I_Coff     := TRUE
Q_ON     	=> UVI_DO.Vn_V1_ON
Q_OFF     	=> UVI_DO.Vn_V1_OF);

ps_im := ps_im OR Proc_Vn_V1.ps;]]></ST>
            </FunctionBlock>
            <Function UUID="CODNAAKPURQE5ISSMFLXHEFINI" Name="IM_Init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables />
                <ST><![CDATA[//Вентсистема В1
TuneAM.Vn_V1.delayChangeOvertimeAlert := 15.0;
TuneAM.Vn_V1.delayQTimeout := 20.0;
TuneAM.Vn_V1.delayExtraOn := 1.0;
TuneAM.Vn_V1.delayExtraOff := 1.0;
TuneAM.Vn_V1.delayNotMoveAlert := 5.0;
TuneAM.Vn_V1.delayCircBrkAlert := 1.0;
]]></ST>
            </Function>
        </Folder>
        <Folder Name="InOut" Comment="" Data="" UUID="JEWGRCJIABKEFPEQMJNGJFUDNY">
            <Folder Name="AI" Comment="" Data="" UUID="DUS6OXMH5TYULHSJYLJCLLBS2Q">
                <Folder Name="ANB" Comment="" Data="" UUID="D2DYZQR3CIRENIG62BN2KCIEJQ">
                    <Function UUID="BYAR3MRKOBFE3ASGP7ZBFBDZQA" Name="ANB_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables />
                        <ST><![CDATA[if init = false then

//Давление метанола перед распределительными клапанами УВИ1 повышенное
UVI_Ust.Pmet_Kl_UVI1_Pv := 15.1;
//Давление метанола перед распределительными клапанами УВИ1 высокое
UVI_Ust.Pmet_Kl_UVI1_Av := 15.2;
//---------------------------------------------------------------------
//Давление метанола перед распределительными клапанами УВИ2 повышенное
UVI_Ust.Pmet_Kl_UVI2_Pv := 15.1;
//Давление метанола перед распределительными клапанами УВИ2 высокое
UVI_Ust.Pmet_Kl_UVI2_Av := 15.2;
//---------------------------------------------------------------------
//Мгновенный массовый расход метанола на УВИ1 низкий
UVI_Ust.Qmgms_met_UVI1_An := 0.378;
//Мгновенный массовый расход метанола на УВИ1 пониженный
UVI_Ust.Qmgms_met_UVI1_Pn := 0.428;
//Мгновенный массовый расход метанола на УВИ1 повышенный
UVI_Ust.Qmgms_met_UVI1_Pv := 0.9;
//Мгновенный массовый расход метанола на УВИ1 высокий
UVI_Ust.Qmgms_met_UVI1_Av := 0.95;
//---------------------------------------------------------------------
//Мгновенный массовый расход метанола на УВИ2 низкий
UVI_Ust.Qmgms_met_UVI2_An := 0.378;
//Мгновенный массовый расход метанола на УВИ2 пониженный
UVI_Ust.Qmgms_met_UVI2_Pn := 0.428;
//Мгновенный массовый расход метанола на УВИ2 повышенный
UVI_Ust.Qmgms_met_UVI2_Pv := 0.9;
//Мгновенный массовый расход метанола на УВИ2 высокий
UVI_Ust.Qmgms_met_UVI2_Av := 0.95;
//---------------------------------------------------------------------
//Верхний уровень в емкости E-8.1 дренажа метанола
UVI_Ust.Lmet_E8_1_v_Pn := 7.0;
//---------------------------------------------------------------------
//Основное напряжение САУ низкое
UVI_Ust.Uosn_SAU_Pn := 187.0;
//Основное напряжение САУ высокое
UVI_Ust.Uosn_SAU_Pv := 242.0;
//---------------------------------------------------------------------
//Резервное напряжение САУ низкое
UVI_Ust.Urez_SAU_Pn := 187.0;
//Резервное напряжение САУ высокое
UVI_Ust.Urez_SAU_Pv := 242.0;

//при неисправности; уставка верхняя, задержка, тип(2АС 1ПС)

UVI_ANB_Settings.Uosn_SAU_Pn := ANB_init(0, false, 1.0);// Измерение основного напряжения: предупредительная нижняя
UVI_ANB_Settings.Urez_SAU_Pn := ANB_init(0, false, 1.0,);// Измерение резервного напряжения: предупредительная нижняя
UVI_ANB_Settings.Uosn_SAU_Pv := ANB_init(0, true,  1.0);// Измерение основного напряжения: предупредительная верхняя
UVI_ANB_Settings.Urez_SAU_Pv := ANB_init(0, true,  1.0);// Измерение резервного напряжения: предупредительная верхняя
//Верхний уровень в емкости E-8.1 дренажа метанола
UVI_ANB_Settings.Lmet_E8_1_v_Pn := ANB_init(0, false, 1.0,);

//Давление метанола перед распределительными клапанами УВИ1
UVI_ANB_Settings.Pmet_Kl_UVI1_Pv := ANB_init(0, true,  1.0);
UVI_ANB_Settings.Pmet_Kl_UVI1_Av := ANB_init(0, true,  1.0);
//Давление метанола перед распределительными клапанами УВИ2
UVI_ANB_Settings.Pmet_Kl_UVI2_Pv := ANB_init(0, true,  1.0);
UVI_ANB_Settings.Pmet_Kl_UVI2_Av := ANB_init(0, true,  1.0);
//Мгновенный массовый расход метанола на УВИ1
UVI_ANB_Settings.Qmgms_met_UVI1_An := ANB_init(0, false, 1.0);
UVI_ANB_Settings.Qmgms_met_UVI1_Pn := ANB_init(0, false, 1.0);
UVI_ANB_Settings.Qmgms_met_UVI1_Pv := ANB_init(0, true,  1.0);
UVI_ANB_Settings.Qmgms_met_UVI1_Av := ANB_init(0, true,  1.0);
//Мгновенный массовый расход метанола на УВИ2
UVI_ANB_Settings.Qmgms_met_UVI2_An := ANB_init(0, false, 1.0);
UVI_ANB_Settings.Qmgms_met_UVI2_Pn := ANB_init(0, false, 1.0);
UVI_ANB_Settings.Qmgms_met_UVI2_Pv := ANB_init(0, true,  1.0);
UVI_ANB_Settings.Qmgms_met_UVI2_Av := ANB_init(0, true,  1.0);

end_if;

//========================================================================================================================================

UVI_ANB.Uosn_SAU_Pn := ANB_Processing(UVI_Ust.Uosn_SAU_Pn, UVI_AI_ToHMI.Uosn_SAU.PV, UVI_AI_ToHMI.Uosn_SAU.fault_common, UVI_ANB_Settings.Uosn_SAU_Pn, UVI_ANB_Internal.Uosn_SAU_Pn);// Измерение основного напряжения: предупредительная нижняя
UVI_ANB.Urez_SAU_Pn := ANB_Processing(UVI_Ust.Urez_SAU_Pn, UVI_AI_ToHMI.Urez_SAU.PV, UVI_AI_ToHMI.Urez_SAU.fault_common,  UVI_ANB_Settings.Urez_SAU_Pn, UVI_ANB_Internal.Urez_SAU_Pn);// Измерение резервного напряжения: предупредительная нижняя
UVI_ANB.Uosn_SAU_Pv := ANB_Processing(UVI_Ust.Uosn_SAU_Pv, UVI_AI_ToHMI.Uosn_SAU.PV, UVI_AI_ToHMI.Uosn_SAU.fault_common, UVI_ANB_Settings.Uosn_SAU_Pv, UVI_ANB_Internal.Uosn_SAU_Pv);// Измерение основного напряжения: предупредительная верхняя
UVI_AI_ToHMI.Uosn_SAU.ps := UVI_ANB.Uosn_SAU_Pv OR UVI_ANB.Uosn_SAU_Pn;
UVI_ANB.Urez_SAU_Pv := ANB_Processing(UVI_Ust.Urez_SAU_Pv, UVI_AI_ToHMI.Urez_SAU.PV, UVI_AI_ToHMI.Urez_SAU.fault_common, UVI_ANB_Settings.Urez_SAU_Pv, UVI_ANB_Internal.Urez_SAU_Pv);// Измерение резервного напряжения: предупредительная верхняя
UVI_AI_ToHMI.Urez_SAU.ps := UVI_ANB.Urez_SAU_Pv OR UVI_ANB.Urez_SAU_Pn;
UVI_ANB.Lmet_E8_1_v_Pn := ANB_Processing(UVI_Ust.Lmet_E8_1_v_Pn, UVI_AI_ToHMI.Lmet_E8_1_v.PV, UVI_AI_ToHMI.Lmet_E8_1_v.fault_common, UVI_ANB_Settings.Lmet_E8_1_v_Pn, UVI_ANB_Internal.Lmet_E8_1_v_Pn); //Верхний уровень в емкости E-8.1 дренажа метанола
UVI_AI_ToHMI.Lmet_E8_1_v.ps := UVI_ANB.Lmet_E8_1_v_Pn;

// из модбаса
//Давление метанола перед распределительными клапанами УВИ1
UVI_ANB.Pmet_Kl_UVI1_Pv := ANB_Processing(UVI_Ust.Pmet_Kl_UVI1_Pv, UVI_UVI_mb_AI_ToHMI.P.PV, UVI_UVI_mb_AI_ToHMI.P.fault_common, UVI_ANB_Settings.Pmet_Kl_UVI1_Pv , UVI_ANB_Internal.Pmet_Kl_UVI1_Pv); 
UVI_UVI_mb_AI_ToHMI.P.ps := UVI_ANB.Pmet_Kl_UVI1_Pv;
UVI_ANB.Pmet_Kl_UVI1_Av := ANB_Processing(UVI_Ust.Pmet_Kl_UVI1_Av, UVI_UVI_mb_AI_ToHMI.P.PV, UVI_UVI_mb_AI_ToHMI.P.fault_common, UVI_ANB_Settings.Pmet_Kl_UVI1_Av , UVI_ANB_Internal.Pmet_Kl_UVI1_Av); 
UVI_UVI_mb_AI_ToHMI.P.as := UVI_ANB.Pmet_Kl_UVI1_Av;
//Давление метанола перед распределительными клапанами УВИ2
UVI_ANB.Pmet_Kl_UVI2_Pv := ANB_Processing(UVI_Ust.Pmet_Kl_UVI2_Pv, UVI_UVI_mb_AI_ToHMI.P.PV, UVI_UVI_mb_AI_ToHMI.P.fault_common, UVI_ANB_Settings.Pmet_Kl_UVI2_Pv , UVI_ANB_Internal.Pmet_Kl_UVI2_Pv); 
UVI_UVI_mb_AI_ToHMI.P.ps :=UVI_ANB.Pmet_Kl_UVI2_Pv;
UVI_ANB.Pmet_Kl_UVI2_Av := ANB_Processing(UVI_Ust.Pmet_Kl_UVI2_Av, UVI_UVI_mb_AI_ToHMI.P.PV, UVI_UVI_mb_AI_ToHMI.P.fault_common, UVI_ANB_Settings.Pmet_Kl_UVI2_Av , UVI_ANB_Internal.Pmet_Kl_UVI2_Av); 
UVI_UVI_mb_AI_ToHMI.P.as := UVI_ANB.Pmet_Kl_UVI2_Av;
//Мгновенный массовый расход метанола на УВИ1
UVI_ANB.Qmgms_met_UVI1_An := ANB_Processing(UVI_Ust.Qmgms_met_UVI1_An, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI1_An , UVI_ANB_Internal.Qmgms_met_UVI1_An); 
UVI_ANB.Qmgms_met_UVI1_Pn := ANB_Processing(UVI_Ust.Qmgms_met_UVI1_Pn, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI1_Pn , UVI_ANB_Internal.Qmgms_met_UVI1_Pn); 
UVI_ANB.Qmgms_met_UVI1_Pv := ANB_Processing(UVI_Ust.Qmgms_met_UVI1_Pv, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI1_Pv , UVI_ANB_Internal.Qmgms_met_UVI1_Pv); 
UVI_UVI_mb_AI_ToHMI.Q.ps := UVI_ANB.Qmgms_met_UVI1_Pv OR UVI_ANB.Qmgms_met_UVI1_Pn;
UVI_ANB.Qmgms_met_UVI1_Av := ANB_Processing(UVI_Ust.Qmgms_met_UVI1_Av, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI1_Av , UVI_ANB_Internal.Qmgms_met_UVI1_Av); 
UVI_UVI_mb_AI_ToHMI.Q.as := UVI_ANB.Qmgms_met_UVI1_Av OR UVI_ANB.Qmgms_met_UVI1_An;
//Мгновенный массовый расход метанола на УВИ2
UVI_ANB.Qmgms_met_UVI2_An := ANB_Processing(UVI_Ust.Qmgms_met_UVI2_An, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI2_An , UVI_ANB_Internal.Qmgms_met_UVI2_An); 
UVI_ANB.Qmgms_met_UVI2_Pn := ANB_Processing(UVI_Ust.Qmgms_met_UVI2_Pn, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI2_Pn , UVI_ANB_Internal.Qmgms_met_UVI2_Pn); 
UVI_ANB.Qmgms_met_UVI2_Pv := ANB_Processing(UVI_Ust.Qmgms_met_UVI2_Pv, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI2_Pv , UVI_ANB_Internal.Qmgms_met_UVI2_Pv); 
UVI_UVI_mb_AI_ToHMI.Q.ps := UVI_ANB.Qmgms_met_UVI2_Pv OR UVI_ANB.Qmgms_met_UVI2_Pn;
UVI_ANB.Qmgms_met_UVI2_Av := ANB_Processing(UVI_Ust.Qmgms_met_UVI2_Av, UVI_UVI_mb_AI_ToHMI.Q.PV, UVI_UVI_mb_AI_ToHMI.Q.fault_common, UVI_ANB_Settings.Qmgms_met_UVI2_Av , UVI_ANB_Internal.Qmgms_met_UVI2_Av); 
UVI_UVI_mb_AI_ToHMI.Q.as := UVI_ANB.Qmgms_met_UVI2_Av OR UVI_ANB.Qmgms_met_UVI2_An;]]></ST>
                    </Function>
                    <Function UUID="XYBPO55BLI4UPLMLN7IPM2G3AE" Name="ANB_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables>
                            <Variable UUID="NGTALOKOFQQEJCXFO5K2WRVOEM" Name="limit" Comment="порог срабатывания" Type="REAL" Usage="input" />
                            <Variable UUID="OYP2F37VW5REJFKT3KXRET4S3M" Name="anp" Type="REAL" Usage="input" />
                            <Variable UUID="QHRSZQ2O22ZUDO3RO7LZCS7TCQ" Name="fault" Type="BOOL" Usage="input" />
                            <Variable UUID="XZFZFVGE5NOUHBKTICGTXHSDWI" Name="set" Type="T_ANB_Settings" TypeUUID="I7SVZ4ZR3CPE7BHJZXJTI4JZXI" Usage="input" />
                            <Variable UUID="6A7WAZF3BDRUBOHX4IKMI5L3CY" Name="timer" Type="REAL" Usage="inout" />
                        </Variables>
                        <ST><![CDATA[if fault then
	if    set.setForFault = 0 then ANB_Processing := false;
	elsif set.setForFault = 1 then ANB_Processing := true; 
	end_if;
else
	if anp < limit xor set.isUp then
		timer := timer + tim.cycle;
	else
		timer := 0.0;
	end_if;
	ANB_Processing := timer >(*=*) set.delay; //= неравенство д.б. строгим
(*anp.ps := ANB_Processing and set.tip = 1;
anp.as := ANB_Processing and set.tip = 2; 
anp.os := ANB_Processing and set.tip = 3; 
*)
end_if;]]></ST>
                    </Function>
                    <Function UUID="QLH3Q4CCZZNUZDE6GAV5NNELHQ" Name="ANB_init" ResultTypeUUID="I7SVZ4ZR3CPE7BHJZXJTI4JZXI">
                        <Variables>
                            <Variable UUID="J3PMJZQQPFCKTLXZKHCSBVW2FY" Name="setForFault" Type="INT" Usage="input" />
                            <Variable UUID="PPFZBCEPQNDGDPXS4GFZ5DG2R4" Name="isUp" Type="BOOL" Usage="input" />
                            <Variable UUID="YGKONKKT2ZACFPHVF5HQIODJOQ" Name="delay" Type="REAL" Usage="input" />
                        </Variables>
                        <ST><![CDATA[//setStruct.spVal := spVal;//значения уставки
ANB_init.setForFault := setForFault;//значение, записываемое в ANB при неисправности канала: 0 - FALSE, 1 - TRUE, 2 - оставить то что было
ANB_init.isUp := isUp;//направление срабатывания. TRUE - верхняя, FALSE - нижняя
ANB_init.delay := delay;//задержка на срабатывание
//ANB_init.tip := tip; // тип уставки (1 ПС, 2 АС, 3 ОС)]]></ST>
                    </Function>
                </Folder>
                <Function UUID="FRQ7F67BQNBCDLLM53Q4UKPGR4" Name="AI_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="L27BSM7XEZH7PBAFCWXQPDPAHM" Name="in" Type="REAL" Usage="input" />
                        <Variable UUID="3RRZ672T65H27KGUANWIHJUTAQ" Name="set" Type="T_AI_Settings" TypeUUID="XHUY6ZRHGRQEVOF35XEJI5L2SE" Usage="input" />
                        <Variable UUID="6GENIMNWPJBGLDUSADU5POKSIU" Name="btn" Type="T_AI_FromHMI" TypeUUID="VZ3H6GEVT3CUTI65HAA5AALRAY" Usage="input" />
                        <Variable UUID="2ISD2SFA6RHOVBLDUJA43YIYKA" Name="out" Type="T_AI_ToHMI" TypeUUID="J74RQIZG5I6EZDCM32A6SZRKIM" Usage="inout" />
                        <Variable UUID="KNUNDWLBWVFKTOYD3CUNK54D2I" Name="my" Type="T_AI_Internal" TypeUUID="GZ6UU5D6R5EXXPFY4TZ3EOTECU" Usage="inout" />
                        <Variable UUID="Z3VWPXEY7ZHYHLOJY634T36OTI" Name="tmp" Type="INT" Usage="internal" />
                        <Variable UUID="3JRCDCALYZAKDD252W6PF3GDLA" Name="qCycleCheckROC" Comment="Количество циклов контроля РОК" Type="INT" Usage="internal" />
                        <Variable UUID="5M2NFBWVLJEB5GONNQSVU37O3M" Name="tau" Type="REAL" Usage="internal" />
                        <Variable UUID="4FOVGDDSVNDJVMJ33BNQD4UHBQ" Name="criticalSettingErr" Type="BOOL" Usage="internal" />
                        <Variable UUID="SIMSIEIFINHRJIC55L2DCXT3CM" Name="limSettingErr" Type="BOOL" Usage="internal" />
                        <Variable UUID="BGOHZRGBKVHJFGQBERMGBC6VXU" Name="brkSettingErr" Type="BOOL" Usage="internal" />
                    </Variables>
                    <ST><![CDATA[//---------------------- Поиск ошибок задания настроек – несоответствие допустимым значениям (BOOL)-----------------------------------------
criticalSettingErr := (set.min >= set.max or 
					set.minADC = set.maxADC or
					set.repairTime = 0 or set.recoveryTime < 0.0)  and not out.manual ;     //AKV
limSettingErr := (set.loLim >= set.hiLim or set.loLim >= set.max or set.hiLim <= set.min)  and not out.manual ;    //AKV
brkSettingErr := (set.hiBrk <= set.hiLim or set.loBrk >= set.loLim)  and not out.manual ;     //AKV
out.settingErr := criticalSettingErr or limSettingErr or brkSettingErr;
	out.fault_common := (out.settingErr or out.break or out.up_scale or out.down_scale or out.ROC)  and not out.manual ;  //AKV //обобщённая неисправность. Образуется по «ИЛИ» от break,up_scale,down_scale,ROC,settingErr (BOOL)
	out.criticalFault := (criticalSettingErr or out.break or out.ROC)  and not out.manual ;   //AKV //Критическая ошибка, свидетельствующая о полной неисправности канала

//---------------- таймер восстановления канала после неисправности или ремонта или ДУ ----------------------------------------------------------------
if not (criticalSettingErr or out.repair or out.manual) and my.prevFault then
	my.timerRecover := set.recoveryTime;
elsif my.timerRecover > 0.0 then
	my.timerRecover := my.timerRecover - tim.cycle;
else
	my.timerRecover := 0.0;
end_if;
my.prevFault := criticalSettingErr or out.repair or out.manual;
if criticalSettingErr then return; end_if; //Если есть ошибки настроек - прекращаем обработку
//---------------------------------------------------------------------------------------------------------------------------------------------
//----------------- Пересчёт парамера из кодов АЦП в единицы измерения -----------------------------------------------------------------------
out.measure := (in - set.minADC  + set.corrADC)/(set.maxADC - set.minADC)*(set.max - set.min)+set.min;//Пересчёт кода АЦП в инженерные единицы (REAL)
//---------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------- Определение обрыва и зашкалов -----------------------------------------------------------------------
if not brkSettingErr and not out.manual then    //AKV
	out.break      := out.break      and not btn.BTNworkOn or out.measure > set.hiBrk or out.measure < set.loBrk;	//обрыв канала (BOOL)
	elsif out.manual then
		out.break      := false;

end_if;
if not limSettingErr and not out.manual then //AKV
	out.up_scale   := out.up_scale   and not btn.BTNworkOn or out.measure > set.hiLim;							//выход за верхний зашкал (BOOL)
	out.down_scale := out.down_scale and not btn.BTNworkOn or out.manual or out.measure < set.loLim;							//выход за нижний зашкал (BOOL)
		elsif out.manual then
			out.up_scale   :=false;
			out.down_scale :=false;

end_if;
//---------------------------------------------------------------------------------------------------------------------------------------------
//----------- Расчёт превышения максимальной скорости изменения парамера -----------------------------------------------------------------------
if set.maxROC > 0.0 and tim.cycle > 0.0 then //Работает только если макс.скорость задана и есть корректное время цикла
	qCycleCheckROC := 3; //Количество циклов подряд, когда скорость изменения параметра превышает заданный предел
	if (out.measure - my.prevMeasure)/tim.cycle > set.maxROC  then //если новый замер больше старого на заданную величину приведённую к времени цикла
		if    my.qCycleROC >= 0 and my.qCycleROC < qCycleCheckROC then my.qCycleROC := my.qCycleROC + 1; //и предыдущий тоже был больше или никаким - увеличиваем счётчик на 1
		elsif my.qCycleROC < 0 then my.qCycleROC := 1;														//если предыдущая проверка показала падение скорости - устанавливаем счётчик на 1
		end_if;
	elsif (my.prevMeasure - out.measure)/tim.cycle > set.maxROC then // то же делаем для отрицательной разницы
		if    my.qCycleROC <= 0 and my.qCycleROC > -qCycleCheckROC then my.qCycleROC := my.qCycleROC - 1;
		elsif my.qCycleROC < 0 then my.qCycleROC := -1;
		end_if;
	else
		my.qCycleROC := 0; 		//если скорость в норме - обнуляем счётчик превышений подряд
								//и, если таймер восстановления не запущен, запоминаем достоверное значение
		//------- Обработка вывода канала в работу ----------------------------------------------------------------------------------------------------------
		if my.timerRecover <= 0.0 then my.validMeasure := out.measure;
		else my.validMeasure := my.validMeasure + (out.measure - my.validMeasure)*(set.recoveryTime - my.timerRecover + 1.0)/(set.recoveryTime + 1.0);
		end_if;
	end_if;
else
	//------- Обработка вывода канала в работу ----------------------------------------------------------------------------------------------------------
	if my.timerRecover <= 0.0 then my.validMeasure := out.measure;
	else my.validMeasure := my.validMeasure + (out.measure - my.validMeasure)*(set.recoveryTime - my.timerRecover + 1.0)/(set.recoveryTime + 1.0);
	end_if;
end_if;
//Если количество циклов с превышением скорости больше заданного количества, неисправность запоминаем до нажатия кнопки "в работу"
//= out.ROC := out.ROC and not btn.BTNworkOn or (my.qCycleROC >= qCycleCheckROC) or (my.qCycleROC <= -qCycleCheckROC);
out.ROC := (out.ROC and not btn.BTNworkOn or (my.qCycleROC >= qCycleCheckROC) or (my.qCycleROC <= -qCycleCheckROC)) and set.maxROC > 0.0;//=
my.prevMeasure := out.measure; //запоминаем предыдущее измерение.
//------------------------------------------------------------------------------------------------------------------------------------------------
out.repair := (btn.BTNrepairOn or out.repair) and not(btn.BTNworkOn or btn.BTNmanualOn or out.CurrentTimeOfRepair > set.repairTime);//канал в ремонте (BOOL)
out.manual := (btn.BTNmanualOn or out.manual) and not(btn.BTNworkOn or btn.BTNrepairOn);//канал в дист.упр. (BOOL)
//------------------- Обработка ремонта ----------------------------------------------------------------------------------------------------------
if out.repair and not btn.BTNrepairProlong then
	my.timerRepair := my.timerRepair + tim.cycle;//оставшееся время ремонта (INT)
else
	my.timerRepair := 0.0;
end_if;
tmp := set.repairTime - REAL_TO_INT(my.timerRepair);
if tmp >= 0 then out.CurrentTimeOfRepair := tmp;
else out.CurrentTimeOfRepair := 0;
end_if;
out.repair_time_less_10_percent := out.CurrentTimeOfRepair < set.repairTime/10;//до конца ремонта осталось меньше 10% от заданного времени (BOOL)
if out.repair then return; end_if; //если выставлен ремонт - не обновляем значение параметра для алгоритма
//------------------------------------------------------------------------------------------------------------------------------------------------
//------------------- Обработка ДУ ----------------------------------------------------------------------------------------------------------
if out.manual then
	my.validMeasure := btn.manualTarget;//значение для САУ. Рассчитывается из  measure, Manual_Target с учётом неисправностей и фильтрации (REAL)
else
	btn.manualTarget := my.validMeasure;
end_if;
//------------------------------------------------------------------------------------------------------------------------------------------------
//------------------- Расчёт PV ----------------------------------------------------------------------------------------------------------
//значение для САУ. Рассчитывается из  measure, Manual_Target с учётом неисправностей и фильтрации (REAL)
if tim.cycle > 0.0 then
	tau := 4.0 * set.tau/tim.cycle;
	if tau > 1.0 then
		out.PV := out.PV + (my.validMeasure - out.PV)/tau;
	else
		out.PV := my.validMeasure;
	end_if;
else
	out.PV := my.validMeasure;
end_if;
(*
set.min := ;//минимум шкалы канала, ед.изм. Не может быть >= max
set.max := ;//максимум шкалы канала, ед.изм. Не может быть <= min
set.loLim := ;//уровень зашкала вниз, ед.изм. Не может быть >= hiLim и < min
set.hiLim := ;//уровень зашкала вверх, ед.изм. Не может быть <= loLim и > max
set.minADC := ;//значение АЦП, соответствующее минимуму шкалы канала, б.р.
set.maxADC := ;//значение АЦП, соотв. макс. шкалы, б.р. Не может быть равно minADC
set.minROC := ;//макс. допустимая скорость сниж. показаний, ед.изм./сек. Если «0» - скорость падения не анализируется
set.maxROC := ;//макс. допустимая скорость роста, ед.изм./сек. Если «0» - скорость роста не анализируется
set.ROC_time := ;//время, за которое анализируется скорость изменения, сек. Если «0» - скорость не анализируется
set.recoveryTime := ;//время восстановления после неисправности, сек. Не может быть < «0»
set.repairTime := ;//максимальное время в ремонте, сек. Не может быть «0»
set.tau := ;//тау фильтра, сек. Если «0» - фильтрация отсутствует
set.id := ;//номер по порядку
btn.manualTarget //Задание из ЧМИ
btn.BTNmanualOn //Кнопка вкл. задания значения из ЧМИ
btn.BTNrepairOn //Кнопка вкл. ремонта
btn.BTNworkOn //Кнопка перекл. в работу
btn.BTNrepairProlong //Кнопка продления ремонта
*)]]></ST>
                </Function>
                <Function UUID="CF4QENKSGJC3PJ2UNFRMVS5ILY" Name="AI_init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="3PUM5EGSZZGW5B46GT7GJGJYHY" Name="setStruct" Type="T_AI_Settings" TypeUUID="XHUY6ZRHGRQEVOF35XEJI5L2SE" Usage="output" />
                        <Variable UUID="A4X47N4MTNEGBMHG5JCV54OYD4" Name="min" Type="REAL" Usage="input" />
                        <Variable UUID="J3PMJZQQPFCKTLXZKHCSBVW2FY" Name="max" Type="REAL" Usage="input" />
                        <Variable UUID="PPFZBCEPQNDGDPXS4GFZ5DG2R4" Name="minADC" Type="REAL" Usage="input" />
                        <Variable UUID="YGKONKKT2ZACFPHVF5HQIODJOQ" Name="maxADC" Type="REAL" Usage="input" />
                        <Variable UUID="SNMC52OSVNCEJC2WKNQ55IXRDU" Name="loLim" Type="REAL" Usage="input" />
                        <Variable UUID="C5FFNJBSORADZKDONAJYIOYQMM" Name="hiLim" Type="REAL" Usage="input" />
                        <Variable UUID="BLJ7QPD3B5GIFOK5INHVLE4N4M" Name="loBrk" Type="REAL" Usage="input" />
                        <Variable UUID="BRAZ2SPNOBCCNMKASNN375STCQ" Name="hiBrk" Type="REAL" Usage="input" />
                        <Variable UUID="A5ZCH4MWLNBG7GEVV73JJRNRZ4" Name="maxROC" Type="REAL" Usage="input" />
                        <Variable UUID="322VB4Q5PNEOBO55S4FRZSF2IQ" Name="recoveryTime" Type="REAL" Usage="input" />
                        <Variable UUID="UCAGZSJ77NAYTFYRM4N5QV62A4" Name="repairTime" Type="INT" Usage="input" />
                        <Variable UUID="3WUETIGW3VCGPPNXPQHEFM4NP4" Name="tau" Type="REAL" Usage="input" />
                        <Variable UUID="O2PSTUZUB5EIRAZBONFYBOPYXU" Name="id" Type="INT" Usage="input" />
                    </Variables>
                    <ST><![CDATA[setStruct.min:= min;//минимум шкалы канала, ед.изм. Не может быть >= max
setStruct.max:= max;//максимум шкалы канала, ед.изм. Не может быть <= min
setStruct.minADC:= minADC;//значение АЦП, соответствующее минимуму шкалы канала, б.р.
setStruct.maxADC:= maxADC;//значение АЦП, соотв. макс. шкалы, б.р. Не может быть равно minADC
setStruct.loLim:= loLim;//уровень зашкала вниз, ед.изм. Не может быть >= hiLim и < min
setStruct.hiLim:= hiLim;//уровень зашкала вверх, ед.изм. Не может быть <= loLim и > max
setStruct.loBrk:= loBrk;//уровень зашкала вниз, ед.изм. Не может быть >= loLim
setStruct.hiBrk:= hiBrk;//уровень обрыва вверх, ед.изм. Не может быть <= hiLim
setStruct.maxROC:= maxROC;//макс. допустимая скорость роста, ед.изм./сек. Если «0» - скорость роста не анализируется
setStruct.recoveryTime:= recoveryTime;//время восстановления после неисправности, сек. Не может быть меньше "0"
setStruct.repairTime:= repairTime;//максимальное время в ремонте, сек. Не может быть меньше или равно «0»
setStruct.tau:= tau;//тау фильтра, сек. Если «0» - фильтрация отсутствует
setStruct.id:= id;//номер по порядку	
setStruct.corrADC:= 0.0;//корректировка минимумa АЦП
]]></ST>
                </Function>
                <Function UUID="KN56QWFEILWWBFGTRCEYS6FASA" Name="UVI_AI_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="TGLRFATQ24XUPFHW373KXU5CZ4" Name="repTime" Type="INT" Usage="internal" />
                    </Variables>
                    <ST><![CDATA[repTime := 3600;
if init = false then

//------------------------------- аргументы функции инициализации --------------------------------
//минимум шкалы канала, ед.изм. Не может быть >= max
//максимум шкалы канала, ед.изм. Не может быть <= min
//значение АЦП, соответствующее минимуму шкалы канала, б.р.
//значение АЦП, соотв. макс. шкалы, б.р. Не может быть равно minADC
//уровень зашкала вниз, ед.изм. Не может быть >= hiLim и < min
//уровень зашкала вверх, ед.изм. Не может быть <= loLim и > max
//уровень зашкала вниз, ед.изм. Не может быть >= loLim
//уровень обрыва вверх, ед.изм. Не может быть <= hiLim
//макс. допустимая скорость роста, ед.изм./сек. Если «0» - скорость роста не анализируется
//время восстановления после неисправности, сек. Не может быть меньше "0"
//максимальное время в ремонте, сек. Не может быть меньше или равно «0»
//тау фильтра, сек. Если «0» - фильтрация отсутствует
//номер по порядку	
//-------------------------------------------------------------------------------------------
//Начало сгенерированного кода AI_init
//Верхний уровень в емкости E-8.1 дренажа метанола
AI_init(UVI_AI_Settings.Lmet_E8_1_v,4.0,21.5,11773.0,59714.0,3.475,22.025,2.95,22.55,0.0,1.0,repTime,1.0,0);
//Загазованность по метанолу (QISA-1)
AI_init(UVI_AI_Settings.Gas_met1_v,4.0,20.0,11773.0,59714.0,3.52,20.48,3.04,20.96,0.0,1.0,repTime,1.0,1);
//Загазованность по метанолу (QISA-2)
AI_init(UVI_AI_Settings.Gas_met2_v,4.0,20.0,11773.0,59714.0,3.52,20.48,3.04,20.96,0.0,1.0,repTime,1.0,2);
//Резерв
AI_init(UVI_AI_Settings.Res_0,0.0,100.0,11773.0,59714.0,0.0,0.0,0.0,0.0,0.0,1.0,repTime,1.0,3);
//Измерение основного напряжения
AI_init(UVI_AI_Settings.Uosn_SAU,0.0,100.0,11773.0,59714.0,0.0,0.0,0.0,0.0,0.0,1.0,repTime,1.0,4);
//Измерение резервного напряжения
AI_init(UVI_AI_Settings.Urez_SAU,0.0,100.0,11773.0,59714.0,0.0,0.0,0.0,0.0,0.0,1.0,repTime,1.0,5);
//Резерв
AI_init(UVI_AI_Settings.Res_1,0.0,100.0,11773.0,59714.0,0.0,0.0,0.0,0.0,0.0,1.0,repTime,1.0,6);
//Резерв
AI_init(UVI_AI_Settings.Res_2,0.0,100.0,11773.0,59714.0,0.0,0.0,0.0,0.0,0.0,1.0,repTime,1.0,7);
//Конец сгенерированного кода
end_if;
//Начало сгенерированного кода AI_Processing
//Верхний уровень в емкости E-8.1 дренажа метанола
AI_Processing(UVI_AI_DRV.Lmet_E8_1_v,UVI_AI_Settings.Lmet_E8_1_v,UVI_AI_FromHMI.Lmet_E8_1_v,UVI_AI_ToHMI.Lmet_E8_1_v,UVI_AI_Internal.Lmet_E8_1_v);
//Загазованность по метанолу (QISA-1)
AI_Processing(UVI_AI_DRV.Gas_met1_v,UVI_AI_Settings.Gas_met1_v,UVI_AI_FromHMI.Gas_met1_v,UVI_AI_ToHMI.Gas_met1_v,UVI_AI_Internal.Gas_met1_v);
//Загазованность по метанолу (QISA-2)
AI_Processing(UVI_AI_DRV.Gas_met2_v,UVI_AI_Settings.Gas_met2_v,UVI_AI_FromHMI.Gas_met2_v,UVI_AI_ToHMI.Gas_met2_v,UVI_AI_Internal.Gas_met2_v);
//Резерв
AI_Processing(UVI_AI_DRV.Res_0,UVI_AI_Settings.Res_0,UVI_AI_FromHMI.Res_0,UVI_AI_ToHMI.Res_0,UVI_AI_Internal.Res_0);
//Измерение основного напряжения
AI_Processing(UVI_AI_DRV.Uosn_SAU,UVI_AI_Settings.Uosn_SAU,UVI_AI_FromHMI.Uosn_SAU,UVI_AI_ToHMI.Uosn_SAU,UVI_AI_Internal.Uosn_SAU);
//Измерение резервного напряжения
AI_Processing(UVI_AI_DRV.Urez_SAU,UVI_AI_Settings.Urez_SAU,UVI_AI_FromHMI.Urez_SAU,UVI_AI_ToHMI.Urez_SAU,UVI_AI_Internal.Urez_SAU);
//Резерв
AI_Processing(UVI_AI_DRV.Res_1,UVI_AI_Settings.Res_1,UVI_AI_FromHMI.Res_1,UVI_AI_ToHMI.Res_1,UVI_AI_Internal.Res_1);
//Резерв
AI_Processing(UVI_AI_DRV.Res_2,UVI_AI_Settings.Res_2,UVI_AI_FromHMI.Res_2,UVI_AI_ToHMI.Res_2,UVI_AI_Internal.Res_2);
//Конец сгенерированного кода
]]></ST>
                </Function>
            </Folder>
            <Folder Name="DI" Comment="" Data="" UUID="BRH2QXNFQVEU5LHMQUFTMLXSJA">
                <Function UUID="P2XYAGEU5FGZTGPRCEWII4RCGE" Name="DI_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="L27BSM7XEZH7PBAFCWXQPDPAHM" Name="in" Type="BOOL" Usage="input" />
                        <Variable UUID="WHFS6UBDDVC7RDLEWVS6NYVJLQ" Name="externalFault" Type="BOOL" Usage="input" />
                        <Variable UUID="3RRZ672T65H27KGUANWIHJUTAQ" Name="set" Type="T_DI_Settings" TypeUUID="YYQ4LFBFOMREFPHHDI3SPZLDYM" Usage="input" />
                        <Variable UUID="6GENIMNWPJBGLDUSADU5POKSIU" Name="fromHMI" Type="T_DI_FromHMI" TypeUUID="CB63GVNINFXE5NDGOS62CUMGSY" Usage="inout" />
                        <Variable UUID="2ISD2SFA6RHOVBLDUJA43YIYKA" Name="toHMI" Type="T_DI_ToHMI" TypeUUID="GHOQ5H5MCDOEHDF2HTYC2D4HJI" Usage="inout" />
                        <Variable UUID="KNUNDWLBWVFKTOYD3CUNK54D2I" Name="my" Type="T_DI_Internal" TypeUUID="AZLZGZOBJZBF3NOVFVJWX37NVA" Usage="inout" />
                        <Variable UUID="BHQXJT3WMZFR5CMWIFB25VJNXQ" Name="out" Type="BOOL" Usage="inout" />
                        <Variable UUID="I6ZDT3YY5BCUHDXRDWGOOQPS74" Name="tmp" Type="INT" Usage="internal" />
                    </Variables>
                    <ST><![CDATA[//---------------------- Поиск ошибок задания настроек – несоответствие допустимым значениям (BOOL)-----------------------------------------
toHMI.settingErr := set.repairTime = 0;
toHMI.fault_common := toHMI.settingErr or externalFault;//обобщённая неисправность. Образуется по «ИЛИ» от settingErr и неисправности цепи датчика
//---------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------
toHMI.repair := (fromHMI.BTNrepairOn or toHMI.repair) and not(fromHMI.BTNworkOn or fromHMI.BTNmanualOn or toHMI.CurrentTimeOfRepair > set.repairTime);//канал в ремонте (BOOL)
toHMI.manual := (fromHMI.BTNmanualOn or toHMI.manual) and not(fromHMI.BTNworkOn or fromHMI.BTNrepairOn);//канал в дист.упр. (BOOL)
//------------------- Обработка ремонта ----------------------------------------------------------------------------------------------------------
if toHMI.repair and not fromHMI.BTNrepairProlong then
	my.timerRepair := my.timerRepair + tim.cycle;//оставшееся время ремонта (INT)
else
	my.timerRepair := 0.0;
end_if;
tmp := set.repairTime - REAL_TO_INT(my.timerRepair);
if(tmp >= 0) then toHMI.CurrentTimeOfRepair := tmp;
else toHMI.CurrentTimeOfRepair := 0;
end_if;
toHMI.repair_time_less_10_percent := toHMI.CurrentTimeOfRepair < set.repairTime/10;//до конца ремонта осталось меньше 10% от заданного времени (BOOL)
if toHMI.repair then return; end_if; //если выставлен ремонт - не обновляем значение параметра для алгоритма
//------------------------------------------------------------------------------------------------------------------------------------------------
fromHMI.BTNrepairOn := false;
fromHMI.BTNworkOn	:= false;
fromHMI.BTNmanualOn	:= false;
fromHMI.BTNrepairProlong := false;
//------------------- Обработка ДУ ----------------------------------------------------------------------------------------------------------
if toHMI.manual then
	out := fromHMI.manualTarget;	//значение для САУ. Рассчитывается из  measure, Manual_Target с учётом неисправностей и фильтрации (REAL)
	return; 					//дальнейшие вычисления не нужны
else
	fromHMI.manualTarget := out;
end_if;
//------------------------------------------------------------------------------------------------------------------------------------------------
//------------------- Расчёт PV ----------------------------------------------------------------------------------------------------------
//значение для САУ
if set.del = 0.0 then
	out := in;
else
    if not out and in and my.timerAntiTremor < set.del then// or not out and in then
        if my.timerAntiTremor < 0.0 then
            my.timerAntiTremor := 0.0;
        end_if;
        my.timerAntiTremor := my.timerAntiTremor + tim.cycle;
    elsif out and not in and my.timerAntiTremor > -set.del then// or not out and in then
        if my.timerAntiTremor > 0.0 then
            my.timerAntiTremor := 0.0;
        end_if;
        my.timerAntiTremor := my.timerAntiTremor - tim.cycle;
	else
		my.timerAntiTremor := 0.0;
    end_if;
    out := in and my.timerAntiTremor >= set.del or out and (in or my.timerAntiTremor > -set.del);
end_if;
//-----------------------------------------------------------------------------------------------------------------------------------
]]></ST>
                </Function>
                <Function UUID="HNOM4UHXFVC4LPCSJFKZTYGF74" Name="DI_init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="3PUM5EGSZZGW5B46GT7GJGJYHY" Name="setStruct" Type="T_DI_Settings" TypeUUID="YYQ4LFBFOMREFPHHDI3SPZLDYM" Usage="output" />
                        <Variable UUID="UCAGZSJ77NAYTFYRM4N5QV62A4" Name="repairTime" Type="INT" Usage="input" />
                        <Variable UUID="3WUETIGW3VCGPPNXPQHEFM4NP4" Name="del" Type="REAL" Usage="input" />
                        <Variable UUID="DOVR3SXOLZGSNMUJFQXZNFY4WQ" Name="inv" Type="BOOL" Usage="input" />
                        <Variable UUID="O2PSTUZUB5EIRAZBONFYBOPYXU" Name="id" Type="INT" Usage="input" />
                    </Variables>
                    <ST><![CDATA[setStruct.del:= del;//задержка от дребезга
setStruct.repairTime:= repairTime;//максимальное время в ремонте, сек. Не может быть меньше или равно «0»
setStruct.inv:= inv;//признак инверсии
setStruct.id:= id;//номер по порядку	]]></ST>
                </Function>
                <Function UUID="MBBMGDDXJBRGL57K7GIJDE6T5Q" Name="UVI_DI_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="IPPP52UYWOXETJA3YKWVVFCKSM" Name="repTime" Type="INT" Usage="internal" />
                    </Variables>
                    <ST><![CDATA[repTime := 3600;
if init = false then

//---------------- аргументы функции инициализации --------------------------
//задержка от дребезга
//максимальное время в ремонте, сек. Не может быть меньше или равно «0»
//признак инверсии
//номер по порядку	
//---------------------------------------------------------------------
//Начало сгенерированного кода DI_init
//Загазованность по метанолу QISA-1, порог 1
DI_init(UVI_DI_Settings.Gas_met1_v,repTime,0.0,false,0);
//Загазованность по метанолу QISA-1, порог 2
DI_init(UVI_DI_Settings.Gas_met1_av,repTime,0.0,false,1);
//Загазованность по метанолу QISA-1, неисправность датчика
DI_init(UVI_DI_Settings.Gas_met1_Bad,repTime,0.0,false,2);
//Загазованность по метанолу QISA-2, порог 1
DI_init(UVI_DI_Settings.Gas_met2_v,repTime,0.0,false,3);
//Загазованность по метанолу QISA-2, порог 2
DI_init(UVI_DI_Settings.Gas_met2_av,repTime,0.0,false,4);
//Загазованность по метанолу QISA-2, неисправность датчика
DI_init(UVI_DI_Settings.Gas_met2_Bad,repTime,0.0,false,5);
//Вентсистема В1 работает
DI_init(UVI_DI_Settings.Vn_V1_ON,repTime,0.0,false,6);
//Авария вентсистемы В1
DI_init(UVI_DI_Settings.Vn_V1_Alarm,repTime,0.0,false,7);
//ШЩ. Секционный автоматический выключатель включен
DI_init(UVI_DI_Settings.QS_ON,repTime,0.0,false,8);
//ШЩ. Секционный автоматический выключатель отключен
DI_init(UVI_DI_Settings.QS_OF,repTime,0.0,false,9);
//ШЩ.  Секционный автоматический выключатель аварийно отключен
DI_init(UVI_DI_Settings.QS_AOF,repTime,0.0,false,10);
//ШЩ.  Сигнализация наличия напряжения. I секция шин
DI_init(UVI_DI_Settings.U1_ok,repTime,0.0,false,11);
//ШЩ. Вводной автоматический выключатель включен
DI_init(UVI_DI_Settings.Q1_ON,repTime,0.0,false,12);
//ШЩ. Вводной автоматический выключатель отключен
DI_init(UVI_DI_Settings.Q1_OF,repTime,0.0,false,13);
//ШЩ. Вводной автоматический выключатель аварийно отключен
DI_init(UVI_DI_Settings.Q1_AOF,repTime,0.0,false,14);
//ШЩ. Вводной автоматический выключатель включен
DI_init(UVI_DI_Settings.Q2_ON,repTime,0.0,false,15);
//ШЩ. Вводной автоматический выключатель отключен
DI_init(UVI_DI_Settings.Q2_OF,repTime,0.0,false,16);
//ШЩ.  Вводной автоматический выключатель аварийно отключен
DI_init(UVI_DI_Settings.Q2_AOF,repTime,0.0,false,17);
//ШЩ.  Сигнализация наличия напряжения. II секция шин
DI_init(UVI_DI_Settings.U2_ok,repTime,0.0,false,18);
//УЗИП неисправен
DI_init(UVI_DI_Settings.UZIP_Bad,repTime,0.0,false,19);
//(Резерв)
DI_init(UVI_DI_Settings.Res_0,repTime,0.0,false,20);
//(Резерв)
DI_init(UVI_DI_Settings.Res_1,repTime,0.0,false,21);
//(Резерв)
DI_init(UVI_DI_Settings.Res_2,repTime,0.0,false,22);
//(Резерв)
DI_init(UVI_DI_Settings.Res_3,repTime,0.0,false,23);
//(Резерв)
DI_init(UVI_DI_Settings.Res_4,repTime,0.0,false,24);
//(Резерв)
DI_init(UVI_DI_Settings.Res_5,repTime,0.0,false,25);
//(Резерв)
DI_init(UVI_DI_Settings.Res_6,repTime,0.0,false,26);
//(Резерв)
DI_init(UVI_DI_Settings.Res_7,repTime,0.0,false,27);
//(Резерв)
DI_init(UVI_DI_Settings.Res_8,repTime,0.0,false,28);
//(Резерв)
DI_init(UVI_DI_Settings.Res_9,repTime,0.0,false,29);
//(Резерв)
DI_init(UVI_DI_Settings.Res_10,repTime,0.0,false,30);
//(Резерв)
DI_init(UVI_DI_Settings.Res_11,repTime,0.0,false,31);
//Контроль основного питания  ~220 В
DI_init(UVI_DI_Settings.Chk_AC220_SAU,repTime,0.0,false,32);
//Контроль резервного питания  =220 В
DI_init(UVI_DI_Settings.Chk_DC220_SAU,repTime,0.0,false,33);
//Двери шкафа открыты
DI_init(UVI_DI_Settings.Cabin_open,repTime,0.0,false,34);
//Контроль исправности разрядников
DI_init(UVI_DI_Settings.Chk_razr,repTime,0.0,false,35);
//Автоматы питания включены
DI_init(UVI_DI_Settings.QF_ON,repTime,0.0,false,36);
//Исправность осн. ИП =24В внутренних цепей
DI_init(UVI_DI_Settings.DC24osn_Int_ok,repTime,0.0,false,37);
//Исправность рез. ИП =24В внутренних цепей
DI_init(UVI_DI_Settings.DC24rez_Int_ok,repTime,0.0,false,38);
//Исправность осн. ИП =24В внешних цепей
DI_init(UVI_DI_Settings.DC24osn_Ext_ok,repTime,0.0,false,39);
//Исправность рез. ИП =24В внешних цепей
DI_init(UVI_DI_Settings.DC24rez_Ext_ok,repTime,0.0,false,40);
//(Резерв)
DI_init(UVI_DI_Settings.Res_12,repTime,0.0,false,41);
//(Резерв)
DI_init(UVI_DI_Settings.Res_13,repTime,0.0,false,42);
//(Резерв)
DI_init(UVI_DI_Settings.Res_14,repTime,0.0,false,43);
//(Резерв)
DI_init(UVI_DI_Settings.Res_15,repTime,0.0,false,44);
//(Резерв)
DI_init(UVI_DI_Settings.Res_16,repTime,0.0,false,45);
//(Резерв)
DI_init(UVI_DI_Settings.Res_17,repTime,0.0,false,46);
//(Резерв)
DI_init(UVI_DI_Settings.Res_18,repTime,0.0,false,47);
//Конец сгенерированного кода
end_if;
//Начало сгенерированного кода DI_Processing
//Загазованность по метанолу QISA-1, порог 1
DI_Processing(UVI_DI_DRV.Gas_met1_v,false,UVI_DI_Settings.Gas_met1_v,UVI_DI_FromHMI.Gas_met1_v,UVI_DI_ToHMI.Gas_met1_v,UVI_DI_Internal.Gas_met1_v,UVI_DI.Gas_met1_v);
//Загазованность по метанолу QISA-1, порог 2
DI_Processing(UVI_DI_DRV.Gas_met1_av,false,UVI_DI_Settings.Gas_met1_av,UVI_DI_FromHMI.Gas_met1_av,UVI_DI_ToHMI.Gas_met1_av,UVI_DI_Internal.Gas_met1_av,UVI_DI.Gas_met1_av);
//Загазованность по метанолу QISA-1, неисправность датчика
DI_Processing(UVI_DI_DRV.Gas_met1_Bad,false,UVI_DI_Settings.Gas_met1_Bad,UVI_DI_FromHMI.Gas_met1_Bad,UVI_DI_ToHMI.Gas_met1_Bad,UVI_DI_Internal.Gas_met1_Bad,UVI_DI.Gas_met1_Bad);
//Загазованность по метанолу QISA-2, порог 1
DI_Processing(UVI_DI_DRV.Gas_met2_v,false,UVI_DI_Settings.Gas_met2_v,UVI_DI_FromHMI.Gas_met2_v,UVI_DI_ToHMI.Gas_met2_v,UVI_DI_Internal.Gas_met2_v,UVI_DI.Gas_met2_v);
//Загазованность по метанолу QISA-2, порог 2
DI_Processing(UVI_DI_DRV.Gas_met2_av,false,UVI_DI_Settings.Gas_met2_av,UVI_DI_FromHMI.Gas_met2_av,UVI_DI_ToHMI.Gas_met2_av,UVI_DI_Internal.Gas_met2_av,UVI_DI.Gas_met2_av);
//Загазованность по метанолу QISA-2, неисправность датчика
DI_Processing(UVI_DI_DRV.Gas_met2_Bad,false,UVI_DI_Settings.Gas_met2_Bad,UVI_DI_FromHMI.Gas_met2_Bad,UVI_DI_ToHMI.Gas_met2_Bad,UVI_DI_Internal.Gas_met2_Bad,UVI_DI.Gas_met2_Bad);
//Вентсистема В1 работает
DI_Processing(UVI_DI_DRV.Vn_V1_ON,false,UVI_DI_Settings.Vn_V1_ON,UVI_DI_FromHMI.Vn_V1_ON,UVI_DI_ToHMI.Vn_V1_ON,UVI_DI_Internal.Vn_V1_ON,UVI_DI.Vn_V1_ON);
//Авария вентсистемы В1
DI_Processing(UVI_DI_DRV.Vn_V1_Alarm,false,UVI_DI_Settings.Vn_V1_Alarm,UVI_DI_FromHMI.Vn_V1_Alarm,UVI_DI_ToHMI.Vn_V1_Alarm,UVI_DI_Internal.Vn_V1_Alarm,UVI_DI.Vn_V1_Alarm);
//ШЩ. Секционный автоматический выключатель включен
DI_Processing(UVI_DI_DRV.QS_ON,false,UVI_DI_Settings.QS_ON,UVI_DI_FromHMI.QS_ON,UVI_DI_ToHMI.QS_ON,UVI_DI_Internal.QS_ON,UVI_DI.QS_ON);
//ШЩ. Секционный автоматический выключатель отключен
DI_Processing(UVI_DI_DRV.QS_OF,false,UVI_DI_Settings.QS_OF,UVI_DI_FromHMI.QS_OF,UVI_DI_ToHMI.QS_OF,UVI_DI_Internal.QS_OF,UVI_DI.QS_OF);
//ШЩ.  Секционный автоматический выключатель аварийно отключен
DI_Processing(UVI_DI_DRV.QS_AOF,false,UVI_DI_Settings.QS_AOF,UVI_DI_FromHMI.QS_AOF,UVI_DI_ToHMI.QS_AOF,UVI_DI_Internal.QS_AOF,UVI_DI.QS_AOF);
//ШЩ.  Сигнализация наличия напряжения. I секция шин
DI_Processing(UVI_DI_DRV.U1_ok,false,UVI_DI_Settings.U1_ok,UVI_DI_FromHMI.U1_ok,UVI_DI_ToHMI.U1_ok,UVI_DI_Internal.U1_ok,UVI_DI.U1_ok);
//ШЩ. Вводной автоматический выключатель включен
DI_Processing(UVI_DI_DRV.Q1_ON,false,UVI_DI_Settings.Q1_ON,UVI_DI_FromHMI.Q1_ON,UVI_DI_ToHMI.Q1_ON,UVI_DI_Internal.Q1_ON,UVI_DI.Q1_ON);
//ШЩ. Вводной автоматический выключатель отключен
DI_Processing(UVI_DI_DRV.Q1_OF,false,UVI_DI_Settings.Q1_OF,UVI_DI_FromHMI.Q1_OF,UVI_DI_ToHMI.Q1_OF,UVI_DI_Internal.Q1_OF,UVI_DI.Q1_OF);
//ШЩ. Вводной автоматический выключатель аварийно отключен
DI_Processing(UVI_DI_DRV.Q1_AOF,false,UVI_DI_Settings.Q1_AOF,UVI_DI_FromHMI.Q1_AOF,UVI_DI_ToHMI.Q1_AOF,UVI_DI_Internal.Q1_AOF,UVI_DI.Q1_AOF);
//ШЩ. Вводной автоматический выключатель включен
DI_Processing(UVI_DI_DRV.Q2_ON,false,UVI_DI_Settings.Q2_ON,UVI_DI_FromHMI.Q2_ON,UVI_DI_ToHMI.Q2_ON,UVI_DI_Internal.Q2_ON,UVI_DI.Q2_ON);
//ШЩ. Вводной автоматический выключатель отключен
DI_Processing(UVI_DI_DRV.Q2_OF,false,UVI_DI_Settings.Q2_OF,UVI_DI_FromHMI.Q2_OF,UVI_DI_ToHMI.Q2_OF,UVI_DI_Internal.Q2_OF,UVI_DI.Q2_OF);
//ШЩ.  Вводной автоматический выключатель аварийно отключен
DI_Processing(UVI_DI_DRV.Q2_AOF,false,UVI_DI_Settings.Q2_AOF,UVI_DI_FromHMI.Q2_AOF,UVI_DI_ToHMI.Q2_AOF,UVI_DI_Internal.Q2_AOF,UVI_DI.Q2_AOF);
//ШЩ.  Сигнализация наличия напряжения. II секция шин
DI_Processing(UVI_DI_DRV.U2_ok,false,UVI_DI_Settings.U2_ok,UVI_DI_FromHMI.U2_ok,UVI_DI_ToHMI.U2_ok,UVI_DI_Internal.U2_ok,UVI_DI.U2_ok);
//УЗИП неисправен
DI_Processing(UVI_DI_DRV.UZIP_Bad,false,UVI_DI_Settings.UZIP_Bad,UVI_DI_FromHMI.UZIP_Bad,UVI_DI_ToHMI.UZIP_Bad,UVI_DI_Internal.UZIP_Bad,UVI_DI.UZIP_Bad);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_0,false,UVI_DI_Settings.Res_0,UVI_DI_FromHMI.Res_0,UVI_DI_ToHMI.Res_0,UVI_DI_Internal.Res_0,UVI_DI.Res_0);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_1,false,UVI_DI_Settings.Res_1,UVI_DI_FromHMI.Res_1,UVI_DI_ToHMI.Res_1,UVI_DI_Internal.Res_1,UVI_DI.Res_1);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_2,false,UVI_DI_Settings.Res_2,UVI_DI_FromHMI.Res_2,UVI_DI_ToHMI.Res_2,UVI_DI_Internal.Res_2,UVI_DI.Res_2);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_3,false,UVI_DI_Settings.Res_3,UVI_DI_FromHMI.Res_3,UVI_DI_ToHMI.Res_3,UVI_DI_Internal.Res_3,UVI_DI.Res_3);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_4,false,UVI_DI_Settings.Res_4,UVI_DI_FromHMI.Res_4,UVI_DI_ToHMI.Res_4,UVI_DI_Internal.Res_4,UVI_DI.Res_4);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_5,false,UVI_DI_Settings.Res_5,UVI_DI_FromHMI.Res_5,UVI_DI_ToHMI.Res_5,UVI_DI_Internal.Res_5,UVI_DI.Res_5);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_6,false,UVI_DI_Settings.Res_6,UVI_DI_FromHMI.Res_6,UVI_DI_ToHMI.Res_6,UVI_DI_Internal.Res_6,UVI_DI.Res_6);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_7,false,UVI_DI_Settings.Res_7,UVI_DI_FromHMI.Res_7,UVI_DI_ToHMI.Res_7,UVI_DI_Internal.Res_7,UVI_DI.Res_7);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_8,false,UVI_DI_Settings.Res_8,UVI_DI_FromHMI.Res_8,UVI_DI_ToHMI.Res_8,UVI_DI_Internal.Res_8,UVI_DI.Res_8);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_9,false,UVI_DI_Settings.Res_9,UVI_DI_FromHMI.Res_9,UVI_DI_ToHMI.Res_9,UVI_DI_Internal.Res_9,UVI_DI.Res_9);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_10,false,UVI_DI_Settings.Res_10,UVI_DI_FromHMI.Res_10,UVI_DI_ToHMI.Res_10,UVI_DI_Internal.Res_10,UVI_DI.Res_10);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_11,false,UVI_DI_Settings.Res_11,UVI_DI_FromHMI.Res_11,UVI_DI_ToHMI.Res_11,UVI_DI_Internal.Res_11,UVI_DI.Res_11);
//Контроль основного питания  ~220 В
DI_Processing(UVI_DI_DRV.Chk_AC220_SAU,false,UVI_DI_Settings.Chk_AC220_SAU,UVI_DI_FromHMI.Chk_AC220_SAU,UVI_DI_ToHMI.Chk_AC220_SAU,UVI_DI_Internal.Chk_AC220_SAU,UVI_DI.Chk_AC220_SAU);
//Контроль резервного питания  =220 В
DI_Processing(UVI_DI_DRV.Chk_DC220_SAU,false,UVI_DI_Settings.Chk_DC220_SAU,UVI_DI_FromHMI.Chk_DC220_SAU,UVI_DI_ToHMI.Chk_DC220_SAU,UVI_DI_Internal.Chk_DC220_SAU,UVI_DI.Chk_DC220_SAU);
//Двери шкафа открыты
DI_Processing(UVI_DI_DRV.Cabin_open,false,UVI_DI_Settings.Cabin_open,UVI_DI_FromHMI.Cabin_open,UVI_DI_ToHMI.Cabin_open,UVI_DI_Internal.Cabin_open,UVI_DI.Cabin_open);
//Контроль исправности разрядников
DI_Processing(UVI_DI_DRV.Chk_razr,false,UVI_DI_Settings.Chk_razr,UVI_DI_FromHMI.Chk_razr,UVI_DI_ToHMI.Chk_razr,UVI_DI_Internal.Chk_razr,UVI_DI.Chk_razr);
//Автоматы питания включены
DI_Processing(UVI_DI_DRV.QF_ON,false,UVI_DI_Settings.QF_ON,UVI_DI_FromHMI.QF_ON,UVI_DI_ToHMI.QF_ON,UVI_DI_Internal.QF_ON,UVI_DI.QF_ON);
//Исправность осн. ИП =24В внутренних цепей
DI_Processing(UVI_DI_DRV.DC24osn_Int_ok,false,UVI_DI_Settings.DC24osn_Int_ok,UVI_DI_FromHMI.DC24osn_Int_ok,UVI_DI_ToHMI.DC24osn_Int_ok,UVI_DI_Internal.DC24osn_Int_ok,UVI_DI.DC24osn_Int_ok);
//Исправность рез. ИП =24В внутренних цепей
DI_Processing(UVI_DI_DRV.DC24rez_Int_ok,false,UVI_DI_Settings.DC24rez_Int_ok,UVI_DI_FromHMI.DC24rez_Int_ok,UVI_DI_ToHMI.DC24rez_Int_ok,UVI_DI_Internal.DC24rez_Int_ok,UVI_DI.DC24rez_Int_ok);
//Исправность осн. ИП =24В внешних цепей
DI_Processing(UVI_DI_DRV.DC24osn_Ext_ok,false,UVI_DI_Settings.DC24osn_Ext_ok,UVI_DI_FromHMI.DC24osn_Ext_ok,UVI_DI_ToHMI.DC24osn_Ext_ok,UVI_DI_Internal.DC24osn_Ext_ok,UVI_DI.DC24osn_Ext_ok);
//Исправность рез. ИП =24В внешних цепей
DI_Processing(UVI_DI_DRV.DC24rez_Ext_ok,false,UVI_DI_Settings.DC24rez_Ext_ok,UVI_DI_FromHMI.DC24rez_Ext_ok,UVI_DI_ToHMI.DC24rez_Ext_ok,UVI_DI_Internal.DC24rez_Ext_ok,UVI_DI.DC24rez_Ext_ok);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_12,false,UVI_DI_Settings.Res_12,UVI_DI_FromHMI.Res_12,UVI_DI_ToHMI.Res_12,UVI_DI_Internal.Res_12,UVI_DI.Res_12);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_13,false,UVI_DI_Settings.Res_13,UVI_DI_FromHMI.Res_13,UVI_DI_ToHMI.Res_13,UVI_DI_Internal.Res_13,UVI_DI.Res_13);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_14,false,UVI_DI_Settings.Res_14,UVI_DI_FromHMI.Res_14,UVI_DI_ToHMI.Res_14,UVI_DI_Internal.Res_14,UVI_DI.Res_14);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_15,false,UVI_DI_Settings.Res_15,UVI_DI_FromHMI.Res_15,UVI_DI_ToHMI.Res_15,UVI_DI_Internal.Res_15,UVI_DI.Res_15);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_16,false,UVI_DI_Settings.Res_16,UVI_DI_FromHMI.Res_16,UVI_DI_ToHMI.Res_16,UVI_DI_Internal.Res_16,UVI_DI.Res_16);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_17,false,UVI_DI_Settings.Res_17,UVI_DI_FromHMI.Res_17,UVI_DI_ToHMI.Res_17,UVI_DI_Internal.Res_17,UVI_DI.Res_17);
//(Резерв)
DI_Processing(UVI_DI_DRV.Res_18,false,UVI_DI_Settings.Res_18,UVI_DI_FromHMI.Res_18,UVI_DI_ToHMI.Res_18,UVI_DI_Internal.Res_18,UVI_DI.Res_18);
//Конец сгенерированного кода
]]></ST>
                </Function>
            </Folder>
            <Folder Name="DO" Comment="" Data="" UUID="FYLTDJ65YDTUBBBZTDNGLBQ6TE">
                <Function UUID="A5XW7BBUWNFW7M2YG2UJULUSFM" Name="DO_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables>
                        <Variable UUID="4AIZP6TN7OCU3GVNU6PSRDOTRA" Name="algOut" Type="BOOL" Usage="input" />
                        <Variable UUID="5R5WL3HGLRGMXN3ZVPA3FETS6Q" Name="fromHMI" Type="T_DO_FromHMI" TypeUUID="ICYCYA5WR5FTZMTITNXXGA6V4U" Usage="inout" />
                        <Variable UUID="EDA4FRWG6FGWJPKIBGBT6SNR2Q" Name="toHMI" Type="T_DO_ToHMI" TypeUUID="JPIXI5FFWBGSRAAFIJ2MBV77UE" Usage="inout" />
                        <Variable UUID="ROPOI5IJ6BZEBLSGQEGYPURC2I" Name="drv" Type="BOOL" Usage="output" />
                    </Variables>
                    <ST><![CDATA[toHMI.forsEnable := (toHMI.forsEnable or fromHMI.BTNforceOn) and toHMI.forsPermit and not fromHMI.BTNworkOn;
drv := algOut and not toHMI.forsEnable or fromHMI.manualTarget and toHMI.forsEnable;
fromHMI.manualTarget := drv;
//-------------------------------------------
fromHMI.BTNforceOn := false;
fromHMI.BTNworkOn := false;]]></ST>
                </Function>
                <Function UUID="ACXZX2R2JKAQ6KOVQ65GLZ52VU" Name="UVI_DO_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                    <Variables />
                    <ST><![CDATA[//----------- Обработка дискретных выходов ---------------
//Начало сгенерированного кода DO_Processing
//Верхний уровень в емкости E-8.1 для дренажа метанола
DO_Processing(UVI_DO.Lmet_E8_1_v,UVI_DO_FromHMI.Lmet_E8_1_v,UVI_DO_ToHMI.Lmet_E8_1_v,UVI_DO_DRV.Lmet_E8_1_v);
//Загазованность по метанолу табло информационное
DO_Processing(UVI_DO.Gas_Alarm1,UVI_DO_FromHMI.Gas_Alarm1,UVI_DO_ToHMI.Gas_Alarm1,UVI_DO_DRV.Gas_Alarm1);
//Загазованность по метанолу пост сигнализации
DO_Processing(UVI_DO.Gas_Alarm2,UVI_DO_FromHMI.Gas_Alarm2,UVI_DO_ToHMI.Gas_Alarm2,UVI_DO_DRV.Gas_Alarm2);
//Пуск вентсистемы В1
DO_Processing(UVI_DO.Vn_V1_ON,UVI_DO_FromHMI.Vn_V1_ON,UVI_DO_ToHMI.Vn_V1_ON,UVI_DO_DRV.Vn_V1_ON);
//Стоп вентсистемы В1
DO_Processing(UVI_DO.Vn_V1_OF,UVI_DO_FromHMI.Vn_V1_OF,UVI_DO_ToHMI.Vn_V1_OF,UVI_DO_DRV.Vn_V1_OF);
//Резерв
DO_Processing(UVI_DO.Res_0,UVI_DO_FromHMI.Res_0,UVI_DO_ToHMI.Res_0,UVI_DO_DRV.Res_0);
//Резерв
DO_Processing(UVI_DO.Res_1,UVI_DO_FromHMI.Res_1,UVI_DO_ToHMI.Res_1,UVI_DO_DRV.Res_1);
//Резерв
DO_Processing(UVI_DO.Res_2,UVI_DO_FromHMI.Res_2,UVI_DO_ToHMI.Res_2,UVI_DO_DRV.Res_2);
//Резерв
DO_Processing(UVI_DO.Res_3,UVI_DO_FromHMI.Res_3,UVI_DO_ToHMI.Res_3,UVI_DO_DRV.Res_3);
//Резерв
DO_Processing(UVI_DO.Res_4,UVI_DO_FromHMI.Res_4,UVI_DO_ToHMI.Res_4,UVI_DO_DRV.Res_4);
//Резерв
DO_Processing(UVI_DO.Res_5,UVI_DO_FromHMI.Res_5,UVI_DO_ToHMI.Res_5,UVI_DO_DRV.Res_5);
//Резерв
DO_Processing(UVI_DO.Res_6,UVI_DO_FromHMI.Res_6,UVI_DO_ToHMI.Res_6,UVI_DO_DRV.Res_6);
//Резерв
DO_Processing(UVI_DO.Res_7,UVI_DO_FromHMI.Res_7,UVI_DO_ToHMI.Res_7,UVI_DO_DRV.Res_7);
//Резерв
DO_Processing(UVI_DO.Res_8,UVI_DO_FromHMI.Res_8,UVI_DO_ToHMI.Res_8,UVI_DO_DRV.Res_8);
//Резерв
DO_Processing(UVI_DO.Res_9,UVI_DO_FromHMI.Res_9,UVI_DO_ToHMI.Res_9,UVI_DO_DRV.Res_9);
//Резерв
DO_Processing(UVI_DO.Res_10,UVI_DO_FromHMI.Res_10,UVI_DO_ToHMI.Res_10,UVI_DO_DRV.Res_10);
//Конец сгенерированного кода
]]></ST>
                </Function>
            </Folder>
        </Folder>
        <Folder Name="АПС" Comment="" Data="" UUID="EGFRLMDTYBXEZBNF6IDZHHQ6H4">
            <Function UUID="FW42INRNPRHFXK54IV4UB5K24M" Name="APS_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="5KOTXMQ56XMUXOPGEVEUSMNRCY" Name="unlock" Comment="Деблокировка" Type="BOOL" Usage="input" />
                    <Variable UUID="A4RLFHSGO6HEPPBSGLD75OAVJA" Name="i" Type="INT" Usage="internal" />
                </Variables>
                <ST><![CDATA[
for i :=0 to 8 do AlarmTarget[i] := FALSE; end_for; // 5 - номер последнего типа сигнализации (target)
if unlock then UVI_FirstOutIndex := 0; end_if;

new_wrn := false;
new_crs := false;
i:=0;
APS_Processing(UVI_ANB.Pmet_Kl_UVI1_Av, 1.0, unlock, UVI_APS.ev_Pmet_Kl_UVI1_Av, UVI_APS_Internal.ev_Pmet_Kl_UVI1_Av, UVI_FirstOutIndex, i); // Давление метанола перед распределительными клапанами УВИ1 высокое [AS]
APS_Processing(UVI_ANB.Pmet_Kl_UVI2_Av, 1.0, unlock, UVI_APS.ev_Pmet_Kl_UVI2_Av, UVI_APS_Internal.ev_Pmet_Kl_UVI2_Av, UVI_FirstOutIndex, i); // Давление метанола перед распределительными клапанами УВИ2 высокое [AS]
APS_Processing(UVI_ANB.Qmgms_met_UVI1_An, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI1_An, UVI_APS_Internal.ev_Qmgms_met_UVI1_An, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ1 низкий [AS]
APS_Processing(UVI_ANB.Qmgms_met_UVI1_Av, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI1_Av, UVI_APS_Internal.ev_Qmgms_met_UVI1_Av, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ1 высокий [AS]
APS_Processing(UVI_ANB.Qmgms_met_UVI2_An, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI2_An, UVI_APS_Internal.ev_Qmgms_met_UVI2_An, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ2 низкий [AS]
APS_Processing(UVI_ANB.Qmgms_met_UVI2_Av, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI2_Av, UVI_APS_Internal.ev_Qmgms_met_UVI2_Av, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ2 высокий [AS]
APS_Processing(UVI_DI.Gas_met1_av, 1.0, unlock, UVI_APS.Gas_met1_av, UVI_APS_Internal.Gas_met1_av, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-1 Порог «2» [AS]
APS_Processing(UVI_DI.Gas_met2_av, 1.0, unlock, UVI_APS.Gas_met2_av, UVI_APS_Internal.Gas_met2_av, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-2 Порог «2» [AS]
APS_Processing(UVI_ANB.Lmet_E8_1_v_Pn, 1.0, unlock, UVI_APS.Lmet_E8_1_v_Pn, UVI_APS_Internal.Lmet_E8_1_v_Pn, UVI_FirstOutIndex, i); // Верхний уровень в емкости E-8.1 дренажа метанола [PS]
APS_Processing(UVI_ANB.Uosn_SAU_Pn, 1.0, unlock, UVI_APS.Uosn_SAU_Pn, UVI_APS_Internal.Uosn_SAU_Pn, UVI_FirstOutIndex, i); // Основное напряжение САУ низкое [PS]
APS_Processing(UVI_ANB.Uosn_SAU_Pv, 1.0, unlock, UVI_APS.Uosn_SAU_Pv, UVI_APS_Internal.Uosn_SAU_Pv, UVI_FirstOutIndex, i); // Основное напряжение САУ высокое [PS]
APS_Processing(UVI_ANB.Urez_SAU_Pn, 1.0, unlock, UVI_APS.Urez_SAU_Pn, UVI_APS_Internal.Urez_SAU_Pn, UVI_FirstOutIndex, i); // Резервное напряжение САУ низкое [PS]
APS_Processing(UVI_ANB.Urez_SAU_Pv, 1.0, unlock, UVI_APS.Urez_SAU_Pv, UVI_APS_Internal.Urez_SAU_Pv, UVI_FirstOutIndex, i); // Резервное напряжение САУ высокое [PS]
APS_Processing(UVI_ANB.Pmet_Kl_UVI1_Pv, 1.0, unlock, UVI_APS.ev_Pmet_Kl_UVI1_Pv, UVI_APS_Internal.ev_Pmet_Kl_UVI1_Pv, UVI_FirstOutIndex, i); // Давление метанола перед распределительными клапанами УВИ1 повышенное [PS]
APS_Processing(UVI_ANB.Pmet_Kl_UVI2_Pv, 1.0, unlock, UVI_APS.ev_Pmet_Kl_UVI2_Pv, UVI_APS_Internal.ev_Pmet_Kl_UVI2_Pv, UVI_FirstOutIndex, i); // Давление метанола перед распределительными клапанами УВИ2 повышенное [PS]
APS_Processing(UVI_ANB.Qmgms_met_UVI1_Pn, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI1_Pn, UVI_APS_Internal.ev_Qmgms_met_UVI1_Pn, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ1 пониженный [PS]
APS_Processing(UVI_ANB.Qmgms_met_UVI1_Pv, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI1_Pv, UVI_APS_Internal.ev_Qmgms_met_UVI1_Pv, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ1 повышенный [PS]
APS_Processing(UVI_ANB.Qmgms_met_UVI2_Pn, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI2_Pn, UVI_APS_Internal.ev_Qmgms_met_UVI2_Pn, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ2 пониженный [PS]
APS_Processing(UVI_ANB.Qmgms_met_UVI2_Pv, 1.0, unlock, UVI_APS.ev_Qmgms_met_UVI2_Pv, UVI_APS_Internal.ev_Qmgms_met_UVI2_Pv, UVI_FirstOutIndex, i); // Мгновенный массовый расход метанола на УВИ2 повышенный [PS]
APS_Processing(UVI_DI.Gas_met1_v, 1.0, unlock, UVI_APS.Gas_met1_v, UVI_APS_Internal.Gas_met1_v, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-1 Порог «1» [PS]
APS_Processing(UVI_DI.Gas_met1_Bad, 1.0, unlock, UVI_APS.Gas_met1_Bad, UVI_APS_Internal.Gas_met1_Bad, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-1 «Неисправность датчика» [PS]
APS_Processing(UVI_DI.Gas_met2_v, 1.0, unlock, UVI_APS.Gas_met2_v, UVI_APS_Internal.Gas_met2_v, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-2 Порог «1» [PS]
APS_Processing(UVI_DI.Gas_met2_Bad, 1.0, unlock, UVI_APS.Gas_met2_Bad, UVI_APS_Internal.Gas_met2_Bad, UVI_FirstOutIndex, i); // Загазованность по метанолу поз. QISA-2 «Неисправность датчика» [PS]
APS_Processing(UVI_DI.QS_OF, 1.0, unlock, UVI_APS.QS_OF, UVI_APS_Internal.QS_OF, UVI_FirstOutIndex, i); // ШЩ. Секционный автоматический выключатель п.QF3 Отключен [PS]
APS_Processing(UVI_DI.QS_AOF, 1.0, unlock, UVI_APS.QS_AOF, UVI_APS_Internal.QS_AOF, UVI_FirstOutIndex, i); // ШЩ.  Секционный автоматический выключатель п.QF3 Аварийное отключение  [PS]
APS_Processing(UVI_DI.Q1_OF, 1.0, unlock, UVI_APS.Q1_OF, UVI_APS_Internal.Q1_OF, UVI_FirstOutIndex, i); // ШЩ. Вводной автоматический выключатель п.QF1  Отключен [PS]
APS_Processing(UVI_DI.Q2_OF, 1.0, unlock, UVI_APS.Q2_OF, UVI_APS_Internal.Q2_OF, UVI_FirstOutIndex, i); // ШЩ. Вводной автоматический выключатель п.QF2  Отключен [PS]
APS_Processing(UVI_DI.Q2_AOF, 1.0, unlock, UVI_APS.Q2_AOF, UVI_APS_Internal.Q2_AOF, UVI_FirstOutIndex, i); // ШЩ.  Вводной автоматический выключатель п.QF2 Аварийное отключение [PS]
APS_Processing(UVI_DI.UZIP_Bad, 1.0, unlock, UVI_APS.UZIP_Bad, UVI_APS_Internal.UZIP_Bad, UVI_FirstOutIndex, i); // ЩЗИП. Сигнализация выхода из строя УЗИП [PS]
APS_Processing(UVI_DI.Chk_AC220_SAU, 1.0, unlock, UVI_APS.Chk_AC220_SAU, UVI_APS_Internal.Chk_AC220_SAU, UVI_FirstOutIndex, i); // Нет основного питания  ~220 В [PS]
APS_Processing(UVI_DI.Chk_DC220_SAU, 1.0, unlock, UVI_APS.Chk_DC220_SAU, UVI_APS_Internal.Chk_DC220_SAU, UVI_FirstOutIndex, i); // Нет резервного питания  =220 В [PS]
APS_Processing(UVI_DI.Cabin_open, 1.0, unlock, UVI_APS.Cabin_open, UVI_APS_Internal.Cabin_open, UVI_FirstOutIndex, i); // Двери шкафа открыты [PS]
APS_Processing(UVI_DI.Chk_razr, 1.0, unlock, UVI_APS.Chk_razr, UVI_APS_Internal.Chk_razr, UVI_FirstOutIndex, i); // Нет исправности разрядников [PS]
APS_Processing(not UVI_DI.QF_ON, 1.0, unlock, UVI_APS.QF_ON, UVI_APS_Internal.QF_ON, UVI_FirstOutIndex, i); // Автоматы питания выключены [PS]
APS_Processing(not UVI_DI.DC24osn_Int_ok, 1.0, unlock, UVI_APS.DC24osn_Int_ok, UVI_APS_Internal.DC24osn_Int_ok, UVI_FirstOutIndex, i); // Неисправность осн. ИП =24В внутренних цепей [PS]
APS_Processing(not UVI_DI.DC24rez_Int_ok, 1.0, unlock, UVI_APS.DC24rez_Int_ok, UVI_APS_Internal.DC24rez_Int_ok, UVI_FirstOutIndex, i); // Неисправность рез. ИП =24В внутренних цепей [PS]
APS_Processing(not UVI_DI.DC24osn_Ext_ok, 1.0, unlock, UVI_APS.DC24osn_Ext_ok, UVI_APS_Internal.DC24osn_Ext_ok, UVI_FirstOutIndex, i); // Неисправность осн. ИП =24В внешних цепей [PS]
APS_Processing(not UVI_DI.DC24rez_Ext_ok, 1.0, unlock, UVI_APS.DC24rez_Ext_ok, UVI_APS_Internal.DC24rez_Ext_ok, UVI_FirstOutIndex, i); // Неисправность рез. ИП =24В внешних цепей [PS]
APS_Processing(UVI_DI.Vn_V1_Alarm, 1.0, unlock, UVI_APS.Vn_V1_Alarm, UVI_APS_Internal.Vn_V1_Alarm, UVI_FirstOutIndex, i); // Авария вентсистемы В1 [PS]
APS_Processing(KC_CRS.AOs or KC_CRS.AOb, 1.0, unlock, UVI_APS.AO_KC,  UVI_APS_Internal.AO_KC, UVI_FirstOutIndex, i); // Останов от цеховой системы


//------------------- Звук --------------------------------

(*
for i:=1 to 39 do
	new_wrn := UVI_APS.Arr[i] and not UVI_APS_Internal.Arr[i].pr_value and UVI_APS_Internal.Arr[i].target > 3 or new_wrn;
	new_crs := UVI_APS.Arr[i] and not UVI_APS_Internal.Arr[i].pr_value and UVI_APS_Internal.Arr[i].target < 4 or new_crs; 
	UVI_APS_Internal.Arr[i].pr_value  := UVI_APS.Arr[i];
end_for;
*)
UVI_Sound.alarm := (new_wrn or ps_im) or UVI_Sound.alarm and not (UVI_BTN.Sound_Off or unlock); // сигн. тревога
UVI_Sound.crash := new_crs or UVI_Sound.crash and not (UVI_BTN.Sound_Off or unlock); // сигн. авария
//признак отключения звука
UVI_SS.mute := (AlarmTarget[1] or AlarmTarget[2] or AlarmTarget[3] or AlarmTarget[4] or AlarmTarget[5]) and not UVI_Sound.crash  or 
			  (AlarmTarget[6] or AlarmTarget[7]) and not UVI_Sound.alarm;]]></ST>
            </Function>
            <Function UUID="JRWJCZBU4NHJNB6ORKLXITPVMQ" Name="APS_Init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables />
                <ST><![CDATA[
if not init then
Alarms.Fire := 1; // Пожар
Alarms.AOs := 2; // Аварийный останов со стравливанием
Alarms.AOb := 3; // Аварийный останов без стравливания
Alarms.VOs := 4; // Вынужденный останов со стравливанием
Alarms.VOb := 5; // Вынужденный останов без стравливания
Alarms.AS  := 6; // Аварийная сигнализация без останова
Alarms.PS  := 7; // Предупредительная сигнализация
Alarms.OS  := 8; // Ограничительная сигнализация

UVI_APS_Internal.ev_Pmet_Kl_UVI1_Av.target   := Alarms.AS; // Давление метанола перед распределительными клапанами УВИ1 высокое
UVI_APS_Internal.ev_Pmet_Kl_UVI2_Av.target   := Alarms.AS; // Давление метанола перед распределительными клапанами УВИ2 высокое
UVI_APS_Internal.ev_Qmgms_met_UVI1_An.target := Alarms.AS; // Мгновенный массовый расход метанола на УВИ1 низкий
UVI_APS_Internal.ev_Qmgms_met_UVI1_Av.target := Alarms.AS; // Мгновенный массовый расход метанола на УВИ1 высокий
UVI_APS_Internal.ev_Qmgms_met_UVI2_An.target := Alarms.AS; // Мгновенный массовый расход метанола на УВИ2 низкий
UVI_APS_Internal.ev_Qmgms_met_UVI2_Av.target := Alarms.AS; // Мгновенный массовый расход метанола на УВИ2 высокий
UVI_APS_Internal.Gas_met1_av.target          := Alarms.AS; // Загазованность по метанолу поз. QISA-1 Порог «2»
UVI_APS_Internal.Gas_met2_av.target          := Alarms.AS; // Загазованность по метанолу поз. QISA-2 Порог «2»
UVI_APS_Internal.Lmet_E8_1_v_Pn.target       := Alarms.PS; // Верхний уровень в емкости E-8.1 дренажа метанола
UVI_APS_Internal.Uosn_SAU_Pn.target          := Alarms.PS; // Основное напряжение САУ низкое
UVI_APS_Internal.Uosn_SAU_Pv.target          := Alarms.PS; // Основное напряжение САУ высокое
UVI_APS_Internal.Urez_SAU_Pn.target          := Alarms.PS; // Резервное напряжение САУ низкое
UVI_APS_Internal.Urez_SAU_Pv.target          := Alarms.PS; // Резервное напряжение САУ высокое
UVI_APS_Internal.ev_Pmet_Kl_UVI1_Pv.target   := Alarms.PS; // Давление метанола перед распределительными клапанами УВИ1 повышенное
UVI_APS_Internal.ev_Pmet_Kl_UVI2_Pv.target   := Alarms.PS; // Давление метанола перед распределительными клапанами УВИ2 повышенное
UVI_APS_Internal.ev_Qmgms_met_UVI1_Pn.target := Alarms.PS; // Мгновенный массовый расход метанола на УВИ1 пониженный
UVI_APS_Internal.ev_Qmgms_met_UVI1_Pv.target := Alarms.PS; // Мгновенный массовый расход метанола на УВИ1 повышенный
UVI_APS_Internal.ev_Qmgms_met_UVI2_Pn.target := Alarms.PS; // Мгновенный массовый расход метанола на УВИ2 пониженный
UVI_APS_Internal.ev_Qmgms_met_UVI2_Pv.target := Alarms.PS; // Мгновенный массовый расход метанола на УВИ2 повышенный
UVI_APS_Internal.Gas_met1_v.target           := Alarms.PS; // Загазованность по метанолу поз. QISA-1 Порог «1»
UVI_APS_Internal.Gas_met1_Bad.target         := Alarms.PS; // Загазованность по метанолу поз. QISA-1 «Неисправность датчика»
UVI_APS_Internal.Gas_met2_v.target           := Alarms.PS; // Загазованность по метанолу поз. QISA-2 Порог «1»
UVI_APS_Internal.Gas_met2_Bad.target         := Alarms.PS; // Загазованность по метанолу поз. QISA-2 «Неисправность датчика»
UVI_APS_Internal.QS_OF.target                := Alarms.PS; // ШЩ. Секционный автоматический выключатель п.QF3 Отключен
UVI_APS_Internal.QS_AOF.target               := Alarms.PS; // ШЩ.  Секционный автоматический выключатель п.QF3 Аварийное отключение 
UVI_APS_Internal.Q1_OF.target                := Alarms.PS; // ШЩ. Вводной автоматический выключатель п.QF1  Отключен
UVI_APS_Internal.Q2_OF.target                := Alarms.PS; // ШЩ. Вводной автоматический выключатель п.QF2  Отключен
UVI_APS_Internal.Q2_AOF.target               := Alarms.PS; // ШЩ.  Вводной автоматический выключатель п.QF2 Аварийное отключение
UVI_APS_Internal.UZIP_Bad.target             := Alarms.PS; // ЩЗИП. Сигнализация выхода из строя УЗИП
UVI_APS_Internal.Chk_AC220_SAU.target        := Alarms.PS; // Нет основного питания  ~220 В
UVI_APS_Internal.Chk_DC220_SAU.target        := Alarms.PS; // Нет резервного питания  =220 В
UVI_APS_Internal.Cabin_open.target           := Alarms.PS; // Двери шкафа открыты
UVI_APS_Internal.Chk_razr.target             := Alarms.PS; // Нет исправности разрядников
UVI_APS_Internal.QF_ON.target                := Alarms.PS; // Автоматы питания выключены
UVI_APS_Internal.DC24osn_Int_ok.target       := Alarms.PS; // Неисправность осн. ИП =24В внутренних цепей
UVI_APS_Internal.DC24rez_Int_ok.target       := Alarms.PS; // Неисправность рез. ИП =24В внутренних цепей
UVI_APS_Internal.DC24osn_Ext_ok.target       := Alarms.PS; // Неисправность осн. ИП =24В внешних цепей
UVI_APS_Internal.DC24rez_Ext_ok.target       := Alarms.PS; // Неисправность рез. ИП =24В внешних цепей
UVI_APS_Internal.Vn_V1_Alarm.target          := Alarms.PS; // Авария вентсистемы В1
UVI_APS_Internal.AO_KC.target   		 	 := Alarms.AS; // Останов от цеховой системы

end_if;
]]></ST>
            </Function>
            <Function UUID="5JNGGSG7TFAZNF652CWSBV7ITU" Name="APS_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="XUPU5QSBXZB3VKJC3T2JHCQBBE" Name="cnd" Comment="условие защиты" Type="BOOL" Usage="input" />
                    <Variable UUID="JGZ43QLS3Y3ULHFPRNURAOQSIY" Name="delay" Comment="задержка, с" Type="REAL" Usage="input" />
                    <Variable UUID="6ZQWFLESTWCE5BISEPM5ARCL5U" Name="reset" Comment="сброс защиты" Type="BOOL" Usage="input" />
                    <Variable UUID="DGLQLOIG5VHVZKGYZCFYXHHMA4" Name="alr" Comment="выход аларма" Type="BOOL" Usage="inout" />
                    <Variable UUID="VBXXK6DJKZDA3NVMCEXSSROBZQ" Name="var" Type="T_APS_Internal" TypeUUID="Y2SUFYR34WCUVAETREJRLVIA74" Usage="inout" />
                    <Variable UUID="GPPVQEL7KXYEDFUOLVBG2MOKWM" Name="firstoutIndex" Comment="Индекс первопричины" Type="INT" Usage="inout" />
                    <Variable UUID="ZBDBYGOJVK6ENPJDBDHCVBPHWI" Name="index" Type="INT" Usage="inout" />
                    <Variable UUID="VPNS5SKQUSWU3OXZBMSDBVKMHI" Name="av" Type="BOOL" Usage="internal" />
                </Variables>
                <ST><![CDATA[if cnd
	then if var.tmr <= delay then var.tmr := var.tmr + tim.cycle; end_if;  //отсчет задержки
	else var.tmr := 0.0; 
end_if;
av := var.tmr > delay ; //срабатывание аварии
//-- детектирование нового аларма (для звука)
new_wrn := av and not var.pr_value and var.target >= Alarms.AS or new_wrn; // новое предупреждение
new_crs := av and not var.pr_value and var.target <= Alarms.VOb or new_crs; //новая авария
var.pr_value := av;
//-- 
alr := av or alr and not reset; //выдача аларма
AlarmTarget[var.target] := AlarmTarget[var.target] or alr; //срабатывание защиты в алгоритм
//первопричина
if var.target >= Alarms.AS or firstoutIndex <> 0 then return; end_if;
index := index + 1;
if alr then firstoutIndex := index; end_if;	]]></ST>
            </Function>
        </Folder>
        <Folder Name="Алгоритм" Comment="" Data="" UUID="QTBWLT2SSDCE5HEZI6YSBIS2HI">
            <Function UUID="ML2IACWZS7CEHJOW6R5PEBGND4" Name="Alg_UVI" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables />
                <ST><![CDATA[//====================================== УВИ =======================================================
//==================================================================================================
//= АО от САУ КЦ algKC.AO

algUVI.AO := KC_Mode.AOssKC OR KC_Mode.AObsKC;

(*=======    Вычислим чуть позже: - сделаны через уставки ANB//=
// Давление метанола перед клапанами
algUVI.	Pmet_Kl_UVI1_Pv	 :=	;	//
algUVI.	Pmet_Kl_UVI1_Av	 :=	;	//
algUVI.	Pmet_Kl_UVI2_Pv	 :=	;	//
algUVI.	Pmet_Kl_UVI2_Av	 :=	;	//

// Мгновенные массовые расходы
algUVI.	Qmgms_met_UVI1_An	 :=	;	//
algUVI.	Qmgms_met_UVI1_Pn	 :=	;	//
algUVI.	Qmgms_met_UVI1_Pv	 :=	;	//
algUVI.	Qmgms_met_UVI1_Av	 :=	;	//
algUVI.	Qmgms_met_UVI2_An	 :=	;	//
algUVI.	Qmgms_met_UVI2_Pn	 :=	;	//
algUVI.	Qmgms_met_UVI2_Pv	 :=	;	//
algUVI.	Qmgms_met_UVI2_Av	 :=	;	//

*)]]></ST>
            </Function>
            <FunctionBlock UUID="UB363VV3BHWEPNZS3N22GQE2PI" Name="FB_Logic">
                <Variables>
                    <Variable UUID="LN4UL3UWRS2ETAKXFMJOWIJLUY" Name="Kn_DU_IM" Type="FB_Ttrg" TypeUUID="JH6E2RDLE37ULL4MOUYCEZKSHQ" Usage="internal" />
                    <Variable UUID="6YEU73BAX7XE7ON6L3GCZIV2QE" Name="Gas_met" Type="BOOL" Usage="internal" />
                    <Variable UUID="COS7HMHV6OHEPEFBN555QZ56JI" Name="Fl_Gas_met" Type="BOOL" Usage="internal" />
                    <Variable UUID="IMNJGDE3NB5E3DG2RZDVX7G2PI" Name="TMR_Gas_met" Type="TON" TypeUUID="NM52J2VHZ3GU3NCIW4VK3USPKU" Usage="internal" />
                </Variables>
                <ST><![CDATA[//====================================== УВИ =======================================================
//==================================================================================================
//Включение ДУ для ИМ по кнопке
UVI_SS.Prm_DU_IM := NOT algUVI.AO; //разрешение кнопки
Kn_DU_IM(UVI_BTN.DU_IM, NOT UVI_SS.Prm_DU_IM, UVI_TS.DU_IM); //включение ДУ для ИМ (пропадание UVI_SS.Prm_DU_IM сбросит флаг ДУ UVI_TS.DU_IM в ноль)

//= Включение Вентсистемы В1 по загазованности
Gas_met := UVI_DI.Gas_met1_v or UVI_DI.Gas_met1_av or UVI_DI.Gas_met2_v or UVI_DI.Gas_met2_av;//= Обобщённый сигнал загазованности
UVI_AM.Vn_V1.algOff	:= Fl_Gas_met AND TMR_Gas_met.Q;
Fl_Gas_met := Gas_met or Fl_Gas_met AND NOT TMR_Gas_met.Q;
TMR_Gas_met(IN:= NOT Gas_met, PT:= T#60s);//= отключение через 60с после снятия сигналов о загазованности
UVI_AM.Vn_V1.algOn	:= Fl_Gas_met;

//= Загазованность по метанолу
UVI_DO.Gas_Alarm1 := Gas_met;//= вывод на табло
UVI_DO.Gas_Alarm2 := Gas_met;//= вывод на пост сигнализации

//= Уровень в емкости E-8.1
UVI_DO.Lmet_E8_1_v := UVI_ANB.Lmet_E8_1_v_Pn;//= Верхний уровень в емкости E-8.1 для дренажа метанола]]></ST>
            </FunctionBlock>
            <FunctionBlock UUID="JH6E2RDLE37ULL4MOUYCEZKSHQ" Name="FB_Ttrg" Comment="Т-триггер на дискретных элементах">
                <Variables>
                    <Variable UUID="G733ZPQIUZCUZJXOIV7OQQT3G4" Name="c" Comment="Входной тактовый импульс" Type="BOOL" Usage="input" />
                    <Variable UUID="7QPJXKAOG7XUTMS7SZ3FDZDHCE" Name="r" Comment="Безусловный сброс" Type="BOOL" Usage="input" />
                    <Variable UUID="VBKMAUZHCLJUTLMX4GJ6QYJVRY" Name="q" Comment="Выход Т-триггера" Type="BOOL" Usage="output" />
                    <Variable UUID="EEKECSBDYVAELGKC3TOJWPG56M" Name="pr_c" Type="BOOL" Usage="internal" />
                </Variables>
                <ST><![CDATA[
q := (c AND NOT pr_c  AND NOT q OR q) AND NOT (c AND NOT pr_c  AND q OR r);
pr_c := c;]]></ST>
            </FunctionBlock>
        </Folder>
        <Folder Name="Драйверы" Comment="" Data="" UUID="D3DQMJTFEWPU3AIHYVXAES3EAE">
            <Folder Name="УВИ" Comment="" Data="" UUID="SDIKRBP4527UXAJ6ZIPYNXLQJQ">
                <Folder Name="AI" Comment="" Data="" UUID="2INUPUKS3M2EFGUKOEOP4UAOWU">
                    <Function UUID="P2ZRBD2PJMR6DDAH32Y3R3MGSM" Name="UVI_UVI_AI_Permit" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables>
                            <Variable UUID="TGLRFATQ24XUPFHW373KXU5CZ4" Name="tmpPermit" Type="BOOL" Usage="internal" />
                        </Variables>
                        <ST><![CDATA[//--- Групповое разрешение ДУ ---
tmpPermit := true;
//Начало сгенерированного кода AI_Permit
UVI_UVI_mb_AI_ToHMI.Qi_1.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 1;
UVI_UVI_mb_AI_ToHMI.Qi_2.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 2;
UVI_UVI_mb_AI_ToHMI.Qi_3.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 3;
UVI_UVI_mb_AI_ToHMI.Qi_4.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 4;
UVI_UVI_mb_AI_ToHMI.Qi_5.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 5;
UVI_UVI_mb_AI_ToHMI.Qi_6.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 6;
UVI_UVI_mb_AI_ToHMI.Qi_7.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 7;
UVI_UVI_mb_AI_ToHMI.Qi_8.manual := tmpPermit; //Измеренный мгновенный расход ингибитора канал 8;
UVI_UVI_mb_AI_ToHMI.Qr_1.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 1;
UVI_UVI_mb_AI_ToHMI.Qr_2.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 2;
UVI_UVI_mb_AI_ToHMI.Qr_3.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 3;
UVI_UVI_mb_AI_ToHMI.Qr_4.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 4;
UVI_UVI_mb_AI_ToHMI.Qr_5.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 5;
UVI_UVI_mb_AI_ToHMI.Qr_6.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 6;
UVI_UVI_mb_AI_ToHMI.Qr_7.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 7;
UVI_UVI_mb_AI_ToHMI.Qr_8.manual := tmpPermit; //Расчитанный мгновенный расход ингибитора канал 8;
UVI_UVI_mb_AI_ToHMI.Qi_sum.manual := tmpPermit; //Мгновенный измеренный расход ингибитора суммарно по каналам;
UVI_UVI_mb_AI_ToHMI.Tk.manual := tmpPermit; //Температура внутри корпуса;
UVI_UVI_mb_AI_ToHMI.U.manual := tmpPermit; //Напряжение питания;
UVI_UVI_mb_AI_ToHMI.Q.manual := tmpPermit; //Мгновенный расход расходомера;
UVI_UVI_mb_AI_ToHMI.dPf.manual := tmpPermit; //Текущий перепад давления на фильтре;
UVI_UVI_mb_AI_ToHMI.Pf.manual := tmpPermit; //Текущее давление на фильтре;
UVI_UVI_mb_AI_ToHMI.P.manual := tmpPermit; //Текущее значение давления;
UVI_UVI_mb_AI_ToHMI.dPf_max.manual := tmpPermit; //Текущий максимальный перепад давления на фильтре;
UVI_UVI_mb_AI_ToHMI.Kq.manual := tmpPermit; //Коэф-т поправки расхода по каналам;
UVI_UVI_mb_AI_ToHMI.Den.manual := tmpPermit; //Текущая плотность ингибитора;
UVI_UVI_mb_AI_ToHMI.Qmax_ch1.manual := tmpPermit; //Максимальный расход канал 1;
UVI_UVI_mb_AI_ToHMI.Qmax_ch2.manual := tmpPermit; //Максимальный расход канал 2;
UVI_UVI_mb_AI_ToHMI.Qmax_ch3.manual := tmpPermit; //Максимальный расход канал 3;
UVI_UVI_mb_AI_ToHMI.Qmax_ch4.manual := tmpPermit; //Максимальный расход канал 4;
UVI_UVI_mb_AI_ToHMI.Qmax_ch5.manual := tmpPermit; //Максимальный расход канал 5;
UVI_UVI_mb_AI_ToHMI.Qmax_ch6.manual := tmpPermit; //Максимальный расход канал 6;
UVI_UVI_mb_AI_ToHMI.Qmax_ch7.manual := tmpPermit; //Максимальный расход канал 7;
UVI_UVI_mb_AI_ToHMI.Qmax_ch8.manual := tmpPermit; //Максимальный расход канал 8;
UVI_UVI_mb_AI_ToHMI.Qdem_1.manual := tmpPermit; //Требуемый расход канал 1;
UVI_UVI_mb_AI_ToHMI.Qdem_2.manual := tmpPermit; //Требуемый расход канал 2;
UVI_UVI_mb_AI_ToHMI.Qdem_3.manual := tmpPermit; //Требуемый расход канал 3;
UVI_UVI_mb_AI_ToHMI.Qdem_4.manual := tmpPermit; //Требуемый расход канал 4;
UVI_UVI_mb_AI_ToHMI.Qdem_5.manual := tmpPermit; //Требуемый расход канал 5;
UVI_UVI_mb_AI_ToHMI.Qdem_6.manual := tmpPermit; //Требуемый расход канал 6;
UVI_UVI_mb_AI_ToHMI.Qdem_7.manual := tmpPermit; //Требуемый расход канал 7;
UVI_UVI_mb_AI_ToHMI.Qdem_8.manual := tmpPermit; //Требуемый расход канал 8;
UVI_UVI_mb_AI_ToHMI.Mode_ch.manual := tmpPermit; //Режим работы каналов;
UVI_UVI_mb_AI_ToHMI.Flow_On.manual := tmpPermit; //Расходомер включен/выключен;
UVI_UVI_mb_AI_ToHMI.dP_max.manual := tmpPermit; //Максиимальный перепад давление на фильтре;
UVI_UVI_mb_AI_ToHMI.T_max.manual := tmpPermit; //Максимальное значение температуры внутри модуля;
UVI_UVI_mb_AI_ToHMI.U_min.manual := tmpPermit; //Минимальное значение напряжения питания;
UVI_UVI_mb_AI_ToHMI.U_max.manual := tmpPermit; //Максимальное значение напряжения питания;
//Конец сгенерированного кода
//Начало сгенерированного кода AI_Alter
//Конец сгенерированного кода
]]></ST>
                    </Function>
                    <FunctionBlock UUID="Y4UUEO6BMA4EJAB2WLGFMUSQEY" Name="UVI_UVI_mb_AI_CallAll_FB">
                        <Variables>
                            <Variable UUID="PE2YWAPF3KRUDCLW7KKZ4UZYMI" Name="Proc_TMR_ON" Type="TON" TypeUUID="NM52J2VHZ3GU3NCIW4VK3USPKU" Usage="internal" />
                            <Variable UUID="6I6EY6CWD5KU7AFEQC6HYO4ZIA" Name="TMO_ON" Type="BOOL" Usage="internal" />
                            <Variable UUID="RMHAGWYOYARU5LND6UK6EDXZ6E" Name="TMR_ON" Type="TIME" Usage="internal" />
                        </Variables>
                        <ST><![CDATA[Proc_TMR_ON(TRUE, T#15s, TMO_ON, TMR_ON);
IF not TMO_ON THEN

//------------------------------- аргументы функции инициализации --------------------------------
// 1                               минимум шкалы канала, ед.изм. Не может быть >= max
// 2                               |    максимум шкалы канала, ед.изм. Не может быть <= min
// 3                               |    |   уровень зашкала вниз, ед.изм. Не может быть >= hiLim и < min
// 4                               |    |   |   уровень зашкала вверх, ед.изм. Не может быть <= loLim и > max
// 5                               |    |   |   |    уровень обрыва вниз, ед.изм. Не может быть >= loLim
// 6                               |    |   |   |    |    уровень обрыва вверх, ед.изм. Не может быть <= hiLim
// 7                               |    |   |   |    |    |  Формат данных
// 8                               |    |   |   |    |    |  |  Настройка 1
// 9                               |    |   |   |    |    |  |  |   Настройка 2
//12                               |    |   |   |    |    |  |  |   |   тау фильтра, сек. Если «0» - фильтрация отсутствует
//13                               |    |   |   |    |    |  |  |   |   |  номер по порядку	
//mb_AI_init(mb_AI_Settings.T_VT1,0.0,50.0,0.0,0.0,-1.5,51.5,0,0.0,0.0,0.0,0);
//-------------------------------------------------------------------------------------------
//Начало сгенерированного кода AI_init
//Измеренный мгновенный расход ингибитора канал 1
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_1,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,1);
//Измеренный мгновенный расход ингибитора канал 2
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_2,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,2);
//Измеренный мгновенный расход ингибитора канал 3
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_3,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,3);
//Измеренный мгновенный расход ингибитора канал 4
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_4,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,4);
//Измеренный мгновенный расход ингибитора канал 5
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_5,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,5);
//Измеренный мгновенный расход ингибитора канал 6
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_6,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,6);
//Измеренный мгновенный расход ингибитора канал 7
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_7,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,7);
//Измеренный мгновенный расход ингибитора канал 8
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_8,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,8);
//Расчитанный мгновенный расход ингибитора канал 1
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_1,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,9);
//Расчитанный мгновенный расход ингибитора канал 2
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_2,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,10);
//Расчитанный мгновенный расход ингибитора канал 3
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_3,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,11);
//Расчитанный мгновенный расход ингибитора канал 4
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_4,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,12);
//Расчитанный мгновенный расход ингибитора канал 5
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_5,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,13);
//Расчитанный мгновенный расход ингибитора канал 6
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_6,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,14);
//Расчитанный мгновенный расход ингибитора канал 7
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_7,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,15);
//Расчитанный мгновенный расход ингибитора канал 8
mb_AI_init(UVI_UVI_mb_AI_Settings.Qr_8,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,16);
//Мгновенный измеренный расход ингибитора суммарно по каналам
mb_AI_init(UVI_UVI_mb_AI_Settings.Qi_sum,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,17);
//Температура внутри корпуса
mb_AI_init(UVI_UVI_mb_AI_Settings.Tk,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,19);
//Напряжение питания
mb_AI_init(UVI_UVI_mb_AI_Settings.U,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,20);
//Мгновенный расход расходомера
mb_AI_init(UVI_UVI_mb_AI_Settings.Q,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,22);
//Текущий перепад давления на фильтре
mb_AI_init(UVI_UVI_mb_AI_Settings.dPf,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,23);
//Текущее давление на фильтре
mb_AI_init(UVI_UVI_mb_AI_Settings.Pf,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,24);
//Текущее значение давления
mb_AI_init(UVI_UVI_mb_AI_Settings.P,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,25);
//Текущий максимальный перепад давления на фильтре
mb_AI_init(UVI_UVI_mb_AI_Settings.dPf_max,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,26);
//Коэф-т поправки расхода по каналам
mb_AI_init(UVI_UVI_mb_AI_Settings.Kq,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,30);
//Текущая плотность ингибитора
mb_AI_init(UVI_UVI_mb_AI_Settings.Den,10.0,2000.0,-49.7,2059.7,-109.4,2119.4,3,0.0,0.0,0.0,31);
//Максимальный расход канал 1
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch1,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,32);
//Максимальный расход канал 2
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch2,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,33);
//Максимальный расход канал 3
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch3,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,34);
//Максимальный расход канал 4
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch4,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,35);
//Максимальный расход канал 5
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch5,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,36);
//Максимальный расход канал 6
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch6,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,37);
//Максимальный расход канал 7
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch7,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,38);
//Максимальный расход канал 8
mb_AI_init(UVI_UVI_mb_AI_Settings.Qmax_ch8,10.0,10000.0,-289.7,10299.7,-589.4,10599.4,3,0.0,0.0,0.0,39);
//Требуемый расход канал 1
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_1,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,40);
//Требуемый расход канал 2
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_2,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,41);
//Требуемый расход канал 3
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_3,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,42);
//Требуемый расход канал 4
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_4,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,43);
//Требуемый расход канал 5
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_5,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,44);
//Требуемый расход канал 6
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_6,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,45);
//Требуемый расход канал 7
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_7,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,46);
//Требуемый расход канал 8
mb_AI_init(UVI_UVI_mb_AI_Settings.Qdem_8,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,3,0.0,0.0,0.0,47);
//Режим работы каналов
mb_AI_init(UVI_UVI_mb_AI_Settings.Mode_ch,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,9,0.0,0.0,0.0,48);
//Расходомер включен/выключен
mb_AI_init(UVI_UVI_mb_AI_Settings.Flow_On,0.0,10000.0,-300.0,10300.0,-600.0,10600.0,9,0.0,0.0,0.0,49);
//Максиимальный перепад давление на фильтре
mb_AI_init(UVI_UVI_mb_AI_Settings.dP_max,0.0,100.0,-3.0,103.0,-6.0,106.0,3,0.0,0.0,0.0,50);
//Максимальное значение температуры внутри модуля
mb_AI_init(UVI_UVI_mb_AI_Settings.T_max,-100.0,200.0,-109.0,209.0,-118.0,218.0,3,0.0,0.0,0.0,51);
//Минимальное значение напряжения питания
mb_AI_init(UVI_UVI_mb_AI_Settings.U_min,0.0,30.0,-0.9,30.9,-1.8,31.8,3,0.0,0.0,0.0,52);
//Максимальное значение напряжения питания
mb_AI_init(UVI_UVI_mb_AI_Settings.U_max,0.0,30.0,-0.9,30.9,-1.8,31.8,3,0.0,0.0,0.0,53);
//Конец сгенерированного кода
end_if;
//Начало сгенерированного кода AI_Processing
//Измеренный мгновенный расход ингибитора канал 1
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_1,UVI_UVI_mb_AI_Settings.Qi_1,UVI_UVI_mb_AI_FromHMI.Qi_1,UVI_UVI_mb_AI_ToHMI.Qi_1);
//Измеренный мгновенный расход ингибитора канал 2
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_2,UVI_UVI_mb_AI_Settings.Qi_2,UVI_UVI_mb_AI_FromHMI.Qi_2,UVI_UVI_mb_AI_ToHMI.Qi_2);
//Измеренный мгновенный расход ингибитора канал 3
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_3,UVI_UVI_mb_AI_Settings.Qi_3,UVI_UVI_mb_AI_FromHMI.Qi_3,UVI_UVI_mb_AI_ToHMI.Qi_3);
//Измеренный мгновенный расход ингибитора канал 4
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_4,UVI_UVI_mb_AI_Settings.Qi_4,UVI_UVI_mb_AI_FromHMI.Qi_4,UVI_UVI_mb_AI_ToHMI.Qi_4);
//Измеренный мгновенный расход ингибитора канал 5
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_5,UVI_UVI_mb_AI_Settings.Qi_5,UVI_UVI_mb_AI_FromHMI.Qi_5,UVI_UVI_mb_AI_ToHMI.Qi_5);
//Измеренный мгновенный расход ингибитора канал 6
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_6,UVI_UVI_mb_AI_Settings.Qi_6,UVI_UVI_mb_AI_FromHMI.Qi_6,UVI_UVI_mb_AI_ToHMI.Qi_6);
//Измеренный мгновенный расход ингибитора канал 7
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_7,UVI_UVI_mb_AI_Settings.Qi_7,UVI_UVI_mb_AI_FromHMI.Qi_7,UVI_UVI_mb_AI_ToHMI.Qi_7);
//Измеренный мгновенный расход ингибитора канал 8
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_8,UVI_UVI_mb_AI_Settings.Qi_8,UVI_UVI_mb_AI_FromHMI.Qi_8,UVI_UVI_mb_AI_ToHMI.Qi_8);
//Расчитанный мгновенный расход ингибитора канал 1
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_1,UVI_UVI_mb_AI_Settings.Qr_1,UVI_UVI_mb_AI_FromHMI.Qr_1,UVI_UVI_mb_AI_ToHMI.Qr_1);
//Расчитанный мгновенный расход ингибитора канал 2
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_2,UVI_UVI_mb_AI_Settings.Qr_2,UVI_UVI_mb_AI_FromHMI.Qr_2,UVI_UVI_mb_AI_ToHMI.Qr_2);
//Расчитанный мгновенный расход ингибитора канал 3
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_3,UVI_UVI_mb_AI_Settings.Qr_3,UVI_UVI_mb_AI_FromHMI.Qr_3,UVI_UVI_mb_AI_ToHMI.Qr_3);
//Расчитанный мгновенный расход ингибитора канал 4
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_4,UVI_UVI_mb_AI_Settings.Qr_4,UVI_UVI_mb_AI_FromHMI.Qr_4,UVI_UVI_mb_AI_ToHMI.Qr_4);
//Расчитанный мгновенный расход ингибитора канал 5
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_5,UVI_UVI_mb_AI_Settings.Qr_5,UVI_UVI_mb_AI_FromHMI.Qr_5,UVI_UVI_mb_AI_ToHMI.Qr_5);
//Расчитанный мгновенный расход ингибитора канал 6
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_6,UVI_UVI_mb_AI_Settings.Qr_6,UVI_UVI_mb_AI_FromHMI.Qr_6,UVI_UVI_mb_AI_ToHMI.Qr_6);
//Расчитанный мгновенный расход ингибитора канал 7
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_7,UVI_UVI_mb_AI_Settings.Qr_7,UVI_UVI_mb_AI_FromHMI.Qr_7,UVI_UVI_mb_AI_ToHMI.Qr_7);
//Расчитанный мгновенный расход ингибитора канал 8
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qr_8,UVI_UVI_mb_AI_Settings.Qr_8,UVI_UVI_mb_AI_FromHMI.Qr_8,UVI_UVI_mb_AI_ToHMI.Qr_8);
//Мгновенный измеренный расход ингибитора суммарно по каналам
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qi_sum,UVI_UVI_mb_AI_Settings.Qi_sum,UVI_UVI_mb_AI_FromHMI.Qi_sum,UVI_UVI_mb_AI_ToHMI.Qi_sum);
//Температура внутри корпуса
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Tk,UVI_UVI_mb_AI_Settings.Tk,UVI_UVI_mb_AI_FromHMI.Tk,UVI_UVI_mb_AI_ToHMI.Tk);
//Напряжение питания
mb_AI_Processing(UVI_UVI_mb_AI_DRV.U,UVI_UVI_mb_AI_Settings.U,UVI_UVI_mb_AI_FromHMI.U,UVI_UVI_mb_AI_ToHMI.U);
//Мгновенный расход расходомера
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Q,UVI_UVI_mb_AI_Settings.Q,UVI_UVI_mb_AI_FromHMI.Q,UVI_UVI_mb_AI_ToHMI.Q);
//Текущий перепад давления на фильтре
mb_AI_Processing(UVI_UVI_mb_AI_DRV.dPf,UVI_UVI_mb_AI_Settings.dPf,UVI_UVI_mb_AI_FromHMI.dPf,UVI_UVI_mb_AI_ToHMI.dPf);
//Текущее давление на фильтре
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Pf,UVI_UVI_mb_AI_Settings.Pf,UVI_UVI_mb_AI_FromHMI.Pf,UVI_UVI_mb_AI_ToHMI.Pf);
//Текущее значение давления
mb_AI_Processing(UVI_UVI_mb_AI_DRV.P,UVI_UVI_mb_AI_Settings.P,UVI_UVI_mb_AI_FromHMI.P,UVI_UVI_mb_AI_ToHMI.P);
//Текущий максимальный перепад давления на фильтре
mb_AI_Processing(UVI_UVI_mb_AI_DRV.dPf_max,UVI_UVI_mb_AI_Settings.dPf_max,UVI_UVI_mb_AI_FromHMI.dPf_max,UVI_UVI_mb_AI_ToHMI.dPf_max);
//Коэф-т поправки расхода по каналам
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Kq,UVI_UVI_mb_AI_Settings.Kq,UVI_UVI_mb_AI_FromHMI.Kq,UVI_UVI_mb_AI_ToHMI.Kq);
//Текущая плотность ингибитора
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Den,UVI_UVI_mb_AI_Settings.Den,UVI_UVI_mb_AI_FromHMI.Den,UVI_UVI_mb_AI_ToHMI.Den);
//Максимальный расход канал 1
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch1,UVI_UVI_mb_AI_Settings.Qmax_ch1,UVI_UVI_mb_AI_FromHMI.Qmax_ch1,UVI_UVI_mb_AI_ToHMI.Qmax_ch1);
//Максимальный расход канал 2
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch2,UVI_UVI_mb_AI_Settings.Qmax_ch2,UVI_UVI_mb_AI_FromHMI.Qmax_ch2,UVI_UVI_mb_AI_ToHMI.Qmax_ch2);
//Максимальный расход канал 3
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch3,UVI_UVI_mb_AI_Settings.Qmax_ch3,UVI_UVI_mb_AI_FromHMI.Qmax_ch3,UVI_UVI_mb_AI_ToHMI.Qmax_ch3);
//Максимальный расход канал 4
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch4,UVI_UVI_mb_AI_Settings.Qmax_ch4,UVI_UVI_mb_AI_FromHMI.Qmax_ch4,UVI_UVI_mb_AI_ToHMI.Qmax_ch4);
//Максимальный расход канал 5
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch5,UVI_UVI_mb_AI_Settings.Qmax_ch5,UVI_UVI_mb_AI_FromHMI.Qmax_ch5,UVI_UVI_mb_AI_ToHMI.Qmax_ch5);
//Максимальный расход канал 6
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch6,UVI_UVI_mb_AI_Settings.Qmax_ch6,UVI_UVI_mb_AI_FromHMI.Qmax_ch6,UVI_UVI_mb_AI_ToHMI.Qmax_ch6);
//Максимальный расход канал 7
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch7,UVI_UVI_mb_AI_Settings.Qmax_ch7,UVI_UVI_mb_AI_FromHMI.Qmax_ch7,UVI_UVI_mb_AI_ToHMI.Qmax_ch7);
//Максимальный расход канал 8
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qmax_ch8,UVI_UVI_mb_AI_Settings.Qmax_ch8,UVI_UVI_mb_AI_FromHMI.Qmax_ch8,UVI_UVI_mb_AI_ToHMI.Qmax_ch8);
//Требуемый расход канал 1
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_1,UVI_UVI_mb_AI_Settings.Qdem_1,UVI_UVI_mb_AI_FromHMI.Qdem_1,UVI_UVI_mb_AI_ToHMI.Qdem_1);
//Требуемый расход канал 2
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_2,UVI_UVI_mb_AI_Settings.Qdem_2,UVI_UVI_mb_AI_FromHMI.Qdem_2,UVI_UVI_mb_AI_ToHMI.Qdem_2);
//Требуемый расход канал 3
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_3,UVI_UVI_mb_AI_Settings.Qdem_3,UVI_UVI_mb_AI_FromHMI.Qdem_3,UVI_UVI_mb_AI_ToHMI.Qdem_3);
//Требуемый расход канал 4
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_4,UVI_UVI_mb_AI_Settings.Qdem_4,UVI_UVI_mb_AI_FromHMI.Qdem_4,UVI_UVI_mb_AI_ToHMI.Qdem_4);
//Требуемый расход канал 5
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_5,UVI_UVI_mb_AI_Settings.Qdem_5,UVI_UVI_mb_AI_FromHMI.Qdem_5,UVI_UVI_mb_AI_ToHMI.Qdem_5);
//Требуемый расход канал 6
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_6,UVI_UVI_mb_AI_Settings.Qdem_6,UVI_UVI_mb_AI_FromHMI.Qdem_6,UVI_UVI_mb_AI_ToHMI.Qdem_6);
//Требуемый расход канал 7
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_7,UVI_UVI_mb_AI_Settings.Qdem_7,UVI_UVI_mb_AI_FromHMI.Qdem_7,UVI_UVI_mb_AI_ToHMI.Qdem_7);
//Требуемый расход канал 8
mb_AI_Processing(UVI_UVI_mb_AI_DRV.Qdem_8,UVI_UVI_mb_AI_Settings.Qdem_8,UVI_UVI_mb_AI_FromHMI.Qdem_8,UVI_UVI_mb_AI_ToHMI.Qdem_8);
//Режим работы каналов
mb_AI_Processing(UINT_TO_REAL(UVI_UVI_mb_AI_DRV.Mode_ch),UVI_UVI_mb_AI_Settings.Mode_ch,UVI_UVI_mb_AI_FromHMI.Mode_ch,UVI_UVI_mb_AI_ToHMI.Mode_ch);
//Расходомер включен/выключен
mb_AI_Processing(UINT_TO_REAL(UVI_UVI_mb_AI_DRV.Flow_On),UVI_UVI_mb_AI_Settings.Flow_On,UVI_UVI_mb_AI_FromHMI.Flow_On,UVI_UVI_mb_AI_ToHMI.Flow_On);
//Максиимальный перепад давление на фильтре
mb_AI_Processing(UVI_UVI_mb_AI_DRV.dP_max,UVI_UVI_mb_AI_Settings.dP_max,UVI_UVI_mb_AI_FromHMI.dP_max,UVI_UVI_mb_AI_ToHMI.dP_max);
//Максимальное значение температуры внутри модуля
mb_AI_Processing(UVI_UVI_mb_AI_DRV.T_max,UVI_UVI_mb_AI_Settings.T_max,UVI_UVI_mb_AI_FromHMI.T_max,UVI_UVI_mb_AI_ToHMI.T_max);
//Минимальное значение напряжения питания
mb_AI_Processing(UVI_UVI_mb_AI_DRV.U_min,UVI_UVI_mb_AI_Settings.U_min,UVI_UVI_mb_AI_FromHMI.U_min,UVI_UVI_mb_AI_ToHMI.U_min);
//Максимальное значение напряжения питания
mb_AI_Processing(UVI_UVI_mb_AI_DRV.U_max,UVI_UVI_mb_AI_Settings.U_max,UVI_UVI_mb_AI_FromHMI.U_max,UVI_UVI_mb_AI_ToHMI.U_max);
//Конец сгенерированного кода
]]></ST>
                    </FunctionBlock>
                </Folder>
                <Folder Name="DI" Comment="" Data="" UUID="J2GWW3FZGJOELBKHKHLUJJW43U">
                    <Function UUID="D6N2BW6DIOEYOLKWA6T6SZ7QLE" Name="UVI_UVI_DI_Permit" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables>
                            <Variable UUID="TGLRFATQ24XUPFHW373KXU5CZ4" Name="tmpPermit" Type="BOOL" Usage="internal" />
                        </Variables>
                        <ST><![CDATA[//--- Групповое разрешение ДУ ---
tmpPermit := true;
//Начало сгенерированного кода DI_Permit
UVI_UVI_mb_DI_ToHMI.Vlv_on_1.manual := tmpPermit; //Клапан 1 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_2.manual := tmpPermit; //Клапан 2 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_3.manual := tmpPermit; //Клапан 3 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_4.manual := tmpPermit; //Клапан 4 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_5.manual := tmpPermit; //Клапан 5 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_6.manual := tmpPermit; //Клапан 6 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_7.manual := tmpPermit; //Клапан 7 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_on_8.manual := tmpPermit; //Клапан 8 открыт;
UVI_UVI_mb_DI_ToHMI.Vlv_1_ok.manual := tmpPermit; //Цепь клапана 1 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_1_kz.manual := tmpPermit; //КЗ цепи клапана 1;
UVI_UVI_mb_DI_ToHMI.Vlv_1_brk.manual := tmpPermit; //Обрыв цепи клапан 1;
UVI_UVI_mb_DI_ToHMI.Vlv_2_ok.manual := tmpPermit; //Цепь клапана 2 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_2_kz.manual := tmpPermit; //КЗ цепи клапана 2;
UVI_UVI_mb_DI_ToHMI.Vlv_2_brk.manual := tmpPermit; //Обрыв цепи клапан 2;
UVI_UVI_mb_DI_ToHMI.Vlv_3_ok.manual := tmpPermit; //Цепь клапана 3 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_3_kz.manual := tmpPermit; //КЗ цепи клапана 3;
UVI_UVI_mb_DI_ToHMI.Vlv_3_brk.manual := tmpPermit; //Обрыв цепи клапан 3;
UVI_UVI_mb_DI_ToHMI.Vlv_4_ok.manual := tmpPermit; //Цепь клапана 4 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_4_kz.manual := tmpPermit; //КЗ цепи клапана 4;
UVI_UVI_mb_DI_ToHMI.Vlv_4_brk.manual := tmpPermit; //Обрыв цепи клапан 4;
UVI_UVI_mb_DI_ToHMI.Vlv_5_ok.manual := tmpPermit; //Цепь клапана 5 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_5_kz.manual := tmpPermit; //КЗ цепи клапана 5;
UVI_UVI_mb_DI_ToHMI.Vlv_5_brk.manual := tmpPermit; //Обрыв цепи клапан 5;
UVI_UVI_mb_DI_ToHMI.Vlv_6_ok.manual := tmpPermit; //Цепь клапана 6 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_6_kz.manual := tmpPermit; //КЗ цепи клапана 6;
UVI_UVI_mb_DI_ToHMI.Vlv_6_brk.manual := tmpPermit; //Обрыв цепи клапан 6;
UVI_UVI_mb_DI_ToHMI.Vlv_7_ok.manual := tmpPermit; //Цепь клапана 7 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_7_kz.manual := tmpPermit; //КЗ цепи клапана 7;
UVI_UVI_mb_DI_ToHMI.Vlv_7_brk.manual := tmpPermit; //Обрыв цепи клапан 7;
UVI_UVI_mb_DI_ToHMI.Vlv_8_ok.manual := tmpPermit; //Цепь клапана 8 в норме;
UVI_UVI_mb_DI_ToHMI.Vlv_8_kz.manual := tmpPermit; //КЗ цепи клапана 8;
UVI_UVI_mb_DI_ToHMI.Vlv_8_brk.manual := tmpPermit; //Обрыв цепи клапан 8;
UVI_UVI_mb_DI_ToHMI.U_low.manual := tmpPermit; //Флаг "Напряжение меньше допустимого";
UVI_UVI_mb_DI_ToHMI.T_GZ.manual := tmpPermit; //Флаг "Температура внутри корпуса больше заданной";
UVI_UVI_mb_DI_ToHMI.Den_flt.manual := tmpPermit; //Флаг неисправность датчика плотности;
UVI_UVI_mb_DI_ToHMI.dP_flt.manual := tmpPermit; //Флаг неисправность датчика перепада давления на фильтре;
UVI_UVI_mb_DI_ToHMI.dP_GZ.manual := tmpPermit; //Флаг "Перепад давления на фильтре больше заданного";
UVI_UVI_mb_DI_ToHMI.Flow_flt.manual := tmpPermit; //Флаг неисправности расходомера;
UVI_UVI_mb_DI_ToHMI.U_hi.manual := tmpPermit; //Флаг "Напряжение больше допустимого";
UVI_UVI_mb_DI_ToHMI.deltaQ_flt.manual := tmpPermit; //Флаг "Расхождение суммарных расходов более заданной ошибки";
UVI_UVI_mb_DI_ToHMI.Pin_low.manual := tmpPermit; //Флаг "Давление на входе меньше допустимого";
UVI_UVI_mb_DI_ToHMI.Pin_flt.manual := tmpPermit; //Флаг "Неисправность датчика входного давления";
UVI_UVI_mb_DI_ToHMI.Leak.manual := tmpPermit; //Флаг "Протечка по байпасам";
UVI_UVI_mb_DI_ToHMI.Filter_flt.manual := tmpPermit; //Флаг "Аварийное засорение фильтра";
UVI_UVI_mb_DI_ToHMI.Fl_sens_1_ok.manual := tmpPermit; //Флаг Цепь датчика 1 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_1_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 1;
UVI_UVI_mb_DI_ToHMI.Fl_sens_1_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 1;
UVI_UVI_mb_DI_ToHMI.Fl_sens_2_ok.manual := tmpPermit; //Флаг Цепь датчика 2 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_2_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 2;
UVI_UVI_mb_DI_ToHMI.Fl_sens_2_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 2;
UVI_UVI_mb_DI_ToHMI.Fl_sens_3_ok.manual := tmpPermit; //Флаг Цепь датчика 3 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_3_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 3;
UVI_UVI_mb_DI_ToHMI.Fl_sens_3_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 3;
UVI_UVI_mb_DI_ToHMI.Fl_sens_4_ok.manual := tmpPermit; //Флаг Цепь датчика 4 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_4_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 4;
UVI_UVI_mb_DI_ToHMI.Fl_sens_4_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 4;
UVI_UVI_mb_DI_ToHMI.Fl_sens_5_ok.manual := tmpPermit; //Флаг Цепь датчика 5 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_5_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 5;
UVI_UVI_mb_DI_ToHMI.Fl_sens_5_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 5;
UVI_UVI_mb_DI_ToHMI.Fl_sens_6_ok.manual := tmpPermit; //Флаг Цепь датчика 6 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_6_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 6;
UVI_UVI_mb_DI_ToHMI.Fl_sens_6_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 6;
UVI_UVI_mb_DI_ToHMI.Fl_sens_7_ok.manual := tmpPermit; //Флаг Цепь датчика 7 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_7_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 7;
UVI_UVI_mb_DI_ToHMI.Fl_sens_7_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 7;
UVI_UVI_mb_DI_ToHMI.Fl_sens_8_ok.manual := tmpPermit; //Флаг Цепь датчика 8 в норме;
UVI_UVI_mb_DI_ToHMI.Fl_sens_8_kz.manual := tmpPermit; //Флаг  КЗ цепи датчика 8;
UVI_UVI_mb_DI_ToHMI.Fl_sens_8_brk.manual := tmpPermit; //Флаг Обрыв цепи датчика 8;
UVI_UVI_mb_DI_ToHMI.Fl_ch_1_ackn.manual := tmpPermit; //Флаг неиспраности канала 1 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_1_clodge.manual := tmpPermit; //Флаг засорен канал 1;
UVI_UVI_mb_DI_ToHMI.Fl_ch_1_leak.manual := tmpPermit; //Флаг протечка канал 1;
UVI_UVI_mb_DI_ToHMI.Fl_ch_2_ackn.manual := tmpPermit; //Флаг неиспраности канала 2 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_2_clodge.manual := tmpPermit; //Флаг засорен канал 2;
UVI_UVI_mb_DI_ToHMI.Fl_ch_2_leak.manual := tmpPermit; //Флаг протечка канал 2;
UVI_UVI_mb_DI_ToHMI.Fl_ch_3_ackn.manual := tmpPermit; //Флаг неиспраности канала 3 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_3_clodge.manual := tmpPermit; //Флаг засорен канал 3;
UVI_UVI_mb_DI_ToHMI.Fl_ch_3_leak.manual := tmpPermit; //Флаг протечка канал 3;
UVI_UVI_mb_DI_ToHMI.Fl_ch_4_ackn.manual := tmpPermit; //Флаг неиспраности канала 4 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_4_clodge.manual := tmpPermit; //Флаг засорен канал 4;
UVI_UVI_mb_DI_ToHMI.Fl_ch_4_leak.manual := tmpPermit; //Флаг протечка канал 4;
UVI_UVI_mb_DI_ToHMI.Fl_ch_5_ackn.manual := tmpPermit; //Флаг неиспраности канала 5 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_5_clodge.manual := tmpPermit; //Флаг засорен канал 5;
UVI_UVI_mb_DI_ToHMI.Fl_ch_5_leak.manual := tmpPermit; //Флаг протечка канал 5;
UVI_UVI_mb_DI_ToHMI.Fl_ch_6_ackn.manual := tmpPermit; //Флаг неиспраности канала 6 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_6_clodge.manual := tmpPermit; //Флаг засорен канал 6;
UVI_UVI_mb_DI_ToHMI.Fl_ch_6_leak.manual := tmpPermit; //Флаг протечка канал 6;
UVI_UVI_mb_DI_ToHMI.Fl_ch_7_ackn.manual := tmpPermit; //Флаг неиспраности канала 7 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_7_clodge.manual := tmpPermit; //Флаг засорен канал 7;
UVI_UVI_mb_DI_ToHMI.Fl_ch_7_leak.manual := tmpPermit; //Флаг протечка канал 7;
UVI_UVI_mb_DI_ToHMI.Fl_ch_8_ackn.manual := tmpPermit; //Флаг неиспраности канала 8 сброшен;
UVI_UVI_mb_DI_ToHMI.Fl_ch_8_clodge.manual := tmpPermit; //Флаг засорен канал 8;
UVI_UVI_mb_DI_ToHMI.Fl_ch_8_leak.manual := tmpPermit; //Флаг протечка канал 8;
UVI_UVI_mb_DI_ToHMI.Ch_on_1.manual := tmpPermit; //Канал 1 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_2.manual := tmpPermit; //Канал 2 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_3.manual := tmpPermit; //Канал 3 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_4.manual := tmpPermit; //Канал 4 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_5.manual := tmpPermit; //Канал 5 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_6.manual := tmpPermit; //Канал 6 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_7.manual := tmpPermit; //Канал 7 в работе;
UVI_UVI_mb_DI_ToHMI.Ch_on_8.manual := tmpPermit; //Канал 8 в работе;
//Конец сгенерированного кода
]]></ST>
                    </Function>
                    <Function UUID="RLWLATFIJANB6TLDRC6ATURLFU" Name="UVI_UVI_mb_DI_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables />
                        <ST><![CDATA[//-------- Обработка дискретных входов полученных по сети --------------
//Начало сгенерированного кода DI_Processing
//Клапан 1 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_1,UVI_UVI_mb_DI_FromHMI.Vlv_on_1,UVI_UVI_mb_DI_ToHMI.Vlv_on_1,UVI_UVI_mb_DI.Vlv_on_1);
//Клапан 2 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_2,UVI_UVI_mb_DI_FromHMI.Vlv_on_2,UVI_UVI_mb_DI_ToHMI.Vlv_on_2,UVI_UVI_mb_DI.Vlv_on_2);
//Клапан 3 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_3,UVI_UVI_mb_DI_FromHMI.Vlv_on_3,UVI_UVI_mb_DI_ToHMI.Vlv_on_3,UVI_UVI_mb_DI.Vlv_on_3);
//Клапан 4 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_4,UVI_UVI_mb_DI_FromHMI.Vlv_on_4,UVI_UVI_mb_DI_ToHMI.Vlv_on_4,UVI_UVI_mb_DI.Vlv_on_4);
//Клапан 5 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_5,UVI_UVI_mb_DI_FromHMI.Vlv_on_5,UVI_UVI_mb_DI_ToHMI.Vlv_on_5,UVI_UVI_mb_DI.Vlv_on_5);
//Клапан 6 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_6,UVI_UVI_mb_DI_FromHMI.Vlv_on_6,UVI_UVI_mb_DI_ToHMI.Vlv_on_6,UVI_UVI_mb_DI.Vlv_on_6);
//Клапан 7 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_7,UVI_UVI_mb_DI_FromHMI.Vlv_on_7,UVI_UVI_mb_DI_ToHMI.Vlv_on_7,UVI_UVI_mb_DI.Vlv_on_7);
//Клапан 8 открыт
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_on_8,UVI_UVI_mb_DI_FromHMI.Vlv_on_8,UVI_UVI_mb_DI_ToHMI.Vlv_on_8,UVI_UVI_mb_DI.Vlv_on_8);
//Цепь клапана 1 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_1_ok,UVI_UVI_mb_DI_FromHMI.Vlv_1_ok,UVI_UVI_mb_DI_ToHMI.Vlv_1_ok,UVI_UVI_mb_DI.Vlv_1_ok);
//КЗ цепи клапана 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_1_kz,UVI_UVI_mb_DI_FromHMI.Vlv_1_kz,UVI_UVI_mb_DI_ToHMI.Vlv_1_kz,UVI_UVI_mb_DI.Vlv_1_kz);
//Обрыв цепи клапан 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_1_brk,UVI_UVI_mb_DI_FromHMI.Vlv_1_brk,UVI_UVI_mb_DI_ToHMI.Vlv_1_brk,UVI_UVI_mb_DI.Vlv_1_brk);
//Цепь клапана 2 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_2_ok,UVI_UVI_mb_DI_FromHMI.Vlv_2_ok,UVI_UVI_mb_DI_ToHMI.Vlv_2_ok,UVI_UVI_mb_DI.Vlv_2_ok);
//КЗ цепи клапана 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_2_kz,UVI_UVI_mb_DI_FromHMI.Vlv_2_kz,UVI_UVI_mb_DI_ToHMI.Vlv_2_kz,UVI_UVI_mb_DI.Vlv_2_kz);
//Обрыв цепи клапан 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_2_brk,UVI_UVI_mb_DI_FromHMI.Vlv_2_brk,UVI_UVI_mb_DI_ToHMI.Vlv_2_brk,UVI_UVI_mb_DI.Vlv_2_brk);
//Цепь клапана 3 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_3_ok,UVI_UVI_mb_DI_FromHMI.Vlv_3_ok,UVI_UVI_mb_DI_ToHMI.Vlv_3_ok,UVI_UVI_mb_DI.Vlv_3_ok);
//КЗ цепи клапана 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_3_kz,UVI_UVI_mb_DI_FromHMI.Vlv_3_kz,UVI_UVI_mb_DI_ToHMI.Vlv_3_kz,UVI_UVI_mb_DI.Vlv_3_kz);
//Обрыв цепи клапан 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_3_brk,UVI_UVI_mb_DI_FromHMI.Vlv_3_brk,UVI_UVI_mb_DI_ToHMI.Vlv_3_brk,UVI_UVI_mb_DI.Vlv_3_brk);
//Цепь клапана 4 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_4_ok,UVI_UVI_mb_DI_FromHMI.Vlv_4_ok,UVI_UVI_mb_DI_ToHMI.Vlv_4_ok,UVI_UVI_mb_DI.Vlv_4_ok);
//КЗ цепи клапана 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_4_kz,UVI_UVI_mb_DI_FromHMI.Vlv_4_kz,UVI_UVI_mb_DI_ToHMI.Vlv_4_kz,UVI_UVI_mb_DI.Vlv_4_kz);
//Обрыв цепи клапан 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_4_brk,UVI_UVI_mb_DI_FromHMI.Vlv_4_brk,UVI_UVI_mb_DI_ToHMI.Vlv_4_brk,UVI_UVI_mb_DI.Vlv_4_brk);
//Цепь клапана 5 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_5_ok,UVI_UVI_mb_DI_FromHMI.Vlv_5_ok,UVI_UVI_mb_DI_ToHMI.Vlv_5_ok,UVI_UVI_mb_DI.Vlv_5_ok);
//КЗ цепи клапана 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_5_kz,UVI_UVI_mb_DI_FromHMI.Vlv_5_kz,UVI_UVI_mb_DI_ToHMI.Vlv_5_kz,UVI_UVI_mb_DI.Vlv_5_kz);
//Обрыв цепи клапан 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_5_brk,UVI_UVI_mb_DI_FromHMI.Vlv_5_brk,UVI_UVI_mb_DI_ToHMI.Vlv_5_brk,UVI_UVI_mb_DI.Vlv_5_brk);
//Цепь клапана 6 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_6_ok,UVI_UVI_mb_DI_FromHMI.Vlv_6_ok,UVI_UVI_mb_DI_ToHMI.Vlv_6_ok,UVI_UVI_mb_DI.Vlv_6_ok);
//КЗ цепи клапана 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_6_kz,UVI_UVI_mb_DI_FromHMI.Vlv_6_kz,UVI_UVI_mb_DI_ToHMI.Vlv_6_kz,UVI_UVI_mb_DI.Vlv_6_kz);
//Обрыв цепи клапан 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_6_brk,UVI_UVI_mb_DI_FromHMI.Vlv_6_brk,UVI_UVI_mb_DI_ToHMI.Vlv_6_brk,UVI_UVI_mb_DI.Vlv_6_brk);
//Цепь клапана 7 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_7_ok,UVI_UVI_mb_DI_FromHMI.Vlv_7_ok,UVI_UVI_mb_DI_ToHMI.Vlv_7_ok,UVI_UVI_mb_DI.Vlv_7_ok);
//КЗ цепи клапана 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_7_kz,UVI_UVI_mb_DI_FromHMI.Vlv_7_kz,UVI_UVI_mb_DI_ToHMI.Vlv_7_kz,UVI_UVI_mb_DI.Vlv_7_kz);
//Обрыв цепи клапан 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_7_brk,UVI_UVI_mb_DI_FromHMI.Vlv_7_brk,UVI_UVI_mb_DI_ToHMI.Vlv_7_brk,UVI_UVI_mb_DI.Vlv_7_brk);
//Цепь клапана 8 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_8_ok,UVI_UVI_mb_DI_FromHMI.Vlv_8_ok,UVI_UVI_mb_DI_ToHMI.Vlv_8_ok,UVI_UVI_mb_DI.Vlv_8_ok);
//КЗ цепи клапана 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_8_kz,UVI_UVI_mb_DI_FromHMI.Vlv_8_kz,UVI_UVI_mb_DI_ToHMI.Vlv_8_kz,UVI_UVI_mb_DI.Vlv_8_kz);
//Обрыв цепи клапан 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Vlv_8_brk,UVI_UVI_mb_DI_FromHMI.Vlv_8_brk,UVI_UVI_mb_DI_ToHMI.Vlv_8_brk,UVI_UVI_mb_DI.Vlv_8_brk);
//Флаг "Напряжение меньше допустимого"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.U_low,UVI_UVI_mb_DI_FromHMI.U_low,UVI_UVI_mb_DI_ToHMI.U_low,UVI_UVI_mb_DI.U_low);
//Флаг "Температура внутри корпуса больше заданной"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.T_GZ,UVI_UVI_mb_DI_FromHMI.T_GZ,UVI_UVI_mb_DI_ToHMI.T_GZ,UVI_UVI_mb_DI.T_GZ);
//Флаг неисправность датчика плотности
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Den_flt,UVI_UVI_mb_DI_FromHMI.Den_flt,UVI_UVI_mb_DI_ToHMI.Den_flt,UVI_UVI_mb_DI.Den_flt);
//Флаг неисправность датчика перепада давления на фильтре
mb_DI_Processing(UVI_UVI_mb_DI_DRV.dP_flt,UVI_UVI_mb_DI_FromHMI.dP_flt,UVI_UVI_mb_DI_ToHMI.dP_flt,UVI_UVI_mb_DI.dP_flt);
//Флаг "Перепад давления на фильтре больше заданного"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.dP_GZ,UVI_UVI_mb_DI_FromHMI.dP_GZ,UVI_UVI_mb_DI_ToHMI.dP_GZ,UVI_UVI_mb_DI.dP_GZ);
//Флаг неисправности расходомера
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Flow_flt,UVI_UVI_mb_DI_FromHMI.Flow_flt,UVI_UVI_mb_DI_ToHMI.Flow_flt,UVI_UVI_mb_DI.Flow_flt);
//Флаг "Напряжение больше допустимого"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.U_hi,UVI_UVI_mb_DI_FromHMI.U_hi,UVI_UVI_mb_DI_ToHMI.U_hi,UVI_UVI_mb_DI.U_hi);
//Флаг "Расхождение суммарных расходов более заданной ошибки"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.deltaQ_flt,UVI_UVI_mb_DI_FromHMI.deltaQ_flt,UVI_UVI_mb_DI_ToHMI.deltaQ_flt,UVI_UVI_mb_DI.deltaQ_flt);
//Флаг "Давление на входе меньше допустимого"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Pin_low,UVI_UVI_mb_DI_FromHMI.Pin_low,UVI_UVI_mb_DI_ToHMI.Pin_low,UVI_UVI_mb_DI.Pin_low);
//Флаг "Неисправность датчика входного давления"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Pin_flt,UVI_UVI_mb_DI_FromHMI.Pin_flt,UVI_UVI_mb_DI_ToHMI.Pin_flt,UVI_UVI_mb_DI.Pin_flt);
//Флаг "Протечка по байпасам"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Leak,UVI_UVI_mb_DI_FromHMI.Leak,UVI_UVI_mb_DI_ToHMI.Leak,UVI_UVI_mb_DI.Leak);
//Флаг "Аварийное засорение фильтра"
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Filter_flt,UVI_UVI_mb_DI_FromHMI.Filter_flt,UVI_UVI_mb_DI_ToHMI.Filter_flt,UVI_UVI_mb_DI.Filter_flt);
//Флаг Цепь датчика 1 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_1_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_1_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_1_ok,UVI_UVI_mb_DI.Fl_sens_1_ok);
//Флаг  КЗ цепи датчика 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_1_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_1_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_1_kz,UVI_UVI_mb_DI.Fl_sens_1_kz);
//Флаг Обрыв цепи датчика 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_1_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_1_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_1_brk,UVI_UVI_mb_DI.Fl_sens_1_brk);
//Флаг Цепь датчика 2 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_2_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_2_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_2_ok,UVI_UVI_mb_DI.Fl_sens_2_ok);
//Флаг  КЗ цепи датчика 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_2_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_2_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_2_kz,UVI_UVI_mb_DI.Fl_sens_2_kz);
//Флаг Обрыв цепи датчика 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_2_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_2_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_2_brk,UVI_UVI_mb_DI.Fl_sens_2_brk);
//Флаг Цепь датчика 3 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_3_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_3_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_3_ok,UVI_UVI_mb_DI.Fl_sens_3_ok);
//Флаг  КЗ цепи датчика 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_3_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_3_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_3_kz,UVI_UVI_mb_DI.Fl_sens_3_kz);
//Флаг Обрыв цепи датчика 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_3_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_3_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_3_brk,UVI_UVI_mb_DI.Fl_sens_3_brk);
//Флаг Цепь датчика 4 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_4_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_4_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_4_ok,UVI_UVI_mb_DI.Fl_sens_4_ok);
//Флаг  КЗ цепи датчика 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_4_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_4_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_4_kz,UVI_UVI_mb_DI.Fl_sens_4_kz);
//Флаг Обрыв цепи датчика 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_4_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_4_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_4_brk,UVI_UVI_mb_DI.Fl_sens_4_brk);
//Флаг Цепь датчика 5 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_5_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_5_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_5_ok,UVI_UVI_mb_DI.Fl_sens_5_ok);
//Флаг  КЗ цепи датчика 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_5_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_5_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_5_kz,UVI_UVI_mb_DI.Fl_sens_5_kz);
//Флаг Обрыв цепи датчика 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_5_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_5_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_5_brk,UVI_UVI_mb_DI.Fl_sens_5_brk);
//Флаг Цепь датчика 6 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_6_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_6_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_6_ok,UVI_UVI_mb_DI.Fl_sens_6_ok);
//Флаг  КЗ цепи датчика 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_6_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_6_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_6_kz,UVI_UVI_mb_DI.Fl_sens_6_kz);
//Флаг Обрыв цепи датчика 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_6_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_6_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_6_brk,UVI_UVI_mb_DI.Fl_sens_6_brk);
//Флаг Цепь датчика 7 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_7_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_7_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_7_ok,UVI_UVI_mb_DI.Fl_sens_7_ok);
//Флаг  КЗ цепи датчика 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_7_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_7_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_7_kz,UVI_UVI_mb_DI.Fl_sens_7_kz);
//Флаг Обрыв цепи датчика 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_7_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_7_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_7_brk,UVI_UVI_mb_DI.Fl_sens_7_brk);
//Флаг Цепь датчика 8 в норме
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_8_ok,UVI_UVI_mb_DI_FromHMI.Fl_sens_8_ok,UVI_UVI_mb_DI_ToHMI.Fl_sens_8_ok,UVI_UVI_mb_DI.Fl_sens_8_ok);
//Флаг  КЗ цепи датчика 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_8_kz,UVI_UVI_mb_DI_FromHMI.Fl_sens_8_kz,UVI_UVI_mb_DI_ToHMI.Fl_sens_8_kz,UVI_UVI_mb_DI.Fl_sens_8_kz);
//Флаг Обрыв цепи датчика 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_sens_8_brk,UVI_UVI_mb_DI_FromHMI.Fl_sens_8_brk,UVI_UVI_mb_DI_ToHMI.Fl_sens_8_brk,UVI_UVI_mb_DI.Fl_sens_8_brk);
//Флаг неиспраности канала 1 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_1_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_1_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_1_ackn,UVI_UVI_mb_DI.Fl_ch_1_ackn);
//Флаг засорен канал 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_1_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_1_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_1_clodge,UVI_UVI_mb_DI.Fl_ch_1_clodge);
//Флаг протечка канал 1
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_1_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_1_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_1_leak,UVI_UVI_mb_DI.Fl_ch_1_leak);
//Флаг неиспраности канала 2 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_2_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_2_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_2_ackn,UVI_UVI_mb_DI.Fl_ch_2_ackn);
//Флаг засорен канал 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_2_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_2_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_2_clodge,UVI_UVI_mb_DI.Fl_ch_2_clodge);
//Флаг протечка канал 2
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_2_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_2_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_2_leak,UVI_UVI_mb_DI.Fl_ch_2_leak);
//Флаг неиспраности канала 3 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_3_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_3_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_3_ackn,UVI_UVI_mb_DI.Fl_ch_3_ackn);
//Флаг засорен канал 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_3_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_3_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_3_clodge,UVI_UVI_mb_DI.Fl_ch_3_clodge);
//Флаг протечка канал 3
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_3_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_3_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_3_leak,UVI_UVI_mb_DI.Fl_ch_3_leak);
//Флаг неиспраности канала 4 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_4_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_4_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_4_ackn,UVI_UVI_mb_DI.Fl_ch_4_ackn);
//Флаг засорен канал 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_4_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_4_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_4_clodge,UVI_UVI_mb_DI.Fl_ch_4_clodge);
//Флаг протечка канал 4
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_4_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_4_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_4_leak,UVI_UVI_mb_DI.Fl_ch_4_leak);
//Флаг неиспраности канала 5 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_5_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_5_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_5_ackn,UVI_UVI_mb_DI.Fl_ch_5_ackn);
//Флаг засорен канал 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_5_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_5_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_5_clodge,UVI_UVI_mb_DI.Fl_ch_5_clodge);
//Флаг протечка канал 5
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_5_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_5_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_5_leak,UVI_UVI_mb_DI.Fl_ch_5_leak);
//Флаг неиспраности канала 6 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_6_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_6_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_6_ackn,UVI_UVI_mb_DI.Fl_ch_6_ackn);
//Флаг засорен канал 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_6_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_6_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_6_clodge,UVI_UVI_mb_DI.Fl_ch_6_clodge);
//Флаг протечка канал 6
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_6_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_6_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_6_leak,UVI_UVI_mb_DI.Fl_ch_6_leak);
//Флаг неиспраности канала 7 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_7_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_7_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_7_ackn,UVI_UVI_mb_DI.Fl_ch_7_ackn);
//Флаг засорен канал 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_7_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_7_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_7_clodge,UVI_UVI_mb_DI.Fl_ch_7_clodge);
//Флаг протечка канал 7
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_7_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_7_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_7_leak,UVI_UVI_mb_DI.Fl_ch_7_leak);
//Флаг неиспраности канала 8 сброшен
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_8_ackn,UVI_UVI_mb_DI_FromHMI.Fl_ch_8_ackn,UVI_UVI_mb_DI_ToHMI.Fl_ch_8_ackn,UVI_UVI_mb_DI.Fl_ch_8_ackn);
//Флаг засорен канал 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_8_clodge,UVI_UVI_mb_DI_FromHMI.Fl_ch_8_clodge,UVI_UVI_mb_DI_ToHMI.Fl_ch_8_clodge,UVI_UVI_mb_DI.Fl_ch_8_clodge);
//Флаг протечка канал 8
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Fl_ch_8_leak,UVI_UVI_mb_DI_FromHMI.Fl_ch_8_leak,UVI_UVI_mb_DI_ToHMI.Fl_ch_8_leak,UVI_UVI_mb_DI.Fl_ch_8_leak);
//Канал 1 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_1,UVI_UVI_mb_DI_FromHMI.Ch_on_1,UVI_UVI_mb_DI_ToHMI.Ch_on_1,UVI_UVI_mb_DI.Ch_on_1);
//Канал 2 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_2,UVI_UVI_mb_DI_FromHMI.Ch_on_2,UVI_UVI_mb_DI_ToHMI.Ch_on_2,UVI_UVI_mb_DI.Ch_on_2);
//Канал 3 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_3,UVI_UVI_mb_DI_FromHMI.Ch_on_3,UVI_UVI_mb_DI_ToHMI.Ch_on_3,UVI_UVI_mb_DI.Ch_on_3);
//Канал 4 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_4,UVI_UVI_mb_DI_FromHMI.Ch_on_4,UVI_UVI_mb_DI_ToHMI.Ch_on_4,UVI_UVI_mb_DI.Ch_on_4);
//Канал 5 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_5,UVI_UVI_mb_DI_FromHMI.Ch_on_5,UVI_UVI_mb_DI_ToHMI.Ch_on_5,UVI_UVI_mb_DI.Ch_on_5);
//Канал 6 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_6,UVI_UVI_mb_DI_FromHMI.Ch_on_6,UVI_UVI_mb_DI_ToHMI.Ch_on_6,UVI_UVI_mb_DI.Ch_on_6);
//Канал 7 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_7,UVI_UVI_mb_DI_FromHMI.Ch_on_7,UVI_UVI_mb_DI_ToHMI.Ch_on_7,UVI_UVI_mb_DI.Ch_on_7);
//Канал 8 в работе
mb_DI_Processing(UVI_UVI_mb_DI_DRV.Ch_on_8,UVI_UVI_mb_DI_FromHMI.Ch_on_8,UVI_UVI_mb_DI_ToHMI.Ch_on_8,UVI_UVI_mb_DI.Ch_on_8);
//Конец сгенерированного кода
]]></ST>
                    </Function>
                    <FunctionBlock UUID="BIVT7BBFRN3E7IHJW2F3YOM43Q" Name="mb_UVI_DI">
                        <Variables>
                            <Variable UUID="UUTBWQ4TUDMU7MBYAQSWRSKJZY" Name="UVI_DI" Type="DWORD" Size="4" Array="TRUE" Usage="internal" />
                        </Variables>
                        <ST><![CDATA[
UVI_DI[0]  :=   WORD_TO_DWORD(UVI_UVI_mb_AI_DRV.Vlv_state);
UVI_DI[1]  :=   WORD_TO_DWORD(UVI_UVI_mb_AI_DRV.Fl_sens);
UVI_DI[2]  :=   WORD_TO_DWORD(UVI_UVI_mb_AI_DRV.Fl_ch);

UVI_UVI_mb_DI_DRV.Vlv_1_ok   :=   NOT  EXTRACT(UVI_DI[0],0)   AND   NOT  EXTRACT(UVI_DI[0],1);   //   Цепь клапана 1 в норме
UVI_UVI_mb_DI_DRV.Vlv_1_kz   :=   NOT  EXTRACT(UVI_DI[0],0)   AND     EXTRACT(UVI_DI[0],1);   //   КЗ цепи клапана 1
UVI_UVI_mb_DI_DRV.Vlv_1_brk   :=     EXTRACT(UVI_DI[0],0)   AND   NOT  EXTRACT(UVI_DI[0],1);   //   Обрыв цепи клапан 1
UVI_UVI_mb_DI_DRV.Vlv_2_ok   :=   NOT  EXTRACT(UVI_DI[0],2)   AND   NOT  EXTRACT(UVI_DI[0],3);   //   Цепь клапана 2 в норме
UVI_UVI_mb_DI_DRV.Vlv_2_kz   :=   NOT  EXTRACT(UVI_DI[0],2)   AND     EXTRACT(UVI_DI[0],3);   //   КЗ цепи клапана 2
UVI_UVI_mb_DI_DRV.Vlv_2_brk   :=     EXTRACT(UVI_DI[0],2)   AND   NOT  EXTRACT(UVI_DI[0],3);   //   Обрыв цепи клапан 2
UVI_UVI_mb_DI_DRV.Vlv_3_ok   :=   NOT  EXTRACT(UVI_DI[0],4)   AND   NOT  EXTRACT(UVI_DI[0],5);   //   Цепь клапана 3 в норме
UVI_UVI_mb_DI_DRV.Vlv_3_kz   :=   NOT  EXTRACT(UVI_DI[0],4)   AND     EXTRACT(UVI_DI[0],5);   //   КЗ цепи клапана 3
UVI_UVI_mb_DI_DRV.Vlv_3_brk   :=     EXTRACT(UVI_DI[0],4)   AND   NOT  EXTRACT(UVI_DI[0],5);   //   Обрыв цепи клапан 3
UVI_UVI_mb_DI_DRV.Vlv_4_ok   :=   NOT  EXTRACT(UVI_DI[0],6)   AND   NOT  EXTRACT(UVI_DI[0],7);   //   Цепь клапана 4 в норме
UVI_UVI_mb_DI_DRV.Vlv_4_kz   :=   NOT  EXTRACT(UVI_DI[0],6)   AND     EXTRACT(UVI_DI[0],7);   //   КЗ цепи клапана 4
UVI_UVI_mb_DI_DRV.Vlv_4_brk   :=     EXTRACT(UVI_DI[0],6)   AND   NOT  EXTRACT(UVI_DI[0],7);   //   Обрыв цепи клапан 4
UVI_UVI_mb_DI_DRV.Vlv_5_ok   :=   NOT  EXTRACT(UVI_DI[0],8)   AND   NOT  EXTRACT(UVI_DI[0],9);   //   Цепь клапана 5 в норме
UVI_UVI_mb_DI_DRV.Vlv_5_kz   :=   NOT  EXTRACT(UVI_DI[0],8)   AND     EXTRACT(UVI_DI[0],9);   //   КЗ цепи клапана 5
UVI_UVI_mb_DI_DRV.Vlv_5_brk   :=     EXTRACT(UVI_DI[0],8)   AND   NOT  EXTRACT(UVI_DI[0],9);   //   Обрыв цепи клапан 5
UVI_UVI_mb_DI_DRV.Vlv_6_ok   :=   NOT  EXTRACT(UVI_DI[0],10)   AND   NOT  EXTRACT(UVI_DI[0],11);   //   Цепь клапана 6 в норме
UVI_UVI_mb_DI_DRV.Vlv_6_kz   :=   NOT  EXTRACT(UVI_DI[0],10)   AND     EXTRACT(UVI_DI[0],11);   //   КЗ цепи клапана 6
UVI_UVI_mb_DI_DRV.Vlv_6_brk   :=     EXTRACT(UVI_DI[0],10)   AND   NOT  EXTRACT(UVI_DI[0],11);   //   Обрыв цепи клапан 6
UVI_UVI_mb_DI_DRV.Vlv_7_ok   :=   NOT  EXTRACT(UVI_DI[0],12)   AND   NOT  EXTRACT(UVI_DI[0],13);   //   Цепь клапана 7 в норме
UVI_UVI_mb_DI_DRV.Vlv_7_kz   :=   NOT  EXTRACT(UVI_DI[0],12)   AND     EXTRACT(UVI_DI[0],13);   //   КЗ цепи клапана 7
UVI_UVI_mb_DI_DRV.Vlv_7_brk   :=     EXTRACT(UVI_DI[0],12)   AND   NOT  EXTRACT(UVI_DI[0],13);   //   Обрыв цепи клапан 7
UVI_UVI_mb_DI_DRV.Vlv_8_ok   :=   NOT  EXTRACT(UVI_DI[0],14)   AND   NOT  EXTRACT(UVI_DI[0],15);   //   Цепь клапана 8 в норме
UVI_UVI_mb_DI_DRV.Vlv_8_kz   :=   NOT  EXTRACT(UVI_DI[0],14)   AND     EXTRACT(UVI_DI[0],15);   //   КЗ цепи клапана 8
UVI_UVI_mb_DI_DRV.Vlv_8_brk   :=     EXTRACT(UVI_DI[0],14)   AND   NOT  EXTRACT(UVI_DI[0],15);   //   Обрыв цепи клапан 8

UVI_UVI_mb_DI_DRV.Fl_sens_1_ok   :=   NOT  EXTRACT(UVI_DI[1],0)   AND   NOT  EXTRACT(UVI_DI[1],1);   //   Флаг Цепь датчика 1 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_1_kz   :=   NOT  EXTRACT(UVI_DI[1],0)   AND     EXTRACT(UVI_DI[1],1);   //   Флаг  КЗ цепи датчика 1
UVI_UVI_mb_DI_DRV.Fl_sens_1_brk   :=     EXTRACT(UVI_DI[1],0)   AND   NOT  EXTRACT(UVI_DI[1],1);   //   Флаг Обрыв цепи датчика 1
UVI_UVI_mb_DI_DRV.Fl_sens_2_ok   :=   NOT  EXTRACT(UVI_DI[1],2)   AND   NOT  EXTRACT(UVI_DI[1],3);   //   Флаг Цепь датчика 2 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_2_kz   :=   NOT  EXTRACT(UVI_DI[1],2)   AND     EXTRACT(UVI_DI[1],3);   //   Флаг  КЗ цепи датчика 2
UVI_UVI_mb_DI_DRV.Fl_sens_2_brk   :=     EXTRACT(UVI_DI[1],2)   AND   NOT  EXTRACT(UVI_DI[1],3);   //   Флаг Обрыв цепи датчика 2
UVI_UVI_mb_DI_DRV.Fl_sens_3_ok   :=   NOT  EXTRACT(UVI_DI[1],4)   AND   NOT  EXTRACT(UVI_DI[1],5);   //   Флаг Цепь датчика 3 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_3_kz   :=   NOT  EXTRACT(UVI_DI[1],4)   AND     EXTRACT(UVI_DI[1],5);   //   Флаг  КЗ цепи датчика 3
UVI_UVI_mb_DI_DRV.Fl_sens_3_brk   :=     EXTRACT(UVI_DI[1],4)   AND   NOT  EXTRACT(UVI_DI[1],5);   //   Флаг Обрыв цепи датчика 3
UVI_UVI_mb_DI_DRV.Fl_sens_4_ok   :=   NOT  EXTRACT(UVI_DI[1],6)   AND   NOT  EXTRACT(UVI_DI[1],7);   //   Флаг Цепь датчика 4 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_4_kz   :=   NOT  EXTRACT(UVI_DI[1],6)   AND     EXTRACT(UVI_DI[1],7);   //   Флаг  КЗ цепи датчика 4
UVI_UVI_mb_DI_DRV.Fl_sens_4_brk   :=     EXTRACT(UVI_DI[1],6)   AND   NOT  EXTRACT(UVI_DI[1],7);   //   Флаг Обрыв цепи датчика 4
UVI_UVI_mb_DI_DRV.Fl_sens_5_ok   :=   NOT  EXTRACT(UVI_DI[1],8)   AND   NOT  EXTRACT(UVI_DI[1],9);   //   Флаг Цепь датчика 5 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_5_kz   :=   NOT  EXTRACT(UVI_DI[1],8)   AND     EXTRACT(UVI_DI[1],9);   //   Флаг  КЗ цепи датчика 5
UVI_UVI_mb_DI_DRV.Fl_sens_5_brk   :=     EXTRACT(UVI_DI[1],8)   AND   NOT  EXTRACT(UVI_DI[1],9);   //   Флаг Обрыв цепи датчика 5
UVI_UVI_mb_DI_DRV.Fl_sens_6_ok   :=   NOT  EXTRACT(UVI_DI[1],10)   AND   NOT  EXTRACT(UVI_DI[1],11);   //   Флаг Цепь датчика 6 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_6_kz   :=   NOT  EXTRACT(UVI_DI[1],10)   AND     EXTRACT(UVI_DI[1],11);   //   Флаг  КЗ цепи датчика 6
UVI_UVI_mb_DI_DRV.Fl_sens_6_brk   :=     EXTRACT(UVI_DI[1],10)   AND   NOT  EXTRACT(UVI_DI[1],11);   //   Флаг Обрыв цепи датчика 6
UVI_UVI_mb_DI_DRV.Fl_sens_7_ok   :=   NOT  EXTRACT(UVI_DI[1],12)   AND   NOT  EXTRACT(UVI_DI[1],13);   //   Флаг Цепь датчика 7 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_7_kz   :=   NOT  EXTRACT(UVI_DI[1],12)   AND     EXTRACT(UVI_DI[1],13);   //   Флаг  КЗ цепи датчика 7
UVI_UVI_mb_DI_DRV.Fl_sens_7_brk   :=     EXTRACT(UVI_DI[1],12)   AND   NOT  EXTRACT(UVI_DI[1],13);   //   Флаг Обрыв цепи датчика 7
UVI_UVI_mb_DI_DRV.Fl_sens_8_ok   :=   NOT  EXTRACT(UVI_DI[1],14)   AND   NOT  EXTRACT(UVI_DI[1],15);   //   Флаг Цепь датчика 8 в норме
UVI_UVI_mb_DI_DRV.Fl_sens_8_kz   :=   NOT  EXTRACT(UVI_DI[1],14)   AND     EXTRACT(UVI_DI[1],15);   //   Флаг  КЗ цепи датчика 8
UVI_UVI_mb_DI_DRV.Fl_sens_8_brk   :=     EXTRACT(UVI_DI[1],14)   AND   NOT  EXTRACT(UVI_DI[1],15);   //   Флаг Обрыв цепи датчика 8

UVI_UVI_mb_DI_DRV.Fl_ch_1_ackn   :=   NOT  EXTRACT(UVI_DI[2],0)   AND   NOT  EXTRACT(UVI_DI[2],1);   //   Флаг неиспраности канала 1 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_1_clodge   :=   NOT  EXTRACT(UVI_DI[2],0)   AND     EXTRACT(UVI_DI[2],1);   //   Флаг засорен канал 1
UVI_UVI_mb_DI_DRV.Fl_ch_1_leak   :=     EXTRACT(UVI_DI[2],0)   AND   NOT  EXTRACT(UVI_DI[2],1);   //   Флаг протечка канал 1
UVI_UVI_mb_DI_DRV.Fl_ch_2_ackn   :=   NOT  EXTRACT(UVI_DI[2],2)   AND   NOT  EXTRACT(UVI_DI[2],3);   //   Флаг неиспраности канала 2 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_2_clodge   :=   NOT  EXTRACT(UVI_DI[2],2)   AND     EXTRACT(UVI_DI[2],3);   //   Флаг засорен канал 2
UVI_UVI_mb_DI_DRV.Fl_ch_2_leak   :=     EXTRACT(UVI_DI[2],2)   AND   NOT  EXTRACT(UVI_DI[2],3);   //   Флаг протечка канал 2
UVI_UVI_mb_DI_DRV.Fl_ch_3_ackn   :=   NOT  EXTRACT(UVI_DI[2],4)   AND   NOT  EXTRACT(UVI_DI[2],5);   //   Флаг неиспраности канала 3 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_3_clodge   :=   NOT  EXTRACT(UVI_DI[2],4)   AND     EXTRACT(UVI_DI[2],5);   //   Флаг засорен канал 3
UVI_UVI_mb_DI_DRV.Fl_ch_3_leak   :=     EXTRACT(UVI_DI[2],4)   AND   NOT  EXTRACT(UVI_DI[2],5);   //   Флаг протечка канал 3
UVI_UVI_mb_DI_DRV.Fl_ch_4_ackn   :=   NOT  EXTRACT(UVI_DI[2],6)   AND   NOT  EXTRACT(UVI_DI[2],7);   //   Флаг неиспраности канала 4 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_4_clodge   :=   NOT  EXTRACT(UVI_DI[2],6)   AND     EXTRACT(UVI_DI[2],7);   //   Флаг засорен канал 4
UVI_UVI_mb_DI_DRV.Fl_ch_4_leak   :=     EXTRACT(UVI_DI[2],6)   AND   NOT  EXTRACT(UVI_DI[2],7);   //   Флаг протечка канал 4
UVI_UVI_mb_DI_DRV.Fl_ch_5_ackn   :=   NOT  EXTRACT(UVI_DI[2],8)   AND   NOT  EXTRACT(UVI_DI[2],9);   //   Флаг неиспраности канала 5 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_5_clodge   :=   NOT  EXTRACT(UVI_DI[2],8)   AND     EXTRACT(UVI_DI[2],9);   //   Флаг засорен канал 5
UVI_UVI_mb_DI_DRV.Fl_ch_5_leak   :=     EXTRACT(UVI_DI[2],8)   AND   NOT  EXTRACT(UVI_DI[2],9);   //   Флаг протечка канал 5
UVI_UVI_mb_DI_DRV.Fl_ch_6_ackn   :=   NOT  EXTRACT(UVI_DI[2],10)   AND   NOT  EXTRACT(UVI_DI[2],11);   //   Флаг неиспраности канала 6 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_6_clodge   :=   NOT  EXTRACT(UVI_DI[2],10)   AND     EXTRACT(UVI_DI[2],11);   //   Флаг засорен канал 6
UVI_UVI_mb_DI_DRV.Fl_ch_6_leak   :=     EXTRACT(UVI_DI[2],10)   AND   NOT  EXTRACT(UVI_DI[2],11);   //   Флаг протечка канал 6
UVI_UVI_mb_DI_DRV.Fl_ch_7_ackn   :=   NOT  EXTRACT(UVI_DI[2],12)   AND   NOT  EXTRACT(UVI_DI[2],13);   //   Флаг неиспраности канала 7 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_7_clodge   :=   NOT  EXTRACT(UVI_DI[2],12)   AND     EXTRACT(UVI_DI[2],13);   //   Флаг засорен канал 7
UVI_UVI_mb_DI_DRV.Fl_ch_7_leak   :=     EXTRACT(UVI_DI[2],12)   AND   NOT  EXTRACT(UVI_DI[2],13);   //   Флаг протечка канал 7
UVI_UVI_mb_DI_DRV.Fl_ch_8_ackn   :=   NOT  EXTRACT(UVI_DI[2],14)   AND   NOT  EXTRACT(UVI_DI[2],15);   //   Флаг неиспраности канала 8 сброшен
UVI_UVI_mb_DI_DRV.Fl_ch_8_clodge   :=   NOT  EXTRACT(UVI_DI[2],14)   AND     EXTRACT(UVI_DI[2],15);   //   Флаг засорен канал 8
UVI_UVI_mb_DI_DRV.Fl_ch_8_leak   :=     EXTRACT(UVI_DI[2],14)   AND   NOT  EXTRACT(UVI_DI[2],15);   //   Флаг протечка канал 8


//UVI_UVI_mb_DI_DRV.Vlv_1_ok
(*
KC_SKM_DI_DRV.State_IKP_1_good   :=     NOT EXTRACT(UVI_DI[0],0) AND   NOT EXTRACT(UVI_DI[0],1);  
KC_SKM_DI_DRV.State_IKP_1_opened   :=     NOT EXTRACT(UVI_DI[0],0) AND EXTRACT(UVI_DI[0],1);  
KC_SKM_DI_DRV.State_IKP_1_absent   :=   EXTRACT(UVI_DI[0],0) AND   NOT EXTRACT(UVI_DI[0],1);  
*)]]></ST>
                    </FunctionBlock>
                </Folder>
                <Folder Name="DO" Comment="" Data="" UUID="3MICJZ23O6TUHAUYXIZMCMS2NM">
                    <Function UUID="OXUR3XUGJYQMMR52OKWUL5OJZE" Name="UVI_UVI_DO_Permit" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables>
                            <Variable UUID="TGLRFATQ24XUPFHW373KXU5CZ4" Name="tmpPermit" Type="BOOL" Usage="internal" />
                        </Variables>
                        <ST><![CDATA[//--- Групповое разрешение ДУ ---
tmpPermit := true;
//Начало сгенерированного кода DO_Permit
UVI_UVI_mb_DO_ToHMI.Vlv_on_1.forsPermit := tmpPermit; //Открыть клапан 1;
UVI_UVI_mb_DO_ToHMI.Vlv_on_2.forsPermit := tmpPermit; //Открыть клапан 2;
UVI_UVI_mb_DO_ToHMI.Vlv_on_3.forsPermit := tmpPermit; //Открыть клапан 3;
UVI_UVI_mb_DO_ToHMI.Vlv_on_4.forsPermit := tmpPermit; //Открыть клапан 4;
UVI_UVI_mb_DO_ToHMI.Vlv_on_5.forsPermit := tmpPermit; //Открыть клапан 5;
UVI_UVI_mb_DO_ToHMI.Vlv_on_6.forsPermit := tmpPermit; //Открыть клапан 6;
UVI_UVI_mb_DO_ToHMI.Vlv_on_7.forsPermit := tmpPermit; //Открыть клапан 7;
UVI_UVI_mb_DO_ToHMI.Vlv_on_8.forsPermit := tmpPermit; //Открыть клапан 8;
UVI_UVI_mb_DO_ToHMI.Ackn.forsPermit := tmpPermit; //Квитирование;
//Конец сгенерированного кода
]]></ST>
                    </Function>
                    <Function UUID="IQMFT6UEIZTRVJAJGKZJ3AQF54" Name="UVI_UVI_mb_DO_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                        <Variables />
                        <ST><![CDATA[//----------- Обработка дискретных выходов ---------------
//Начало сгенерированного кода DO_Processing
//Открыть клапан 1
DO_Processing(UVI_UVI_mb_DO.Vlv_on_1,UVI_UVI_mb_DO_FromHMI.Vlv_on_1,UVI_UVI_mb_DO_ToHMI.Vlv_on_1,UVI_UVI_mb_DO_DRV.Vlv_on_1);
//Открыть клапан 2
DO_Processing(UVI_UVI_mb_DO.Vlv_on_2,UVI_UVI_mb_DO_FromHMI.Vlv_on_2,UVI_UVI_mb_DO_ToHMI.Vlv_on_2,UVI_UVI_mb_DO_DRV.Vlv_on_2);
//Открыть клапан 3
DO_Processing(UVI_UVI_mb_DO.Vlv_on_3,UVI_UVI_mb_DO_FromHMI.Vlv_on_3,UVI_UVI_mb_DO_ToHMI.Vlv_on_3,UVI_UVI_mb_DO_DRV.Vlv_on_3);
//Открыть клапан 4
DO_Processing(UVI_UVI_mb_DO.Vlv_on_4,UVI_UVI_mb_DO_FromHMI.Vlv_on_4,UVI_UVI_mb_DO_ToHMI.Vlv_on_4,UVI_UVI_mb_DO_DRV.Vlv_on_4);
//Открыть клапан 5
DO_Processing(UVI_UVI_mb_DO.Vlv_on_5,UVI_UVI_mb_DO_FromHMI.Vlv_on_5,UVI_UVI_mb_DO_ToHMI.Vlv_on_5,UVI_UVI_mb_DO_DRV.Vlv_on_5);
//Открыть клапан 6
DO_Processing(UVI_UVI_mb_DO.Vlv_on_6,UVI_UVI_mb_DO_FromHMI.Vlv_on_6,UVI_UVI_mb_DO_ToHMI.Vlv_on_6,UVI_UVI_mb_DO_DRV.Vlv_on_6);
//Открыть клапан 7
DO_Processing(UVI_UVI_mb_DO.Vlv_on_7,UVI_UVI_mb_DO_FromHMI.Vlv_on_7,UVI_UVI_mb_DO_ToHMI.Vlv_on_7,UVI_UVI_mb_DO_DRV.Vlv_on_7);
//Открыть клапан 8
DO_Processing(UVI_UVI_mb_DO.Vlv_on_8,UVI_UVI_mb_DO_FromHMI.Vlv_on_8,UVI_UVI_mb_DO_ToHMI.Vlv_on_8,UVI_UVI_mb_DO_DRV.Vlv_on_8);
//Квитирование
DO_Processing(UVI_UVI_mb_DO.Ackn,UVI_UVI_mb_DO_FromHMI.Ackn,UVI_UVI_mb_DO_ToHMI.Ackn,UVI_UVI_mb_DO_DRV.Ackn);
//Конец сгенерированного кода
]]></ST>
                    </Function>
                </Folder>
                <FunctionBlock UUID="ARCJAQXZ64FELEYDH7EUWUXRJI" Name="FB_mb_IM_UVI">
                    <Variables />
                    <ST><![CDATA[//=====================================================================================================================================//
//===========================	ОБРАБОТКА СИГНАЛОВ ИМов	===============================================================================//
//===========================	ПЕРЕДАВАЕМЫХ по MODBUS	===============================================================================//
//=====================================================================================================================================//

//УВИ: Клапан №1
UVI_AM.Vlv_1.ON	:= UVI_UVI_mb_DI.Vlv_on_1;//= открыт
UVI_AM.Vlv_1.OFF	:= not UVI_UVI_mb_DI.Vlv_on_1;//= закрыт
UVI_AM.Vlv_1.general	:= not UVI_UVI_mb_DI.Vlv_1_ok or UVI_UVI_mb_DI.Vlv_1_kz or UVI_UVI_mb_DI.Vlv_1_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_1.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_1.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_1 := UVI_AM.Vlv_1.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_1.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №2
UVI_AM.Vlv_2.ON	:= UVI_UVI_mb_DI.Vlv_on_2;//= открыт
UVI_AM.Vlv_2.OFF	:= not UVI_UVI_mb_DI.Vlv_on_2;//= закрыт
UVI_AM.Vlv_2.general	:= not UVI_UVI_mb_DI.Vlv_2_ok or UVI_UVI_mb_DI.Vlv_2_kz or UVI_UVI_mb_DI.Vlv_2_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_2.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_2.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_2 := UVI_AM.Vlv_2.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_2.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №3
UVI_AM.Vlv_3.ON	:= UVI_UVI_mb_DI.Vlv_on_3;//= открыт
UVI_AM.Vlv_3.OFF	:= not UVI_UVI_mb_DI.Vlv_on_3;//= закрыт
UVI_AM.Vlv_3.general	:= not UVI_UVI_mb_DI.Vlv_3_ok or UVI_UVI_mb_DI.Vlv_3_kz or UVI_UVI_mb_DI.Vlv_3_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_3.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_3.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_3 := UVI_AM.Vlv_3.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_3.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №4
UVI_AM.Vlv_4.ON	:= UVI_UVI_mb_DI.Vlv_on_4;//= открыт
UVI_AM.Vlv_4.OFF	:= not UVI_UVI_mb_DI.Vlv_on_4;//= закрыт
UVI_AM.Vlv_4.general	:= not UVI_UVI_mb_DI.Vlv_4_ok or UVI_UVI_mb_DI.Vlv_4_kz or UVI_UVI_mb_DI.Vlv_4_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_4.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_4.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_4 := UVI_AM.Vlv_4.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_4.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №5
UVI_AM.Vlv_5.ON	:= UVI_UVI_mb_DI.Vlv_on_5;//= открыт
UVI_AM.Vlv_5.OFF	:= not UVI_UVI_mb_DI.Vlv_on_5;//= закрыт
UVI_AM.Vlv_5.general	:= not UVI_UVI_mb_DI.Vlv_5_ok or UVI_UVI_mb_DI.Vlv_5_kz or UVI_UVI_mb_DI.Vlv_5_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_5.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_5.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_5 := UVI_AM.Vlv_5.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_5.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №6
UVI_AM.Vlv_6.ON	:= UVI_UVI_mb_DI.Vlv_on_6;//= открыт
UVI_AM.Vlv_6.OFF	:= not UVI_UVI_mb_DI.Vlv_on_6;//= закрыт
UVI_AM.Vlv_6.general	:= not UVI_UVI_mb_DI.Vlv_6_ok or UVI_UVI_mb_DI.Vlv_6_kz or UVI_UVI_mb_DI.Vlv_6_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_6.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_6.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_6 := UVI_AM.Vlv_6.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_6.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №7
UVI_AM.Vlv_7.ON	:= UVI_UVI_mb_DI.Vlv_on_7;//= открыт
UVI_AM.Vlv_7.OFF	:= not UVI_UVI_mb_DI.Vlv_on_7;//= закрыт
UVI_AM.Vlv_7.general	:= not UVI_UVI_mb_DI.Vlv_7_ok or UVI_UVI_mb_DI.Vlv_7_kz or UVI_UVI_mb_DI.Vlv_7_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_7.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_7.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_7 := UVI_AM.Vlv_7.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_7.rOff;//= "Закрыть" в ДУ
//=========================================================
//УВИ: Клапан №8
UVI_AM.Vlv_8.ON	:= UVI_UVI_mb_DI.Vlv_on_8;//= открыт
UVI_AM.Vlv_8.OFF	:= not UVI_UVI_mb_DI.Vlv_on_8;//= закрыт
UVI_AM.Vlv_8.general	:= not UVI_UVI_mb_DI.Vlv_8_ok or UVI_UVI_mb_DI.Vlv_8_kz or UVI_UVI_mb_DI.Vlv_8_brk;//= обобщённая ошибка
(*
UVI_AM.Vlv_8.ONOF	:= ;//= неисправность концевиков
:= UVI_AM.Vlv_8.DA;//= режим управления (0 - автоматич., 1 - дистанционн.)
*)
UVI_UVI_mb_DO.Vlv_on_8 := UVI_AM.Vlv_8.rOn;//= "Открыть" в ДУ
//= := UVI_AM.Vlv_8.rOff;//= "Закрыть" в ДУ
//=========================================================]]></ST>
                </FunctionBlock>
            </Folder>
            <Function UUID="2F3UB23OXIHELI6M3KYMPN46DE" Name="mb_AI_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="L27BSM7XEZH7PBAFCWXQPDPAHM" Name="in" Type="REAL" Usage="input" />
                    <Variable UUID="3RRZ672T65H27KGUANWIHJUTAQ" Name="set" Type="T_mb_AI_Settings" TypeUUID="ESHVMMDQRNWUVGD5OOWOXN2N44" Usage="input" />
                    <Variable UUID="6GENIMNWPJBGLDUSADU5POKSIU" Name="fromHMI" Type="T_AI_FromHMI" TypeUUID="VZ3H6GEVT3CUTI65HAA5AALRAY" Usage="inout" />
                    <Variable UUID="2ISD2SFA6RHOVBLDUJA43YIYKA" Name="toHMI" Type="T_AI_ToHMI" TypeUUID="J74RQIZG5I6EZDCM32A6SZRKIM" Usage="inout" />
                    <Variable UUID="4FOVGDDSVNDJVMJ33BNQD4UHBQ" Name="criticalSettingErr" Type="BOOL" Usage="internal" />
                    <Variable UUID="SIMSIEIFINHRJIC55L2DCXT3CM" Name="limSettingErr" Type="BOOL" Usage="internal" />
                    <Variable UUID="BGOHZRGBKVHJFGQBERMGBC6VXU" Name="brkSettingErr" Type="BOOL" Usage="internal" />
                    <Variable UUID="26HV5IVYA7UE5DV5U7Q5EC2O2Q" Name="tmp" Type="REAL" Usage="internal" />
                </Variables>
                <ST><![CDATA[//0- float ABCD, 1- float CDAB, 2- float BADC, 3- float DCBA, 4 - INT ABxN,  5 - INT BAxN,   6 - INT ABxR,   7 - INT BAxR
//                                                            8 - UINT ABxN, 9 - UINT BAxN, 10 - UINT ABxR, 11 - UINT BAxR

//---------------------- Поиск ошибок задания настроек – несоответствие допустимым значениям (BOOL)-----------------------------------------
criticalSettingErr := (set.format = 6 or set.format = 7 or set.format = 10 or set.format = 11) and (set.min >= set.max or set.set2 = set.set1);
limSettingErr := set.loLim >= set.hiLim or set.loLim >= set.max or set.hiLim <= set.min;
brkSettingErr := set.hiBrk <= set.hiLim or set.loBrk >= set.loLim;
toHMI.settingErr := criticalSettingErr or limSettingErr or brkSettingErr;
toHMI.fault_common := toHMI.settingErr or toHMI.break or toHMI.up_scale or toHMI.down_scale;//обобщённая неисправность. Образуется по «ИЛИ» от break,up_scale,down_scale,ROC,settingErr (BOOL)
toHMI.criticalFault := criticalSettingErr or toHMI.break;//Критическая ошибка, свидетельствующая о полной неисправности канала
if criticalSettingErr then
	return;
end_if;
//---------------------------------------------------------------------------------------------------------------------------------------------
//----------------- Пересчёт парамера из кодов АЦП в единицы измерения -----------------------------------------------------------------------
if    set.format = 4 or set.format = 5 then
	if set.set1 = 0.0 then
		set.set1 := 1.0;
	end_if;
	toHMI.measure := in * set.set1;
elsif set.format = 6 or set.format = 7 then
	toHMI.measure := (in - set.set1)/(set.set2 - set.set1)*(set.max - set.min) + set.min;
else
	toHMI.measure := in;
end_if;
//---------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------- Определение обрыва и зашкалов -----------------------------------------------------------------------
if not brkSettingErr then
	toHMI.break      := toHMI.break      and not fromHMI.BTNworkOn or toHMI.measure > set.hiBrk or toHMI.measure < set.loBrk;	//обрыв канала (BOOL)
end_if;
if not limSettingErr then
	toHMI.up_scale   := toHMI.up_scale   and not fromHMI.BTNworkOn or toHMI.measure > set.hiLim;							//выход за верхний зашкал (BOOL)
	toHMI.down_scale := toHMI.down_scale and not fromHMI.BTNworkOn or toHMI.measure < set.loLim;							//выход за нижний зашкал (BOOL)
end_if;
//------------------------------------------------------------------------------------------------------------------------------------------------
//------------------- Обработка ДУ ----------------------------------------------------------------------------------------------------------
tmp := toHMI.measure;
toHMI.manual := (fromHMI.BTNmanualOn or toHMI.manual) and not fromHMI.BTNworkOn;//канал в дист.упр. (BOOL)
if toHMI.manual then
	toHMI.PV := fromHMI.manualTarget;//значение для САУ. Рассчитывается из  measure, Manual_Target с учётом неисправностей и фильтрации (REAL)
else
	toHMI.PV := toHMI.measure;
	fromHMI.manualTarget := toHMI.PV;
end_if;
if set.tau > 0.0 then
	toHMI.PV := toHMI.PV + (tmp - toHMI.PV)/set.tau;
else
	toHMI.PV := tmp;
end_if;
//-------------- Обнуление кнопок -----------
fromHMI.BTNmanualOn := false;
fromHMI.BTNworkOn := false;]]></ST>
            </Function>
            <Function UUID="NVF5WA36MS3EDEJJCGBUSAEYDY" Name="mb_AI_init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="3PUM5EGSZZGW5B46GT7GJGJYHY" Name="setStruct" Type="T_mb_AI_Settings" TypeUUID="ESHVMMDQRNWUVGD5OOWOXN2N44" Usage="output" />
                    <Variable UUID="A4X47N4MTNEGBMHG5JCV54OYD4" Name="min" Type="REAL" Usage="input" />
                    <Variable UUID="J3PMJZQQPFCKTLXZKHCSBVW2FY" Name="max" Type="REAL" Usage="input" />
                    <Variable UUID="SNMC52OSVNCEJC2WKNQ55IXRDU" Name="loLim" Type="REAL" Usage="input" />
                    <Variable UUID="C5FFNJBSORADZKDONAJYIOYQMM" Name="hiLim" Type="REAL" Usage="input" />
                    <Variable UUID="BLJ7QPD3B5GIFOK5INHVLE4N4M" Name="loBrk" Type="REAL" Usage="input" />
                    <Variable UUID="BRAZ2SPNOBCCNMKASNN375STCQ" Name="hiBrk" Type="REAL" Usage="input" />
                    <Variable UUID="UCAGZSJ77NAYTFYRM4N5QV62A4" Name="format" Type="INT" Usage="input" />
                    <Variable UUID="PPFZBCEPQNDGDPXS4GFZ5DG2R4" Name="set1" Type="REAL" Usage="input" />
                    <Variable UUID="YGKONKKT2ZACFPHVF5HQIODJOQ" Name="set2" Type="REAL" Usage="input" />
                    <Variable UUID="FIPADVDHNWOEBDOPFXPJ6QM5UM" Name="tau" Type="REAL" Usage="input" />
                    <Variable UUID="O2PSTUZUB5EIRAZBONFYBOPYXU" Name="id" Type="INT" Usage="input" />
                </Variables>
                <ST><![CDATA[setStruct.min:= min;//минимум шкалы канала, ед.изм. Не может быть >= max
setStruct.max:= max;//максимум шкалы канала, ед.изм. Не может быть <= min
setStruct.loLim:= loLim;//уровень зашкала вниз, ед.изм. Не может быть >= hiLim и < min
setStruct.hiLim:= hiLim;//уровень зашкала вверх, ед.изм. Не может быть <= loLim и > max
setStruct.loBrk:= loBrk;//уровень зашкала вниз, ед.изм. Не может быть >= loLim
setStruct.hiBrk:= hiBrk;//уровень обрыва вверх, ед.изм. Не может быть <= hiLim
setStruct.format:= format;//Формат данных
setStruct.set1:= set1;//Настройка 1
setStruct.set2:= set2;//Настройка 2
setStruct.tau:= tau;//Настройка лаг-фильтра
setStruct.id:= id;//номер по порядку]]></ST>
            </Function>
            <Function UUID="C355Y7K6M5IU3JESUKH26M6TTA" Name="mb_AO_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="YWZFMDKLMVYUNFNPE5IXHVSIGY" Name="alg" Type="REAL" Usage="input" />
                    <Variable UUID="CFXXFVD5OJA45LRO7CLY355CNE" Name="set" Type="T_mb_AO_Settings" TypeUUID="7ICVQVNQUR4UDG5AFGOT7BUCRA" Usage="input" />
                    <Variable UUID="5R5WL3HGLRGMXN3ZVPA3FETS6Q" Name="fromHMI" Type="T_AO_FromHMI" TypeUUID="7GRLWKHH6VJU5KGLKDIOI5QPQI" Usage="inout" />
                    <Variable UUID="EDA4FRWG6FGWJPKIBGBT6SNR2Q" Name="toHMI" Type="T_AO_ToHMI" TypeUUID="KOTCLUQLO7JERF5MDM2GMF62MI" Usage="inout" />
                    <Variable UUID="E2P6NR4I7IXEBKC63CP7BOLLQI" Name="outReal" Type="REAL" Usage="output" />
                    <Variable UUID="VBNLWELECL2ELOHFKCMBCNOXDQ" Name="outInt" Type="INT" Usage="output" />
                    <Variable UUID="BH6EHBZAY7HUJMOBUFZLHOB7YQ" Name="tmp" Type="REAL" Usage="internal" />
                </Variables>
                <ST><![CDATA[//0- float ABCD, 1- float CDAB, 2- float BADC, 3- float DCBA, 4 - INT ABxN,  5 - INT BAxN,   6 - INT ABxR,   7 - INT BAxR
//                                                            8 - UINT ABxN, 9 - UINT BAxN, 10 - UINT ABxR, 11 - UINT BAxR
//------------------------------------------------------------------------------------------------------------------------------
toHMI.forsEnable := (toHMI.forsEnable or fromHMI.BTNforceOn) and toHMI.forsPermit and not fromHMI.BTNworkOn;
if toHMI.forsEnable then
	tmp := fromHMI.manualTarget;	
else
	tmp := alg;
	fromHMI.manualTarget := alg;
end_if;
//----------------- Пересчёт парамера из единиц измерения в коды modbus -----------------------------------------------------------------------
if set.format = 4 or set.format = 5 or set.format = 8 or set.format = 9 then
	if set.set1 = 0.0 then
		set.set1 := 1.0;
	end_if;
	outInt := REAL_TO_INT(tmp / set.set1);
elsif set.format = 6 or set.format = 7 or set.format = 10 or set.format = 11 then
	if set.max <> set.min then
		outInt := REAL_TO_INT((tmp - set.min)/(set.max - set.min)*(set.set2 - set.set1) + set.set1);
	else
		outInt := 0;
	end_if;
else
	outReal := tmp;
end_if;
//-------------- Обнуление кнопок -----------
fromHMI.BTNforceOn := false;
fromHMI.BTNworkOn := false;]]></ST>
            </Function>
            <Function UUID="3RCK6I23LYKEDH2INOAP7YEI7A" Name="mb_AO_init" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="3PUM5EGSZZGW5B46GT7GJGJYHY" Name="setStruct" Type="T_mb_AO_Settings" TypeUUID="7ICVQVNQUR4UDG5AFGOT7BUCRA" Usage="output" />
                    <Variable UUID="A4X47N4MTNEGBMHG5JCV54OYD4" Name="min" Type="REAL" Usage="input" />
                    <Variable UUID="J3PMJZQQPFCKTLXZKHCSBVW2FY" Name="max" Type="REAL" Usage="input" />
                    <Variable UUID="Z6XQFDI42ZUEHDDY2ZBDTQSSYM" Name="format" Type="INT" Usage="input" />
                    <Variable UUID="SNMC52OSVNCEJC2WKNQ55IXRDU" Name="set1" Type="REAL" Usage="input" />
                    <Variable UUID="C5FFNJBSORADZKDONAJYIOYQMM" Name="set2" Type="REAL" Usage="input" />
                    <Variable UUID="UCAGZSJ77NAYTFYRM4N5QV62A4" Name="id" Type="INT" Usage="input" />
                </Variables>
                <ST><![CDATA[setStruct.min:= min;//минимум шкалы канала, ед.изм. Не может быть >= max
setStruct.max:= max;//максимум шкалы канала, ед.изм. Не может быть <= min
setStruct.format:= format;//Формат данных
setStruct.set1:= set1;//Настройка 1.
setStruct.set2:= set2;//Настройка 2
setStruct.id:= id;//номер по порядку	]]></ST>
            </Function>
            <Function UUID="2ULQSEEY2MWERNE72WRM6UMD4Q" Name="mb_DI_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="L27BSM7XEZH7PBAFCWXQPDPAHM" Name="in" Type="BOOL" Usage="input" />
                    <Variable UUID="6GENIMNWPJBGLDUSADU5POKSIU" Name="btn" Type="T_DI_FromHMI" TypeUUID="CB63GVNINFXE5NDGOS62CUMGSY" Usage="inout" />
                    <Variable UUID="2ISD2SFA6RHOVBLDUJA43YIYKA" Name="hmi" Type="T_DI_ToHMI" TypeUUID="GHOQ5H5MCDOEHDF2HTYC2D4HJI" Usage="inout" />
                    <Variable UUID="EAYMNT5AXKIEPERYPL4MAHCRDA" Name="out" Type="BOOL" Usage="inout" />
                </Variables>
                <ST><![CDATA[//--------------------------------------------------------------------------------------------
hmi.manual := (btn.BTNmanualOn or hmi.manual) and not btn.BTNworkOn;//канал в дист.упр. (BOOL)
//------------------- Обработка ДУ -----------------------------------------------------------
out := hmi.manual and btn.manualTarget or not hmi.manual and in;
btn.manualTarget := out;
//----------------- Обнуление кнопок ---------------------------------------------------------
btn.BTNmanualOn := false;
btn.BTNworkOn := false;]]></ST>
            </Function>
            <Function UUID="KC3UFSWRQQPE5CS4AE6ZFPYEQY" Name="mb_DO_Processing" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="KQE6TXSBPSYUZBETKKJ3RJNA2U" Name="algCom" Type="BOOL" Usage="input" />
                    <Variable UUID="5R5WL3HGLRGMXN3ZVPA3FETS6Q" Name="hmi" Type="T_DO_FromHMI" TypeUUID="ICYCYA5WR5FTZMTITNXXGA6V4U" Usage="inout" />
                    <Variable UUID="EDA4FRWG6FGWJPKIBGBT6SNR2Q" Name="plc" Type="T_DO_ToHMI" TypeUUID="JPIXI5FFWBGSRAAFIJ2MBV77UE" Usage="inout" />
                    <Variable UUID="7WXGR7INBZ7UBK5X2H62BJBGNE" Name="out" Type="BOOL" Usage="inout" />
                </Variables>
                <ST><![CDATA[plc.forsEnable := (plc.forsEnable or hmi.BTNforceOn) and plc.forsPermit and not hmi.BTNworkOn;
out := algCom and not plc.forsEnable or hmi.manualTarget and plc.forsEnable;
hmi.manualTarget := out;
//-------------- Обнуление кнопок -----------
hmi.BTNforceOn := false;
hmi.BTNworkOn := false;]]></ST>
            </Function>
        </Folder>
        <Folder Name="Режимы" Comment="" Data="" UUID="JZ6KDHOVGOUU3BFVXW35672AYM">
            <Function UUID="4Q6M2NOJJZVU3L6AW4OON5QEFE" Name="Graph_Processing" ResultTypeUUID="J2GLKR5SZATEPPS6SYYJ4FXRO4">
                <Variables>
                    <Variable UUID="JAJ25GPVEBHEDJFPKUJ6NFJW5A" Name="graph" Type="T_Graph" TypeUUID="KHQWP3RHOTWEFJWBPCB6JIVNWI" Usage="inout" />
                    <Variable UUID="YFBXCL5MXYLUPBW4MBKKSVU7OQ" Name="i" Type="INT" Usage="internal" />
                    <Variable UUID="NMDCZXMXGX4UFDOHJS75GMLLJ4" Name="j" Type="INT" Usage="internal" />
                </Variables>
                <ST><![CDATA[(*for i := 0 to 32 do
	if graph.state = i then
		for j := 0 to 32 do
			if EXTRACT(graph.cond[i],j) then graph.state := j; end_if;
		end_for;
	end_if;
end_for;
*)

//=  31
for i := 0 to 31 do
//=	if graph.state = i then
		for j := 0 to 31 do
			if EXTRACT(graph.cond[i],j) then graph.state := j; (*exit;*) end_if;
		end_for;
//=	end_if;
end_for;


//= обнуляем условия переходов
for i:= 0 to 31 do
	graph.cond[i] := DWORD#0;
end_for;

Graph_Processing := graph.state;

]]></ST>
            </Function>
            <Function UUID="XOMDT3IVRFDTLE3KIXYOQ6CO2I" Name="Mode_CallAll" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
                <Variables>
                    <Variable UUID="4GGEESI4WEBELMXGJPCY6EMSXI" Name="AO" Type="INT" Usage="internal" />
                    <Variable UUID="NB5XWH7SF4PULE6RHMMEANS5QA" Name="Norma" Type="INT" Usage="internal" />
                    <Variable UUID="GMMSZZIWZ2QENHQ6ZGJYWZVZQM" Name="Fault" Type="INT" Usage="internal" />
                </Variables>
                <ST><![CDATA[//УВИ
Fault  	:= 0;//Нет режима
//
AO  	:= 1;//АО
Norma  	:= 2;//Норма

//===========================================================================================================================================================================================

//=== АО    ========|======||======||=======================
if not algUVI.AO 	then mdeUVI.graph.cond[AO] := PUTBIT(mdeUVI.graph.cond[AO],  Norma, true); end_if;		// Из АО в Норма
//=== Норма  ========|======||======||=======================
if algUVI.AO 		then mdeUVI.graph.cond[Norma] := PUTBIT(mdeUVI.graph.cond[Norma],AO, 	true); end_if;		// в АО
//===========================================================================================================================================================================================
//============================================================================
UVI_Mode.Num := Graph_Processing(mdeUVI.graph);
//============================================================================
//===========================================================================================================================================================================================

UVI_Mode.AOUVI 	:=  mdeUVI.graph.state = AO;	//АО
UVI_Mode.NormaUVI	:=  mdeUVI.graph.state = Norma;//Резерв

UVI_Mode.FaultUVI := not (UVI_Mode.NormaUVI or UVI_Mode.AOUVI);// Нет режима
]]></ST>
            </Function>
        </Folder>
        <FunctionBlock UUID="6FYJFI56GMYUTBC5ILWW7D63N4" Name="FB_Imit">
            <Variables>
                <Variable UUID="54WEIN3B6QWEPCCDUJ3TRWWWDA" Name="tmr_init" Type="TON" TypeUUID="NM52J2VHZ3GU3NCIW4VK3USPKU" Usage="internal" />
            </Variables>
            <ST><![CDATA[tmr_init(IN:= ImitOn, PT:= T#1s);

(*if not tmr_init.Q then 
	UVI_DI_DRV.Vn_V1_ON   := TRUE;


else
*)
UVI_DI_DRV.Vn_V1_ON    := UVI_AM.Vn_V1.iOn;   //= UVI_DI_DRV.Vn_V1_OF   := UVI_AM.Vn_V1.iOff;


//= end_if;]]></ST>
        </FunctionBlock>
        <FunctionBlock UUID="LCERBCVHMURELEDEHKKNKLUZNQ" Name="FB_Pulse" Comment="Блок формирования импульсов с периодом Tp">
            <Variables>
                <Variable UUID="CMR5BQDGRKPEZBIKWN5RA576SY" Name="on" Comment="Запуск ипульсов" Type="BOOL" Usage="input" />
                <Variable UUID="B6IJ67FPJ3RUFJNLPAS7YG4QFE" Name="tp" Comment="Период следования импульсов" Type="TIME" Usage="input" />
                <Variable UUID="XZGD3TDBOORUPN4TMQKQ32TE3I" Name="tic" Comment="Выход" Type="BOOL" Usage="output" />
                <Variable UUID="TIVKZZA76UQEBDGHCVSWZRJTPI" Name="tmr" Type="TON" TypeUUID="NM52J2VHZ3GU3NCIW4VK3USPKU" Usage="internal" />
            </Variables>
            <ST><![CDATA[//таймер периода
tmr(IN:= on AND NOT tmr.Q, PT:= tp);
//на полупериоде установить 0
//выход
tic :=  tmr.ET < tp/2 AND NOT tmr.Q AND on;
//Steam
]]></ST>
        </FunctionBlock>
        <Function UUID="4RQ57DVKE5HURIKSDR7O536VF4" Name="Trends" ResultTypeUUID="3V5XT3AA6VAULD5HQCWTIGEZD4">
            <Variables />
            <ST><![CDATA[//--------------------------------------- Формирование трендовых переменых --------------------------------------------
//#####################################################################################################################

//------------------------------AI---------------------------------------
UVI_AI_Trend.Lmet_E8_1_v := UVI_AI_ToHMI.Lmet_E8_1_v.PV; //Верхний уровень в емкости E-8.1 дренажа метанола
UVI_AI_Trend.Gas_met1_v := UVI_AI_ToHMI.Gas_met1_v.PV; //Загазованность по метанолу (QISA-1)
UVI_AI_Trend.Gas_met2_v := UVI_AI_ToHMI.Gas_met2_v.PV; //Загазованность по метанолу (QISA-2)
UVI_AI_Trend.Res_0 := UVI_AI_ToHMI.Res_0.PV; //Резерв
UVI_AI_Trend.Uosn_SAU := UVI_AI_ToHMI.Uosn_SAU.PV; //Измерение основного напряжения
UVI_AI_Trend.Urez_SAU := UVI_AI_ToHMI.Urez_SAU.PV; //Измерение резервного напряжения
UVI_AI_Trend.Res_1 := UVI_AI_ToHMI.Res_1.PV; //Резерв
UVI_AI_Trend.Res_2 := UVI_AI_ToHMI.Res_2.PV; //Резерв
//------------------------------DI---------------------------------------
UVI_DI_Trend.Gas_met1_v := UVI_DI.Gas_met1_v; //Загазованность по метанолу QISA-1, порог 1
UVI_DI_Trend.Gas_met1_av := UVI_DI.Gas_met1_av; //Загазованность по метанолу QISA-1, порог 2
UVI_DI_Trend.Gas_met1_Bad := UVI_DI.Gas_met1_Bad; //Загазованность по метанолу QISA-1, неисправность датчика
UVI_DI_Trend.Gas_met2_v := UVI_DI.Gas_met2_v; //Загазованность по метанолу QISA-2, порог 1
UVI_DI_Trend.Gas_met2_av := UVI_DI.Gas_met2_av; //Загазованность по метанолу QISA-2, порог 2
UVI_DI_Trend.Gas_met2_Bad := UVI_DI.Gas_met2_Bad; //Загазованность по метанолу QISA-2, неисправность датчика
UVI_DI_Trend.Vn_V1_ON := UVI_DI.Vn_V1_ON; //Вентсистема В1 работает
UVI_DI_Trend.Vn_V1_Alarm := UVI_DI.Vn_V1_Alarm; //Авария вентсистемы В1
UVI_DI_Trend.QS_ON := UVI_DI.QS_ON; //ШЩ. Секционный автоматический выключатель включен
UVI_DI_Trend.QS_OF := UVI_DI.QS_OF; //ШЩ. Секционный автоматический выключатель отключен
UVI_DI_Trend.QS_AOF := UVI_DI.QS_AOF; //ШЩ.  Секционный автоматический выключатель аварийно отключен
UVI_DI_Trend.U1_ok := UVI_DI.U1_ok; //ШЩ.  Сигнализация наличия напряжения. I секция шин
UVI_DI_Trend.Q1_ON := UVI_DI.Q1_ON; //ШЩ. Вводной автоматический выключатель включен
UVI_DI_Trend.Q1_OF := UVI_DI.Q1_OF; //ШЩ. Вводной автоматический выключатель отключен
UVI_DI_Trend.Q1_AOF := UVI_DI.Q1_AOF; //ШЩ. Вводной автоматический выключатель аварийно отключен
UVI_DI_Trend.Q2_ON := UVI_DI.Q2_ON; //ШЩ. Вводной автоматический выключатель включен
UVI_DI_Trend.Q2_OF := UVI_DI.Q2_OF; //ШЩ. Вводной автоматический выключатель отключен
UVI_DI_Trend.Q2_AOF := UVI_DI.Q2_AOF; //ШЩ.  Вводной автоматический выключатель аварийно отключен
UVI_DI_Trend.U2_ok := UVI_DI.U2_ok; //ШЩ.  Сигнализация наличия напряжения. II секция шин
UVI_DI_Trend.UZIP_Bad := UVI_DI.UZIP_Bad; //УЗИП неисправен
UVI_DI_Trend.Res_0 := UVI_DI.Res_0; //(Резерв)
UVI_DI_Trend.Res_1 := UVI_DI.Res_1; //(Резерв)
UVI_DI_Trend.Res_2 := UVI_DI.Res_2; //(Резерв)
UVI_DI_Trend.Res_3 := UVI_DI.Res_3; //(Резерв)
UVI_DI_Trend.Res_4 := UVI_DI.Res_4; //(Резерв)
UVI_DI_Trend.Res_5 := UVI_DI.Res_5; //(Резерв)
UVI_DI_Trend.Res_6 := UVI_DI.Res_6; //(Резерв)
UVI_DI_Trend.Res_7 := UVI_DI.Res_7; //(Резерв)
UVI_DI_Trend.Res_8 := UVI_DI.Res_8; //(Резерв)
UVI_DI_Trend.Res_9 := UVI_DI.Res_9; //(Резерв)
UVI_DI_Trend.Res_10 := UVI_DI.Res_10; //(Резерв)
UVI_DI_Trend.Res_11 := UVI_DI.Res_11; //(Резерв)
UVI_DI_Trend.Chk_AC220_SAU := UVI_DI.Chk_AC220_SAU; //Контроль основного питания  ~220 В
UVI_DI_Trend.Chk_DC220_SAU := UVI_DI.Chk_DC220_SAU; //Контроль резервного питания  =220 В
UVI_DI_Trend.Cabin_open := UVI_DI.Cabin_open; //Двери шкафа открыты
UVI_DI_Trend.Chk_razr := UVI_DI.Chk_razr; //Контроль исправности разрядников
UVI_DI_Trend.QF_ON := UVI_DI.QF_ON; //Автоматы питания включены
UVI_DI_Trend.DC24osn_Int_ok := UVI_DI.DC24osn_Int_ok; //Исправность осн. ИП =24В внутренних цепей
UVI_DI_Trend.DC24rez_Int_ok := UVI_DI.DC24rez_Int_ok; //Исправность рез. ИП =24В внутренних цепей
UVI_DI_Trend.DC24osn_Ext_ok := UVI_DI.DC24osn_Ext_ok; //Исправность осн. ИП =24В внешних цепей
UVI_DI_Trend.DC24rez_Ext_ok := UVI_DI.DC24rez_Ext_ok; //Исправность рез. ИП =24В внешних цепей
UVI_DI_Trend.Res_12 := UVI_DI.Res_12; //(Резерв)
UVI_DI_Trend.Res_13 := UVI_DI.Res_13; //(Резерв)
UVI_DI_Trend.Res_14 := UVI_DI.Res_14; //(Резерв)
UVI_DI_Trend.Res_15 := UVI_DI.Res_15; //(Резерв)
UVI_DI_Trend.Res_16 := UVI_DI.Res_16; //(Резерв)
UVI_DI_Trend.Res_17 := UVI_DI.Res_17; //(Резерв)
UVI_DI_Trend.Res_18 := UVI_DI.Res_18; //(Резерв)
//------------------------------DO---------------------------------------
UVI_DO_Trend.Lmet_E8_1_v := UVI_DO.Lmet_E8_1_v; //Верхний уровень в емкости E-8.1 для дренажа метанола
UVI_DO_Trend.Gas_Alarm1 := UVI_DO.Gas_Alarm1; //Загазованность по метанолу табло информационное
UVI_DO_Trend.Gas_Alarm2 := UVI_DO.Gas_Alarm2; //Загазованность по метанолу пост сигнализации
UVI_DO_Trend.Vn_V1_ON := UVI_DO.Vn_V1_ON; //Пуск вентсистемы В1
UVI_DO_Trend.Vn_V1_OF := UVI_DO.Vn_V1_OF; //Стоп вентсистемы В1
UVI_DO_Trend.Res_0 := UVI_DO.Res_0; //Резерв
UVI_DO_Trend.Res_1 := UVI_DO.Res_1; //Резерв
UVI_DO_Trend.Res_2 := UVI_DO.Res_2; //Резерв
UVI_DO_Trend.Res_3 := UVI_DO.Res_3; //Резерв
UVI_DO_Trend.Res_4 := UVI_DO.Res_4; //Резерв
UVI_DO_Trend.Res_5 := UVI_DO.Res_5; //Резерв
UVI_DO_Trend.Res_6 := UVI_DO.Res_6; //Резерв
UVI_DO_Trend.Res_7 := UVI_DO.Res_7; //Резерв
UVI_DO_Trend.Res_8 := UVI_DO.Res_8; //Резерв
UVI_DO_Trend.Res_9 := UVI_DO.Res_9; //Резерв
UVI_DO_Trend.Res_10 := UVI_DO.Res_10; //Резерв//--------------------------------------- Формирование трендовых переменых --------------------------------------------
//#####################################################################################################################

//------------------------------AI---------------------------------------
UVI_AI_Trend.Lmet_E8_1_v := UVI_AI_ToHMI.Lmet_E8_1_v.PV; //Верхний уровень в емкости E-8.1 дренажа метанола
UVI_AI_Trend.Gas_met1_v := UVI_AI_ToHMI.Gas_met1_v.PV; //Загазованность по метанолу (QISA-1)
UVI_AI_Trend.Gas_met2_v := UVI_AI_ToHMI.Gas_met2_v.PV; //Загазованность по метанолу (QISA-2)
UVI_AI_Trend.Res_0 := UVI_AI_ToHMI.Res_0.PV; //Резерв
UVI_AI_Trend.Uosn_SAU := UVI_AI_ToHMI.Uosn_SAU.PV; //Измерение основного напряжения
UVI_AI_Trend.Urez_SAU := UVI_AI_ToHMI.Urez_SAU.PV; //Измерение резервного напряжения
UVI_AI_Trend.Res_1 := UVI_AI_ToHMI.Res_1.PV; //Резерв
UVI_AI_Trend.Res_2 := UVI_AI_ToHMI.Res_2.PV; //Резерв
//------------------------------DI---------------------------------------
UVI_DI_Trend.Gas_met1_v := UVI_DI.Gas_met1_v; //Загазованность по метанолу QISA-1, порог 1
UVI_DI_Trend.Gas_met1_av := UVI_DI.Gas_met1_av; //Загазованность по метанолу QISA-1, порог 2
UVI_DI_Trend.Gas_met1_Bad := UVI_DI.Gas_met1_Bad; //Загазованность по метанолу QISA-1, неисправность датчика
UVI_DI_Trend.Gas_met2_v := UVI_DI.Gas_met2_v; //Загазованность по метанолу QISA-2, порог 1
UVI_DI_Trend.Gas_met2_av := UVI_DI.Gas_met2_av; //Загазованность по метанолу QISA-2, порог 2
UVI_DI_Trend.Gas_met2_Bad := UVI_DI.Gas_met2_Bad; //Загазованность по метанолу QISA-2, неисправность датчика
UVI_DI_Trend.Vn_V1_ON := UVI_DI.Vn_V1_ON; //Вентсистема В1 работает
UVI_DI_Trend.Vn_V1_Alarm := UVI_DI.Vn_V1_Alarm; //Авария вентсистемы В1
UVI_DI_Trend.QS_ON := UVI_DI.QS_ON; //ШЩ. Секционный автоматический выключатель включен
UVI_DI_Trend.QS_OF := UVI_DI.QS_OF; //ШЩ. Секционный автоматический выключатель отключен
UVI_DI_Trend.QS_AOF := UVI_DI.QS_AOF; //ШЩ.  Секционный автоматический выключатель аварийно отключен
UVI_DI_Trend.U1_ok := UVI_DI.U1_ok; //ШЩ.  Сигнализация наличия напряжения. I секция шин
UVI_DI_Trend.Q1_ON := UVI_DI.Q1_ON; //ШЩ. Вводной автоматический выключатель включен
UVI_DI_Trend.Q1_OF := UVI_DI.Q1_OF; //ШЩ. Вводной автоматический выключатель отключен
UVI_DI_Trend.Q1_AOF := UVI_DI.Q1_AOF; //ШЩ. Вводной автоматический выключатель аварийно отключен
UVI_DI_Trend.Q2_ON := UVI_DI.Q2_ON; //ШЩ. Вводной автоматический выключатель включен
UVI_DI_Trend.Q2_OF := UVI_DI.Q2_OF; //ШЩ. Вводной автоматический выключатель отключен
UVI_DI_Trend.Q2_AOF := UVI_DI.Q2_AOF; //ШЩ.  Вводной автоматический выключатель аварийно отключен
UVI_DI_Trend.U2_ok := UVI_DI.U2_ok; //ШЩ.  Сигнализация наличия напряжения. II секция шин
UVI_DI_Trend.UZIP_Bad := UVI_DI.UZIP_Bad; //УЗИП неисправен
UVI_DI_Trend.Res_0 := UVI_DI.Res_0; //(Резерв)
UVI_DI_Trend.Res_1 := UVI_DI.Res_1; //(Резерв)
UVI_DI_Trend.Res_2 := UVI_DI.Res_2; //(Резерв)
UVI_DI_Trend.Res_3 := UVI_DI.Res_3; //(Резерв)
UVI_DI_Trend.Res_4 := UVI_DI.Res_4; //(Резерв)
UVI_DI_Trend.Res_5 := UVI_DI.Res_5; //(Резерв)
UVI_DI_Trend.Res_6 := UVI_DI.Res_6; //(Резерв)
UVI_DI_Trend.Res_7 := UVI_DI.Res_7; //(Резерв)
UVI_DI_Trend.Res_8 := UVI_DI.Res_8; //(Резерв)
UVI_DI_Trend.Res_9 := UVI_DI.Res_9; //(Резерв)
UVI_DI_Trend.Res_10 := UVI_DI.Res_10; //(Резерв)
UVI_DI_Trend.Res_11 := UVI_DI.Res_11; //(Резерв)
UVI_DI_Trend.Chk_AC220_SAU := UVI_DI.Chk_AC220_SAU; //Контроль основного питания  ~220 В
UVI_DI_Trend.Chk_DC220_SAU := UVI_DI.Chk_DC220_SAU; //Контроль резервного питания  =220 В
UVI_DI_Trend.Cabin_open := UVI_DI.Cabin_open; //Двери шкафа открыты
UVI_DI_Trend.Chk_razr := UVI_DI.Chk_razr; //Контроль исправности разрядников
UVI_DI_Trend.QF_ON := UVI_DI.QF_ON; //Автоматы питания включены
UVI_DI_Trend.DC24osn_Int_ok := UVI_DI.DC24osn_Int_ok; //Исправность осн. ИП =24В внутренних цепей
UVI_DI_Trend.DC24rez_Int_ok := UVI_DI.DC24rez_Int_ok; //Исправность рез. ИП =24В внутренних цепей
UVI_DI_Trend.DC24osn_Ext_ok := UVI_DI.DC24osn_Ext_ok; //Исправность осн. ИП =24В внешних цепей
UVI_DI_Trend.DC24rez_Ext_ok := UVI_DI.DC24rez_Ext_ok; //Исправность рез. ИП =24В внешних цепей
UVI_DI_Trend.Res_12 := UVI_DI.Res_12; //(Резерв)
UVI_DI_Trend.Res_13 := UVI_DI.Res_13; //(Резерв)
UVI_DI_Trend.Res_14 := UVI_DI.Res_14; //(Резерв)
UVI_DI_Trend.Res_15 := UVI_DI.Res_15; //(Резерв)
UVI_DI_Trend.Res_16 := UVI_DI.Res_16; //(Резерв)
UVI_DI_Trend.Res_17 := UVI_DI.Res_17; //(Резерв)
UVI_DI_Trend.Res_18 := UVI_DI.Res_18; //(Резерв)
//------------------------------DO---------------------------------------
UVI_DO_Trend.Lmet_E8_1_v := UVI_DO.Lmet_E8_1_v; //Верхний уровень в емкости E-8.1 для дренажа метанола
UVI_DO_Trend.Gas_Alarm1 := UVI_DO.Gas_Alarm1; //Загазованность по метанолу табло информационное
UVI_DO_Trend.Gas_Alarm2 := UVI_DO.Gas_Alarm2; //Загазованность по метанолу пост сигнализации
UVI_DO_Trend.Vn_V1_ON := UVI_DO.Vn_V1_ON; //Пуск вентсистемы В1
UVI_DO_Trend.Vn_V1_OF := UVI_DO.Vn_V1_OF; //Стоп вентсистемы В1
UVI_DO_Trend.Res_0 := UVI_DO.Res_0; //Резерв
UVI_DO_Trend.Res_1 := UVI_DO.Res_1; //Резерв
UVI_DO_Trend.Res_2 := UVI_DO.Res_2; //Резерв
UVI_DO_Trend.Res_3 := UVI_DO.Res_3; //Резерв
UVI_DO_Trend.Res_4 := UVI_DO.Res_4; //Резерв
UVI_DO_Trend.Res_5 := UVI_DO.Res_5; //Резерв
UVI_DO_Trend.Res_6 := UVI_DO.Res_6; //Резерв
UVI_DO_Trend.Res_7 := UVI_DO.Res_7; //Резерв
UVI_DO_Trend.Res_8 := UVI_DO.Res_8; //Резерв
UVI_DO_Trend.Res_9 := UVI_DO.Res_9; //Резерв
UVI_DO_Trend.Res_10 := UVI_DO.Res_10; //Резерв]]></ST>
        </Function>
    </FBLibrary>
</Program>
